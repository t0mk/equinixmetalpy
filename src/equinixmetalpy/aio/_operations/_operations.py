# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.3, generator: @autorest/python@6.0.1)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import (
    Any,
    Callable,
    Dict,
    IO,
    List,
    Optional,
    TypeVar,
    Union,
    cast,
    overload,
)

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._operations._operations import (
    build_accept_invitation_request,
    build_accept_transfer_request_request,
    build_assign_native_vlan_request,
    build_assign_port_request,
    build_bond_port_request,
    build_check_capacity_for_facility_request,
    build_check_capacity_for_metro_request,
    build_consume_verification_request_request,
    build_convert_layer2_request,
    build_convert_layer3_request,
    build_create_api_key_request,
    build_create_bgp_session_request,
    build_create_device_batch_request,
    build_create_device_request,
    build_create_email_request,
    build_create_interconnection_port_virtual_circuit_request,
    build_create_ip_assignment_request,
    build_create_license_request,
    build_create_metal_gateway_request,
    build_create_organization_interconnection_request,
    build_create_organization_invitation_request,
    build_create_organization_project_request,
    build_create_organization_request,
    build_create_password_reset_token_request,
    build_create_payment_method_request,
    build_create_port_vlan_assignment_batch_request,
    build_create_project_api_key_request,
    build_create_project_interconnection_request,
    build_create_project_invitation_request,
    build_create_project_request,
    build_create_project_ssh_key_request,
    build_create_self_service_reservation_request,
    build_create_spot_market_request_request,
    build_create_ssh_key_request,
    build_create_transfer_request_request,
    build_create_user_request,
    build_create_validation_request_request,
    build_create_virtual_network_request,
    build_create_vrf_request,
    build_decline_invitation_request,
    build_decline_transfer_request_request,
    build_delete_api_key_request,
    build_delete_batch_request,
    build_delete_bgp_session_request,
    build_delete_device_request,
    build_delete_email_request,
    build_delete_interconnection_request,
    build_delete_ip_address_request,
    build_delete_license_request,
    build_delete_membership_request,
    build_delete_metal_gateway_request,
    build_delete_native_vlan_request,
    build_delete_organization_request,
    build_delete_payment_method_request,
    build_delete_project_request,
    build_delete_spot_market_request_request,
    build_delete_ssh_key_request,
    build_delete_user_api_key_request,
    build_delete_virtual_circuit_request,
    build_delete_virtual_network_request,
    build_delete_vrf_request,
    build_disable_tfa_app_request,
    build_disable_tfa_sms_request,
    build_disbond_port_request,
    build_enable_tfa_app_request,
    build_enable_tfa_sms_request,
    build_find_api_keys_request,
    build_find_batch_by_id_request,
    build_find_batches_by_project_request,
    build_find_bgp_config_by_project_request,
    build_find_bgp_session_by_id_request,
    build_find_bgp_sessions_request,
    build_find_capacity_for_facility_request,
    build_find_capacity_for_metro_request,
    build_find_current_user_request,
    build_find_device_by_id_request,
    build_find_device_customdata_request,
    build_find_device_events_request,
    build_find_device_metadata_by_id_request,
    build_find_device_ssh_keys_request,
    build_find_device_usages_request,
    build_find_device_userdata_by_id_request,
    build_find_email_by_id_request,
    build_find_ensure_otp_request,
    build_find_event_by_id_request,
    build_find_events_request,
    build_find_facilities_by_organization_request,
    build_find_facilities_by_project_request,
    build_find_facilities_request,
    build_find_global_bgp_ranges_request,
    build_find_hardware_reservation_by_id_request,
    build_find_incidents_request,
    build_find_instance_bandwidth_request,
    build_find_interconnection_events_request,
    build_find_interconnection_port_events_request,
    build_find_invitation_by_id_request,
    build_find_invitations_request,
    build_find_ip_address_by_id_request,
    build_find_ip_address_customdata_request,
    build_find_ip_assignment_customdata_request,
    build_find_ip_assignments_request,
    build_find_ip_availabilities_request,
    build_find_ip_reservation_customdata_request,
    build_find_ip_reservations_request,
    build_find_license_by_id_request,
    build_find_membership_by_id_request,
    build_find_metal_gateway_by_id_request,
    build_find_metal_gateways_by_project_request,
    build_find_metro_spot_market_prices_request,
    build_find_metros_request,
    build_find_operating_system_version_request,
    build_find_operating_systems_by_organization_request,
    build_find_operating_systems_request,
    build_find_organization_by_id_request,
    build_find_organization_capacity_per_facility_request,
    build_find_organization_capacity_per_metro_request,
    build_find_organization_customdata_request,
    build_find_organization_devices_request,
    build_find_organization_events_request,
    build_find_organization_invitations_request,
    build_find_organization_payment_methods_request,
    build_find_organization_projects_request,
    build_find_organization_transfers_request,
    build_find_organizations_request,
    build_find_payment_method_by_id_request,
    build_find_plans_by_organization_request,
    build_find_plans_by_project_request,
    build_find_plans_request,
    build_find_port_by_id_request,
    build_find_port_vlan_assignment_batch_by_port_id_and_batch_id_request,
    build_find_port_vlan_assignment_batches_request,
    build_find_port_vlan_assignment_by_port_id_and_assignment_id_request,
    build_find_port_vlan_assignments_request,
    build_find_project_api_keys_request,
    build_find_project_bgp_sessions_request,
    build_find_project_by_id_request,
    build_find_project_customdata_request,
    build_find_project_devices_request,
    build_find_project_events_request,
    build_find_project_hardware_reservations_request,
    build_find_project_invitations_request,
    build_find_project_licenses_request,
    build_find_project_memberships_request,
    build_find_project_ssh_keys_request,
    build_find_project_usage_request,
    build_find_projects_request,
    build_find_recovery_codes_request,
    build_find_self_service_reservation_request,
    build_find_self_service_reservations_request,
    build_find_spot_market_prices_history_request,
    build_find_spot_market_prices_request,
    build_find_spot_market_request_by_id_request,
    build_find_ssh_key_by_id_request,
    build_find_ssh_keys_request,
    build_find_traffic_request,
    build_find_transfer_request_by_id_request,
    build_find_user_by_id_request,
    build_find_user_customdata_request,
    build_find_users_request,
    build_find_virtual_circuit_events_request,
    build_find_virtual_networks_request,
    build_find_vrf_by_id_request,
    build_find_vrf_ip_reservations_request,
    build_find_vrfs_request,
    build_get_bgp_neighbor_data_request,
    build_get_interconnection_port_request,
    build_get_interconnection_request,
    build_get_metro_request,
    build_get_virtual_circuit_request,
    build_get_virtual_network_request,
    build_list_interconnection_port_virtual_circuits_request,
    build_list_interconnection_ports_request,
    build_list_spot_market_requests_request,
    build_move_hardware_reservation_request,
    build_organization_list_interconnections_request,
    build_perform_action_request,
    build_project_list_interconnections_request,
    build_receive_codes_request,
    build_regenerate_codes_request,
    build_request_bgp_config_request,
    build_request_ip_reservation_request,
    build_request_suppert_request,
    build_reset_password_request,
    build_unassign_port_request,
    build_update_bgp_session_request,
    build_update_current_user_request,
    build_update_device_request,
    build_update_email_request,
    build_update_interconnection_request,
    build_update_ip_address_request,
    build_update_license_request,
    build_update_membership_request,
    build_update_organization_request,
    build_update_payment_method_request,
    build_update_project_request,
    build_update_ssh_key_request,
    build_update_virtual_circuit_request,
    build_update_vrf_request,
    build_validate_userdata_request,
)
from .._vendor import MixinABC

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]
]


class ClientOperationsMixin(MixinABC):  # pylint: disable=too-many-public-methods
    @distributed_trace_async
    async def delete_api_key(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the API key.

        Deletes the API key.

        :param id: API Key UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_api_key_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_batch(
        self, id: str, *, remove_associated_instances: bool = False, **kwargs: Any
    ) -> Optional[JSON]:
        """Delete the Batch.

        Deletes the Batch.

        :param id: Batch UUID. Required.
        :type id: str
        :keyword remove_associated_instances: Delete all instances created from this batch. Default
         value is False.
        :paramtype remove_associated_instances: bool
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_batch_request(
            id=id,
            remove_associated_instances=remove_associated_instances,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_batch_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a Batch.

        Returns a Batch.

        :param id: Batch UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "error_messages": [
                        "str"  # Optional.
                    ],
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "quantity": 0,  # Optional.
                    "state": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_batch_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_bgp_session(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the BGP session.

        Deletes the BGP session.

        :param id: BGP session UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_bgp_session_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_bgp_session_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a BGP session.

        Returns a BGP session.

        :param id: BGP session UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address_family": "str",  # Required. Known values are: "ipv4" and "ipv6".
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "default_route": bool,  # Optional.
                    "device": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "learned_routes": [
                        "str"  # Optional.
                    ],
                    "status": "str",  # Optional. The status of the BGP Session. Multiple status
                      values may be reported when the device is connected to multiple switches, one
                      value per switch. Each status will start with "unknown" and progress to "up" or
                      "down" depending on the connected device. Subsequent "unknown" values indicate a
                      problem acquiring status from the switch. Known values are: "unknown", "up", and
                      "down".
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_bgp_session_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def update_bgp_session(
        self, id: str, body: bool, **kwargs: Any
    ) -> Optional[JSON]:
        """Update the BGP session.

        Updates the BGP session by either enabling or disabling the default route functionality.

        :param id: BGP session UUID. Required.
        :type id: str
        :param body: Default route. Required.
        :type body: bool
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", "application/json")
        )  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        _json = body

        request = build_update_bgp_session_request(
            id=id,
            content_type=content_type,
            json=_json,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_capacity_for_facility(self, **kwargs: Any) -> JSON:
        """View capacity.

        Returns a list of facilities and plans with their current capacity.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "capacity": {
                        "ams1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "atl1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "dfw1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ewr1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "fra1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "iad1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "lax1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "nrt1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ord1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sea1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sin1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sjc1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "syd1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "yyz1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        }
                    }
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_capacity_for_facility_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def check_capacity_for_facility(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Check capacity.

        Validates if a deploy can be fulfilled.

        :param body: Facility to check capacity in. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "servers": [
                        {
                            "facility": "str",  # Optional.
                            "plan": "str",  # Optional.
                            "quantity": "str"  # Optional.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "servers": [
                        {
                            "available": bool,  # Optional.
                            "facility": "str",  # Optional.
                            "plan": "str",  # Optional.
                            "quantity": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def check_capacity_for_facility(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Check capacity.

        Validates if a deploy can be fulfilled.

        :param body: Facility to check capacity in. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "servers": [
                        {
                            "available": bool,  # Optional.
                            "facility": "str",  # Optional.
                            "plan": "str",  # Optional.
                            "quantity": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def check_capacity_for_facility(
        self, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Check capacity.

        Validates if a deploy can be fulfilled.

        :param body: Facility to check capacity in. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "servers": [
                        {
                            "available": bool,  # Optional.
                            "facility": "str",  # Optional.
                            "plan": "str",  # Optional.
                            "quantity": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_check_capacity_for_facility_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_capacity_for_metro(self, **kwargs: Any) -> JSON:
        """View capacity for metros.

        Returns a list of metros and plans with their current capacity.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "capacity": {
                        "am": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "at": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ch": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "da": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "dc": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "fr": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "hk": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "la": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ld": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "md": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ny": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "pa": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "se": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sg": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sl": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sp": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sv": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sy": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "tr": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ty": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        }
                    }
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_capacity_for_metro_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def check_capacity_for_metro(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Check capacity for a metro.

        Validates if a deploy can be fulfilled in a metro.

        :param body: Metro to check capacity in. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "servers": [
                        {
                            "metro": "str",  # Optional. The metro ID or code to check
                              the capacity in.
                            "plan": "str",  # Optional. The plan ID or slug to check the
                              capacity of.
                            "quantity": "str"  # Optional. The number of servers to check
                              the capacity of.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "servers": [
                        {
                            "available": bool,  # Optional. Returns true if there is
                              enough capacity in the metro to fulfill the quantity set. Returns false
                              if there is not enough.
                            "metro": "str",  # Optional. The metro ID or code sent to
                              check capacity.
                            "plan": "str",  # Optional. The plan ID or slug sent to check
                              capacity.
                            "quantity": "str"  # Optional. The number of servers sent to
                              check capacity.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def check_capacity_for_metro(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Check capacity for a metro.

        Validates if a deploy can be fulfilled in a metro.

        :param body: Metro to check capacity in. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "servers": [
                        {
                            "available": bool,  # Optional. Returns true if there is
                              enough capacity in the metro to fulfill the quantity set. Returns false
                              if there is not enough.
                            "metro": "str",  # Optional. The metro ID or code sent to
                              check capacity.
                            "plan": "str",  # Optional. The plan ID or slug sent to check
                              capacity.
                            "quantity": "str"  # Optional. The number of servers sent to
                              check capacity.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def check_capacity_for_metro(
        self, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Check capacity for a metro.

        Validates if a deploy can be fulfilled in a metro.

        :param body: Metro to check capacity in. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "servers": [
                        {
                            "available": bool,  # Optional. Returns true if there is
                              enough capacity in the metro to fulfill the quantity set. Returns false
                              if there is not enough.
                            "metro": "str",  # Optional. The metro ID or code sent to
                              check capacity.
                            "plan": "str",  # Optional. The plan ID or slug sent to check
                              capacity.
                            "quantity": "str"  # Optional. The number of servers sent to
                              check capacity.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_check_capacity_for_metro_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_interconnection(self, connection_id: str, **kwargs: Any) -> JSON:
        """Delete interconnection.

        Delete a interconnection, its associated ports and virtual circuits.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_delete_interconnection_request(
            connection_id=connection_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_interconnection(self, connection_id: str, **kwargs: Any) -> JSON:
        """Get interconnection.

        Get the details of a interconnection.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_interconnection_request(
            connection_id=connection_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_interconnection(
        self,
        connection_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update interconnection.

        Update the details of a interconnection.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :param body: Updated interconnection details. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "redundancy": "str",  # Optional. Updating from 'redundant' to 'primary' will
                      remove a secondary port, while updating from 'primary' to 'redundant' will add
                      one.
                    "tags": [
                        "str"  # Optional.
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_interconnection(
        self,
        connection_id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update interconnection.

        Update the details of a interconnection.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :param body: Updated interconnection details. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_interconnection(
        self, connection_id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update interconnection.

        Update the details of a interconnection.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :param body: Updated interconnection details. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_interconnection_request(
            connection_id=connection_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_interconnection_events(
        self,
        connection_id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve interconnection events.

        Returns a list of the interconnection events.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "interpolated": "str",  # Optional.
                    "relationships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional.
                    "type": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_interconnection_events_request(
            connection_id=connection_id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list_interconnection_ports(
        self, connection_id: str, **kwargs: Any
    ) -> JSON:
        """List a interconnection's ports.

        List the ports associated to an interconnection.

        :param connection_id: UUID of the interconnection. Required.
        :type connection_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ports": [
                        {
                            "id": "str",  # Optional.
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ]
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_list_interconnection_ports_request(
            connection_id=connection_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_interconnection_port(
        self, connection_id: str, id: str, **kwargs: Any
    ) -> JSON:
        """Get a interconnection port.

        Get the details of an interconnection port.

        :param connection_id: UUID of the interconnection. Required.
        :type connection_id: str
        :param id: Port UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "role": "str",  # Optional. Either 'primary' or 'secondary'. Known values
                      are: "primary" and "secondary".
                    "status": "str",  # Optional. For both Fabric VCs and Dedicated Ports, this
                      will be 'requested' on creation and 'deleting' on deletion. Once the Fabric VC
                      has found its corresponding Fabric connection, this will turn to 'active'. For
                      Dedicated Ports, once the dedicated port is associated, this will also turn to
                      'active'. For Fabric VCs, this can turn into an 'expired' state if the service
                      token associated is expired. Known values are: "requested", "active", "deleting",
                      and "expired".
                    "switch_id": "str",  # Optional. A switch 'short ID'.
                    "virtual_circuits": {
                        "virtual_circuits": [
                            {}
                        ]
                    }
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_interconnection_port_request(
            connection_id=connection_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_interconnection_port_events(
        self,
        connection_id: str,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve interconnection port events.

        Returns a list of the interconnection port events.

        :param connection_id: Interconnection UUID. Required.
        :type connection_id: str
        :param id: Interconnection Port UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "interpolated": "str",  # Optional.
                    "relationships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional.
                    "type": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_interconnection_port_events_request(
            connection_id=connection_id,
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list_interconnection_port_virtual_circuits(
        self, connection_id: str, port_id: str, **kwargs: Any
    ) -> JSON:
        """List a interconnection port's virtual circuits.

        List the virtual circuit record(s) associatiated with a particular interconnection port.

        :param connection_id: UUID of the interconnection. Required.
        :type connection_id: str
        :param port_id: UUID of the interconnection port. Required.
        :type port_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "virtual_circuits": [
                        {}
                    ]
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_list_interconnection_port_virtual_circuits_request(
            connection_id=connection_id,
            port_id=port_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_interconnection_port_virtual_circuit(
        self,
        connection_id: str,
        port_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a new Virtual Circuit.

        Create a new Virtual Circuit on a Dedicated Port. To create a regular Virtual Circuit, specify
        a Virtual Network record and an NNI VLAN value. To create a VRF-based Virtual Circuit, specify
        the VRF ID and subnet, along with the NNI VLAN value.

        :param connection_id: UUID of the interconnection. Required.
        :type connection_id: str
        :param port_id: UUID of the interconnection port. Required.
        :type port_id: str
        :param body: Virtual Circuit details. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_interconnection_port_virtual_circuit(
        self,
        connection_id: str,
        port_id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a new Virtual Circuit.

        Create a new Virtual Circuit on a Dedicated Port. To create a regular Virtual Circuit, specify
        a Virtual Network record and an NNI VLAN value. To create a VRF-based Virtual Circuit, specify
        the VRF ID and subnet, along with the NNI VLAN value.

        :param connection_id: UUID of the interconnection. Required.
        :type connection_id: str
        :param port_id: UUID of the interconnection port. Required.
        :type port_id: str
        :param body: Virtual Circuit details. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_interconnection_port_virtual_circuit(
        self, connection_id: str, port_id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a new Virtual Circuit.

        Create a new Virtual Circuit on a Dedicated Port. To create a regular Virtual Circuit, specify
        a Virtual Network record and an NNI VLAN value. To create a VRF-based Virtual Circuit, specify
        the VRF ID and subnet, along with the NNI VLAN value.

        :param connection_id: UUID of the interconnection. Required.
        :type connection_id: str
        :param port_id: UUID of the interconnection port. Required.
        :type port_id: str
        :param body: Virtual Circuit details. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_interconnection_port_virtual_circuit_request(
            connection_id=connection_id,
            port_id=port_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_device(
        self, id: str, *, force_delete: Optional[bool] = None, **kwargs: Any
    ) -> Optional[JSON]:
        """Delete the device.

        Deletes a device and deprovisions it in our datacenter.

        :param id: Device UUID. Required.
        :type id: str
        :keyword force_delete: Force the deletion of the device, by detaching any storage volume still
         active. Default value is None.
        :paramtype force_delete: bool
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_device_request(
            id=id,
            force_delete=force_delete,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_device_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a device.

        Type-specific options (such as facility for baremetal devices) will be included as part of the
        main data structure.
                                 State value can be one of: active inactive queued or provisioning.

        :param id: Device UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_device_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_device(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the device.

        Updates the device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: Facility to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "hostname": "str",  # Optional.
                    "ipxe_script_url": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "network_frozen": bool,  # Optional. If true, this instance can not be
                      converted to a different network type.
                    "spot_instance": bool,  # Optional. Can be set to false to convert a
                      spot-market instance to on-demand.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "userdata": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_device(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the device.

        Updates the device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: Facility to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_device(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the device.

        Updates the device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: Facility to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_device_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def perform_action(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Perform an action.

        Performs an action for the given device.  Possible actions include: power_on, power_off,
        reboot, reinstall, and rescue (reboot the device into rescue OS.).

        :param id: Device UUID. Required.
        :type id: str
        :param body: Action to perform. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "deprovision_fast": bool,  # Optional. When type is ``reinstall``"" ,
                      enabling fast deprovisioning will bypass full disk wiping.
                    "force_delete": bool,  # Optional. May be required to perform actions under
                      certain conditions.
                    "ipxe_script_url": "str",  # Optional. When type is ``reinstall``"" , use
                      this ``ipxe_script_url`` ("" ``operating_system`` must be ``custom_ipxe``"" ,
                      defaults to the current ``ipxe_script_url``"" ).
                    "operating_system": "str",  # Optional. When type is ``reinstall``"" , use
                      this ``operating_system`` (defaults to the current ``operating system``"" ).
                    "preserve_data": bool,  # Optional. When type is ``reinstall``"" , preserve
                      the existing data on all disks except the operating-system disk.
                    "type": "str"  # Action to perform. See Device.actions for possible actions.
                      Required. Known values are: "power_on", "power_off", "reboot", "rescue", and
                      "reinstall".
                }

                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def perform_action(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Perform an action.

        Performs an action for the given device.  Possible actions include: power_on, power_off,
        reboot, reinstall, and rescue (reboot the device into rescue OS.).

        :param id: Device UUID. Required.
        :type id: str
        :param body: Action to perform. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def perform_action(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        """Perform an action.

        Performs an action for the given device.  Possible actions include: power_on, power_off,
        reboot, reinstall, and rescue (reboot the device into rescue OS.).

        :param id: Device UUID. Required.
        :type id: str
        :param body: Action to perform. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_perform_action_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_instance_bandwidth(
        self, id: str, *, from_parameter: str, until: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve an instance bandwidth.

        Retrieve an instance bandwidth for a given period of time.

        :param id: Device UUID. Required.
        :type id: str
        :keyword from_parameter: Timestamp from range. Required.
        :paramtype from_parameter: str
        :keyword until: Timestamp to range. Required.
        :paramtype until: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_instance_bandwidth_request(
            id=id,
            from_parameter=from_parameter,
            until=until,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def get_bgp_neighbor_data(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve BGP neighbor data for this device.

        Provides a summary of the BGP neighbor data associated to the BGP sessions for this device.

        :param id: Device UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bgp_neighbors": [
                        {
                            "address_family": 0,  # Optional. Address Family for IP
                              Address. Accepted values are 4 or 6.
                            "customer_as": 0,  # Optional. The customer's ASN. In a local
                              BGP deployment, this will be an internal ASN used to route within the
                              data center. For a global BGP deployment, this will be the your own ASN,
                              configured when you set up BGP for your project.
                            "customer_ip": "str",  # Optional. The device's IP address.
                              For an IPv4 BGP session, this is typically the private bond0 address for
                              the device.
                            "md5_enabled": bool,  # Optional. True if an MD5 password is
                              configured for the project.
                            "md5_password": "str",  # Optional. The MD5 password
                              configured for the project, if set.
                            "multihop": bool,  # Optional. True when the BGP session
                              should be configured as multihop.
                            "peer_as": 0,  # Optional. The Peer ASN to use when
                              configuring BGP on your device.
                            "peer_ips": [
                                "str"  # Optional. A list of one or more IP addresses
                                  to use for the Peer IP section of your BGP configuration. For
                                  non-multihop sessions, this will typically be a single gateway
                                  address for the device. For multihop sessions, it will be a list of
                                  IPs.
                            ],
                            "routes_in": [
                                {
                                    "exact": bool,  # Optional. A list of project
                                      subnets.
                                    "route": "str"  # Optional. A project
                                      network.
                                }
                            ],
                            "routes_out": [
                                {
                                    "exact": bool,  # Optional. A list of
                                      outgoing routes. Only populated if the BGP session has default
                                      route enabled.
                                    "route": "str"  # Optional. A list of
                                      outgoing routes. Only populated if the BGP session has default
                                      route enabled.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_bgp_neighbor_data_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_bgp_sessions(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve all BGP sessions.

        Provides a listing of available BGP sessions for the device.

        :param id: Device UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bgp_sessions": [
                        {
                            "address_family": "str",  # Required. Known values are:
                              "ipv4" and "ipv6".
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "default_route": bool,  # Optional.
                            "device": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "learned_routes": [
                                "str"  # Optional.
                            ],
                            "status": "str",  # Optional. The status of the BGP Session.
                              Multiple status values may be reported when the device is connected to
                              multiple switches, one value per switch. Each status will start with
                              "unknown" and progress to "up" or "down" depending on the connected
                              device. Subsequent "unknown" values indicate a problem acquiring status
                              from the switch. Known values are: "unknown", "up", and "down".
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_bgp_sessions_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_bgp_session(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a BGP session.

        Creates a BGP session.

        :param id: Device UUID. Required.
        :type id: str
        :param body: BGP session to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "address_family": "str",  # Optional. Address family for BGP session. Known
                      values are: "ipv4" and "ipv6".
                    "default_route": False  # Optional. Default value is False. Set the default
                      route policy.
                }

                # response body for status code(s): 201
                response == {
                    "address_family": "str",  # Required. Known values are: "ipv4" and "ipv6".
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "default_route": bool,  # Optional.
                    "device": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "learned_routes": [
                        "str"  # Optional.
                    ],
                    "status": "str",  # Optional. The status of the BGP Session. Multiple status
                      values may be reported when the device is connected to multiple switches, one
                      value per switch. Each status will start with "unknown" and progress to "up" or
                      "down" depending on the connected device. Subsequent "unknown" values indicate a
                      problem acquiring status from the switch. Known values are: "unknown", "up", and
                      "down".
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_bgp_session(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a BGP session.

        Creates a BGP session.

        :param id: Device UUID. Required.
        :type id: str
        :param body: BGP session to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address_family": "str",  # Required. Known values are: "ipv4" and "ipv6".
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "default_route": bool,  # Optional.
                    "device": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "learned_routes": [
                        "str"  # Optional.
                    ],
                    "status": "str",  # Optional. The status of the BGP Session. Multiple status
                      values may be reported when the device is connected to multiple switches, one
                      value per switch. Each status will start with "unknown" and progress to "up" or
                      "down" depending on the connected device. Subsequent "unknown" values indicate a
                      problem acquiring status from the switch. Known values are: "unknown", "up", and
                      "down".
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_bgp_session(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a BGP session.

        Creates a BGP session.

        :param id: Device UUID. Required.
        :type id: str
        :param body: BGP session to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address_family": "str",  # Required. Known values are: "ipv4" and "ipv6".
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "default_route": bool,  # Optional.
                    "device": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "learned_routes": [
                        "str"  # Optional.
                    ],
                    "status": "str",  # Optional. The status of the BGP Session. Multiple status
                      values may be reported when the device is connected to multiple switches, one
                      value per switch. Each status will start with "unknown" and progress to "up" or
                      "down" depending on the connected device. Subsequent "unknown" values indicate a
                      problem acquiring status from the switch. Known values are: "unknown", "up", and
                      "down".
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_bgp_session_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_device_customdata(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Retrieve the custom metadata of an instance.

        Provides the custom metadata stored for this instance in json format.

        :param id: Instance UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_device_customdata_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_device_events(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve device's events.

        Returns a list of events pertaining to a specific device.

        :param id: Device UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_device_events_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ip_assignments(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all ip assignments.

        Returns all ip assignments for a device.

        :param id: Device UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_ip_assignments_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_ip_assignment(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an ip assignment.

        Creates an ip assignment for a device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: IPAssignment to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "address": "str",  # Required.
                    "customdata": {},  # Optional. Any object.
                    "manageable": bool  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "address": "str",  # Optional.
                    "address_family": 0,  # Optional.
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "cidr": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "enabled": bool,  # Optional.
                    "gateway": "str",  # Optional.
                    "global_ip": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "manageable": bool,  # Optional.
                    "management": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "netmask": "str",  # Optional.
                    "network": "str",  # Optional.
                    "parent_block": {
                        "cidr": 0,  # Optional.
                        "href": "str",  # Optional.
                        "netmask": "str",  # Optional.
                        "network": "str"  # Optional.
                    },
                    "public": bool  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_ip_assignment(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an ip assignment.

        Creates an ip assignment for a device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: IPAssignment to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address": "str",  # Optional.
                    "address_family": 0,  # Optional.
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "cidr": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "enabled": bool,  # Optional.
                    "gateway": "str",  # Optional.
                    "global_ip": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "manageable": bool,  # Optional.
                    "management": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "netmask": "str",  # Optional.
                    "network": "str",  # Optional.
                    "parent_block": {
                        "cidr": 0,  # Optional.
                        "href": "str",  # Optional.
                        "netmask": "str",  # Optional.
                        "network": "str"  # Optional.
                    },
                    "public": bool  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_ip_assignment(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create an ip assignment.

        Creates an ip assignment for a device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: IPAssignment to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address": "str",  # Optional.
                    "address_family": 0,  # Optional.
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "cidr": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "enabled": bool,  # Optional.
                    "gateway": "str",  # Optional.
                    "global_ip": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "manageable": bool,  # Optional.
                    "management": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "netmask": "str",  # Optional.
                    "network": "str",  # Optional.
                    "parent_block": {
                        "cidr": 0,  # Optional.
                        "href": "str",  # Optional.
                        "netmask": "str",  # Optional.
                        "network": "str"  # Optional.
                    },
                    "public": bool  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_ip_assignment_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_device_metadata_by_id(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve metadata.

        Retrieve device metadata.

        :param id: Device UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "class": "str",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "facility": "str",  # Optional. The facility code of the instance.
                    "hostname": "str",  # Optional.
                    "id": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "metro": "str",  # Optional. The metro code of the instance.
                    "network": {
                        "addresses": [
                            "str"  # Optional.
                        ],
                        "interfaces": [
                            {}  # Optional.
                        ],
                        "network": {
                            "bonding": {
                                "link_aggregation": "str",  # Optional.
                                "mac": "str",  # Optional.
                                "mode": 0  # Optional.
                            }
                        }
                    },
                    "operating_system": {},  # Optional. Any object.
                    "plan": "str",  # Optional. The plan slug of the instance.
                    "private_subnets": [
                        "str"  # Optional. An array of the private subnets.
                    ],
                    "reserved": bool,  # Optional.
                    "specs": {},  # Optional. The specs of the plan version of the instance.
                    "ssh_keys": [
                        "str"  # Optional.
                    ],
                    "switch_short_id": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "volumes": [
                        "str"  # Optional.
                    ]
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_device_metadata_by_id_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_device_ssh_keys(
        self,
        id: str,
        *,
        search_string: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a device's ssh keys.

        Returns a collection of the device's ssh keys.

        :param id: Project UUID. Required.
        :type id: str
        :keyword search_string: Search by key, label, or fingerprint. Default value is None.
        :paramtype search_string: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ssh_keys": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "entity": {
                                "href": "str"  # Required.
                            },
                            "fingerprint": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "key": "str",  # Optional.
                            "label": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_device_ssh_keys_request(
            id=id,
            search_string=search_string,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_traffic(
        self,
        id: str,
        *,
        direction: str,
        interval: Optional[str] = None,
        bucket: Optional[str] = None,
        timeframe: Optional[JSON] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve device traffic.

        Returns traffic for a specific device.

        :param id: Device UUID. Required.
        :type id: str
        :keyword direction: Traffic direction. Known values are: "inbound" and "outbound". Required.
        :paramtype direction: str
        :keyword interval: Traffic interval. Known values are: "minute", "hour", "day", "week",
         "month", "year", "hour_of_day", "day_of_week", "day_of_month", and "month_of_year". Default
         value is None.
        :paramtype interval: str
        :keyword bucket: Traffic bucket. Known values are: "internal" and "external". Default value is
         None.
        :paramtype bucket: str
        :keyword timeframe: Default value is None.
        :paramtype timeframe: JSON
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_traffic_request(
            id=id,
            direction=direction,
            interval=interval,
            bucket=bucket,
            timeframe=timeframe,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_device_usages(
        self,
        id: str,
        *,
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all usages for device.

        Returns all usages for a device.

        :param id: Device UUID. Required.
        :type id: str
        :keyword created_after: Filter usages created after this date. Default value is None.
        :paramtype created_after: str
        :keyword created_before: Filter usages created before this date. Default value is None.
        :paramtype created_before: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "usages": [
                        {
                            "quantity": "str",  # Optional.
                            "total": "str",  # Optional.
                            "unit": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_device_usages_request(
            id=id,
            created_after=created_after,
            created_before=created_before,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_device_userdata_by_id(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve userdata.

        Retrieve device userdata.

        :param id: Device UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "userdata": "str"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_device_userdata_by_id_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ip_assignment_customdata(
        self, instance_id: str, id: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve the custom metadata of an IP Assignment.

        Provides the custom metadata stored for this IP Assignment in json format.

        :param instance_id: Instance UUID. Required.
        :type instance_id: str
        :param id: Ip Assignment UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_ip_assignment_customdata_request(
            instance_id=instance_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def create_email(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an email.

        Add a new email address to the current user.

        :param body: Email to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "address": "str"  # Required.
                }

                # response body for status code(s): 201
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_email(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an email.

        Add a new email address to the current user.

        :param body: Email to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_email(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create an email.

        Add a new email address to the current user.

        :param body: Email to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_email_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_email(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the email.

        Deletes the email.

        :param id: Email UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_email_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_email_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve an email.

        Provides one of the users emails.

        :param id: Email UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_email_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_email(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the email.

        Updates the email.

        :param id: Email UUID. Required.
        :type id: str
        :param body: email to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "default": bool  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_email(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the email.

        Updates the email.

        :param id: Email UUID. Required.
        :type id: str
        :param body: email to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_email(self, id: str, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Update the email.

        Updates the email.

        :param id: Email UUID. Required.
        :type id: str
        :param body: email to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address": "str",  # Optional.
                    "default": bool,  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "verified": bool  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_email_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_events(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve current user's events.

        Returns a list of the current users events.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_events_request(
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_event_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve an event.

        Returns a single event if the user has access.

        :param id: Event UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "interpolated": "str",  # Optional.
                    "relationships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional.
                    "type": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_event_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_facilities(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: List[str] = ["address"],
        **kwargs: Any
    ) -> JSON:
        """Retrieve all facilities.

        Provides a listing of available datacenters where you can provision Packet devices.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
         Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
         Default value is ['address'].
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "facilities": [
                        {
                            "address": {
                                "address": "str",  # Required.
                                "address2": "str",  # Optional.
                                "city": "str",  # Optional.
                                "coordinates": {
                                    "latitude": "str",  # Optional.
                                    "longitude": "str"  # Optional.
                                },
                                "country": "str",  # Required.
                                "state": "str",  # Optional.
                                "zip_code": "str"  # Required.
                            },
                            "code": "str",  # Optional.
                            "features": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "ip_ranges": [
                                "str"  # Optional. IP ranges registered in facility.
                                  Can be used for GeoIP location.
                            ],
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "name": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_facilities_request(
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_hardware_reservation_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a hardware reservation.

        Returns a single hardware reservation.

        :param id: HardwareReservation UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_hardware_reservation_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def move_hardware_reservation(
        self, id: str, body: str, **kwargs: Any
    ) -> JSON:
        """Move a hardware reservation.

        Move a hardware reservation to another project.

        :param id: Hardware Reservation UUID. Required.
        :type id: str
        :param body: Project UUID. Required.
        :type body: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "custom_rate": 0.0,  # Optional. Amount that will be charged for every
                      billing_cycle.
                    "device": {
                        "actions": [
                            {
                                "name": "str",  # Optional. Actions supported by the
                                  device instance.
                                "type": "str"  # Optional. Actions supported by the
                                  device instance.
                            }
                        ],
                        "always_pxe": bool,  # Optional.
                        "billing_cycle": "str",  # Optional.
                        "bonding_mode": 0,  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "created_by": {
                            "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL
                              of the User.
                            "created_at": "2020-02-20 00:00:00",  # Optional. When the
                              user was created.
                            "email": "str",  # Optional. Primary email address of the
                              User.
                            "first_name": "str",  # Optional. First name of the User.
                            "full_name": "str",  # Optional. Full name of the User.
                            "href": "str",  # Optional. API URL uniquely representing the
                              User.
                            "id": "str",  # ID of the User. Required.
                            "last_name": "str",  # Optional. Last name of the User.
                            "short_id": "str",  # Short ID of the User. Required.
                            "updated_at": "2020-02-20 00:00:00"  # Optional. When the
                              user details were last updated.
                        },
                        "customdata": {},  # Optional. Any object.
                        "description": "str",  # Optional.
                        "facility": {
                            "address": {
                                "address": "str",  # Required.
                                "address2": "str",  # Optional.
                                "city": "str",  # Optional.
                                "coordinates": {
                                    "latitude": "str",  # Optional.
                                    "longitude": "str"  # Optional.
                                },
                                "country": "str",  # Required.
                                "state": "str",  # Optional.
                                "zip_code": "str"  # Required.
                            },
                            "code": "str",  # Optional.
                            "features": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "ip_ranges": [
                                "str"  # Optional. IP ranges registered in facility.
                                  Can be used for GeoIP location.
                            ],
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "name": "str"  # Optional.
                        },
                        "hardware_reservation": {
                            "href": "str"  # Required.
                        },
                        "hostname": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "image_url": "str",  # Optional.
                        "ip_addresses": [
                            {
                                "address": "str",  # Optional.
                                "address_family": 0,  # Optional.
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "cidr": 0,  # Optional.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "enabled": bool,  # Optional.
                                "gateway": "str",  # Optional.
                                "global_ip": bool,  # Optional.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "manageable": bool,  # Optional.
                                "management": bool,  # Optional.
                                "metro": {
                                    "code": "str",  # Optional.
                                    "country": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "name": "str"  # Optional.
                                },
                                "netmask": "str",  # Optional.
                                "network": "str",  # Optional.
                                "parent_block": {
                                    "cidr": 0,  # Optional.
                                    "href": "str",  # Optional.
                                    "netmask": "str",  # Optional.
                                    "network": "str"  # Optional.
                                },
                                "public": bool  # Optional.
                            }
                        ],
                        "ipxe_script_url": "str",  # Optional.
                        "iqn": "str",  # Optional.
                        "locked": bool,  # Optional.
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "network_ports": [
                            {
                                "bond": {
                                    "id": "str",  # Optional. ID of the bonding
                                      port.
                                    "name": "str"  # Optional. Name of the port
                                      interface for the bond ("bond0").
                                },
                                "data": {
                                    "bonded": bool,  # Optional. Bonded is true
                                      for NetworkPort ports in a bond and NetworkBondPort ports that
                                      are active.
                                    "mac": "str"  # Optional. MAC address is set
                                      for NetworkPort ports.
                                },
                                "disbond_operation_supported": bool,  # Optional.
                                  Indicates whether or not the bond can be broken on the port (when
                                  applicable).
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "name": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "native_virtual_network": {
                                    "assigned_to": {
                                        "href": "str"  # Required.
                                    },
                                    "assigned_to_virtual_circuit": bool,  #
                                      Optional. True if the virtual network is attached to a virtual
                                      circuit. False if not.
                                    "description": "str",  # Optional. By
                                      default, servers at Equinix Metal are configured in a
                                      "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                      Protocol). Each 2-NIC server is configured with a single bond
                                      (namely bond0) with both interfaces eth0 and eth1 as members of
                                      the bond in a default Layer 3 mode. Some device plans may have a
                                      different number of ports and bonds available.
                                    "facility": {
                                        "href": "str"  # Required.
                                    },
                                    "href": "str",  # Optional. By default,
                                      servers at Equinix Metal are configured in a "u201cbonded"u201d
                                      mode using LACP (Link Aggregation Control Protocol). Each 2-NIC
                                      server is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "id": "str",  # Optional. By default, servers
                                      at Equinix Metal are configured in a "u201cbonded"u201d mode
                                      using LACP (Link Aggregation Control Protocol). Each 2-NIC server
                                      is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "instances": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "metal_gateways": [
                                        {
                                            "created_at": "2020-02-20
                                              00:00:00",  # Optional. A list of metal gateways
                                              currently associated to this Virtual Network.
                                            "gateway_address": "str",  #
                                              Optional. The gateway address with subnet CIDR value for
                                              this Metal Gateway. For example, a Metal Gateway using an
                                              IP reservation with block 10.1.2.0/27 would have a
                                              gateway address of 10.1.2.1/27.
                                            "href": "str",  # Optional. A
                                              list of metal gateways currently associated to this
                                              Virtual Network.
                                            "id": "str",  # Optional. A
                                              list of metal gateways currently associated to this
                                              Virtual Network.
                                            "state": "str",  # Optional.
                                              The current state of the Metal Gateway. 'Ready' indicates
                                              the gateway record has been configured, but is currently
                                              not active on the network. 'Active' indicates the gateway
                                              has been configured on the network. 'Deleting' is a
                                              temporary state used to indicate that the gateway is in
                                              the process of being un-configured from the network,
                                              after which the gateway record will be deleted. Known
                                              values are: "ready", "active", and "deleting".
                                            "updated_at": "2020-02-20
                                              00:00:00",  # Optional. A list of metal gateways
                                              currently associated to this Virtual Network.
                                            "vlan": 0  # Optional. The
                                              VLAN id of the Virtual Network record associated to this
                                              Metal Gateway.
                                        }
                                    ],
                                    "metro": {
                                        "href": "str"  # Required.
                                    },
                                    "metro_code": "str",  # Optional. The Metro
                                      code of the metro in which this Virtual Network is defined.
                                    "vxlan": 0  # Optional. By default, servers
                                      at Equinix Metal are configured in a "u201cbonded"u201d mode
                                      using LACP (Link Aggregation Control Protocol). Each 2-NIC server
                                      is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                },
                                "network_type": "str",  # Optional. Composite network
                                  type of the bond. Known values are: "layer2-bonded",
                                  "layer2-individual", "layer3", "hybrid", and "hybrid-bonded".
                                "type": "str",  # Optional. Type is either
                                  "NetworkBondPort" for bond ports or "NetworkPort" for bondable
                                  ethernet ports. Known values are: "NetworkPort" and
                                  "NetworkBondPort".
                                "virtual_networks": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            }
                        ],
                        "operating_system": {
                            "distro": "str",  # Optional.
                            "id": "str",  # Optional.
                            "licensed": bool,  # Optional. Licenced OS is priced
                              according to pricing property.
                            "name": "str",  # Optional.
                            "preinstallable": bool,  # Optional. Servers can be already
                              preinstalled with OS in order to shorten provision time.
                            "pricing": {},  # Optional. This object contains price per
                              time unit and optional multiplier value if licence price depends on
                              hardware plan or components (e.g. number of cores).
                            "provisionable_on": [
                                "str"  # Optional.
                            ],
                            "slug": "str",  # Optional.
                            "version": "str"  # Optional.
                        },
                        "plan": {
                            "available_in": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Facility.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          facilities the plan is available in, and the facility-based
                                          price if it is different from the default price.
                                    }
                                }
                            ],
                            "available_in_metros": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Metro.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          metros the plan is available in, and the metro-based price if
                                          it is different from the default price.
                                    }
                                }
                            ],
                            "class": "str",  # Optional.
                            "deployment_types": [
                                "str"  # Optional.
                            ],
                            "description": "str",  # Optional.
                            "id": "str",  # Optional.
                            "legacy": bool,  # Optional.
                            "line": "str",  # Optional. "baremetal"
                            "name": "str",  # Optional.
                            "pricing": {},  # Optional. Any object.
                            "slug": "str",  # Optional.
                            "specs": {
                                "cpus": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional.
                                    }
                                ],
                                "drives": [
                                    {
                                        "category": "str",  # Optional. Known
                                          values are: "boot", "cache", and "storage".
                                        "count": 0,  # Optional.
                                        "size": "str",  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "HDD", "SSD", and "NVME".
                                    }
                                ],
                                "features": {
                                    "raid": bool,  # Optional.
                                    "txt": bool,  # Optional.
                                    "uefi": bool  # Optional.
                                },
                                "nics": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "1Gbps", "10Gbps", and "25Gbps".
                                    }
                                ]
                            },
                            "type": "str"  # Optional. The plan type. Known values are:
                              "standard", "workload_optimized", and "custom".
                        },
                        "project": {
                            "href": "str"  # Required.
                        },
                        "project_lite": {
                            "href": "str"  # Required.
                        },
                        "provisioning_events": [
                            {
                                "body": "str",  # Optional.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "interpolated": "str",  # Optional.
                                "relationships": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "state": "str",  # Optional.
                                "type": "str"  # Optional.
                            }
                        ],
                        "provisioning_percentage": 0.0,  # Optional. Only visible while
                          device provisioning.
                        "root_password": "str",  # Optional. Root password is automatically
                          generated when server is provisioned and it is removed after 24 hours.
                        "short_id": "str",  # Optional.
                        "spot_instance": bool,  # Optional. Whether or not the device is a
                          spot instance.
                        "spot_price_max": 0.0,  # Optional. The maximum price per hour you
                          are willing to pay to keep this spot"ninstance.  If you are outbid, the
                          termination will be set allowing two"nminutes before shutdown.
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "state": "str",  # Optional. Known values are: "active", "deleted",
                          "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                          "post_provisioning", "powering_on", "powering_off", and "provisioning".
                        "switch_uuid": "str",  # Optional. Switch short id. This can be used
                          to determine if two devices are"nconnected to the same switch, for example.
                        "tags": [
                            "str"  # Optional.
                        ],
                        "termination_time": "2020-02-20 00:00:00",  # Optional. When the
                          device will be terminated. This is commonly set in advance for"nephemeral
                          spot market instances but this field may also be set with"non-demand and
                          reservation instances to automatically delete the resource"nat a given time.
                          The termination time can also be used to release a"nhardware reservation
                          instance at a given time, keeping the reservation"nopen for other uses.  On a
                          spot market device, the termination time will"nbe set automatically when
                          outbid.
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "user": "str",  # Optional.
                        "userdata": "str",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "need_of_service": bool,  # Optional. Whether this Device requires assistance
                      from Metal Equinix.
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "provisionable": bool,  # Optional. Whether the reserved server is
                      provisionable or not. Spare devices can't be provisioned unless they are
                      activated first.
                    "short_id": "str",  # Optional. Short version of the ID.
                    "spare": bool,  # Optional. Whether the Hardware Reservation is a spare.
                      Spare Hardware Reservations are used when a Hardware Reservations requires
                      service from Metal Equinix.
                    "switch_uuid": "str"  # Optional. Switch short id. This can be used to
                      determine if two devices are connected to the same switch, for example.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", "application/json")
        )  # type: str
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        _content = body

        request = build_move_hardware_reservation_request(
            id=id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_incidents(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve the number of incidents.

        Retrieve the number of incidents.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_incidents_request(
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_invitations(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve current user invitations.

        Returns all invitations in current user.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "invitations": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "roles": [
                                "str"  # Optional.
                            ],
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": {
                                "href": "str"  # Required.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_invitations_request(
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def decline_invitation(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Decline an invitation.

        Decline an invitation.

        :param id: Invitation UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_decline_invitation_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_invitation_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """View an invitation.

        Returns a single invitation. (It include the ``invitable`` to maintain backward compatibility
        but will be removed soon).

        :param id: Invitation UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_invitation_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def accept_invitation(self, id: str, **kwargs: Any) -> JSON:
        """Accept an invitation.

        Accept an invitation.

        :param id: Invitation UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_accept_invitation_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_ip_address(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Unassign an ip address.

        Note! This call can be used to un-assign an IP assignment or delete an IP reservation.
        Un-assign an IP address record. Use the assignment UUID you get after attaching the IP. This
        will remove the relationship between an IP and the device and will make the IP address
        available to be assigned to another device. Delete and IP reservation. Use the reservation UUID
        you get after adding the IP to the project. This will permanently delete the IP block
        reservation from the project.

        :param id: IP Address UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_ip_address_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_ip_address_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve an ip address.

        Returns a single ip address if the user has access.

        :param id: IP Address UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_ip_address_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def update_ip_address(
        self, id: str, *, details: str, customdata: str, **kwargs: Any
    ) -> JSON:
        """Update an ip address.

        Update details about an ip address.

        :param id: IP Address UUID. Required.
        :type id: str
        :keyword details: Notes for this IP Assignment. Required.
        :paramtype details: str
        :keyword customdata: Provides the custom metadata stored for this IP Assignment in json format.
         Required.
        :paramtype customdata: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_update_ip_address_request(
            id=id,
            details=details,
            customdata=customdata,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ip_availabilities(
        self, id: str, *, cidr: str, **kwargs: Any
    ) -> JSON:
        """Retrieve all available subnets of a particular reservation.

        Provides a list of IP resevations for a single project.

        :param id: IP Reservation UUID. Required.
        :type id: str
        :keyword cidr: Size of subnets in bits. Known values are: "20", "21", "22", "23", "24", "25",
         "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41",
         "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57",
         "58", "59", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "70", "71", "72", "73",
         "74", "75", "76", "77", "78", "79", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89",
         "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "100", "101", "102", "103", "104",
         "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117",
         "118", "119", "120", "121", "122", "123", "124", "125", "126", "127", and "128". Required.
        :paramtype cidr: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "available": [
                        "str"  # Optional.
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_ip_availabilities_request(
            id=id,
            cidr=cidr,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ip_address_customdata(
        self, id: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve the custom metadata of an IP Reservation or IP Assignment.

        Provides the custom metadata stored for this IP Reservation or IP Assignment in json format.

        :param id: Ip Reservation UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_ip_address_customdata_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_license(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the license.

        Deletes a license.

        :param id: License UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_license_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_license_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a license.

        Returns a license.

        :param id: License UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_license_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_license(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the license.

        Updates the license.

        :param id: License UUID. Required.
        :type id: str
        :param body: License to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "size": 0.0  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_license(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the license.

        Updates the license.

        :param id: License UUID. Required.
        :type id: str
        :param body: License to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_license(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the license.

        Updates the license.

        :param id: License UUID. Required.
        :type id: str
        :param body: License to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_license_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_metros(self, **kwargs: Any) -> JSON:
        """Retrieve all metros.

        Provides a listing of available metros.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "metros": [
                        {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_metros_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_metro(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve a specific Metro's details.

        Show the details for a metro, including name, code, and country.

        :param id: Metro UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "code": "str",  # Optional.
                    "country": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str"  # Optional.
                }
                # response body for status code(s): 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_metro_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_spot_market_prices(
        self,
        *,
        facility: Optional[str] = None,
        plan: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Get current spot market prices.

        Get Equinix Metal current spot market prices.

        :keyword facility: Facility to check spot market prices. Default value is None.
        :paramtype facility: str
        :keyword plan: Plan to check spot market prices. Default value is None.
        :paramtype plan: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "spot_market_prices": {
                        "ams1": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "atl1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "dfw1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "ewr1": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "fra1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "iad1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "lax1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "nrt1": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "ord1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "sea1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "sin1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "sjc1": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "syd1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "yyz1": {
                            "baremetal_1e": {
                                "price": 0.0  # Optional.
                            }
                        }
                    }
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_spot_market_prices_request(
            facility=facility,
            plan=plan,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_spot_market_prices_history(
        self,
        *,
        facility: str,
        plan: str,
        from_parameter: str,
        until: str,
        metro: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Get spot market prices for a given period of time.

        Get spot market prices for a given plan and facility in a fixed period of time

        *Note: In the ``200`` response, the property ``datapoints`` contains arrays of ``[float,
        integer]``.*.

        :keyword facility: Facility to check spot market prices. Required.
        :paramtype facility: str
        :keyword plan: Plan to check spot market prices. Required.
        :paramtype plan: str
        :keyword from_parameter: Timestamp from range. Required.
        :paramtype from_parameter: str
        :keyword until: Timestamp to range. Required.
        :paramtype until: str
        :keyword metro: Metro to check spot market price history. Default value is None.
        :paramtype metro: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "prices_history": {
                        "datapoints": [
                            [
                                0.0  # Optional.
                            ]
                        ]
                    }
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_spot_market_prices_history_request(
            facility=facility,
            plan=plan,
            from_parameter=from_parameter,
            until=until,
            metro=metro,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_metro_spot_market_prices(
        self, *, metro: Optional[str] = None, plan: Optional[str] = None, **kwargs: Any
    ) -> JSON:
        """Get current spot market prices for metros.

        Get Equinix Metal current spot market prices for all metros.

        :keyword metro: Metro to filter spot market prices. Default value is None.
        :paramtype metro: str
        :keyword plan: Plan to filter spot market prices. Default value is None.
        :paramtype plan: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "spot_market_prices": {
                        "am": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "ch": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "da": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "la": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "ny": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "sg": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        },
                        "sv": {
                            "baremetal_0": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_1": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_2a2": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_3": {
                                "price": 0.0  # Optional.
                            },
                            "baremetal_s": {
                                "price": 0.0  # Optional.
                            },
                            "c2.medium.x86": {
                                "price": 0.0  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "price": 0.0  # Optional.
                            }
                        }
                    }
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_metro_spot_market_prices_request(
            metro=metro,
            plan=plan,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_membership(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the membership.

        Deletes the membership.

        :param id: Membership UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_membership_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_membership_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a membership.

        Returns a single membership.

        :param id: Membership UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_membership_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_membership(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the membership.

        Updates the membership.

        :param id: Membership UUID. Required.
        :type id: str
        :param body: Membership to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "role": [
                        "str"  # Optional.
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_membership(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the membership.

        Updates the membership.

        :param id: Membership UUID. Required.
        :type id: str
        :param body: Membership to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_membership(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the membership.

        Updates the membership.

        :param id: Membership UUID. Required.
        :type id: str
        :param body: Membership to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_membership_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_metal_gateway(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Deletes the metal gateway.

        Deletes a specific metal gateway.

        :param id: Metal Gateway UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_metal_gateway_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_metal_gateway_by_id(self, id: str, **kwargs: Any) -> JSON:
        """Returns the metal gateway.

        Returns a specific metal gateway.

        :param id: Metal Gateway UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_metal_gateway_by_id_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_operating_system_version(self, **kwargs: Any) -> JSON:
        """Retrieve all operating system versions.

        Provides a listing of available operating system versions.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "operating_systems": [
                        {
                            "distro": "str",  # Optional.
                            "id": "str",  # Optional.
                            "licensed": bool,  # Optional. Licenced OS is priced
                              according to pricing property.
                            "name": "str",  # Optional.
                            "preinstallable": bool,  # Optional. Servers can be already
                              preinstalled with OS in order to shorten provision time.
                            "pricing": {},  # Optional. This object contains price per
                              time unit and optional multiplier value if licence price depends on
                              hardware plan or components (e.g. number of cores).
                            "provisionable_on": [
                                "str"  # Optional.
                            ],
                            "slug": "str",  # Optional.
                            "version": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_operating_system_version_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_operating_systems(self, **kwargs: Any) -> JSON:
        """Retrieve all operating systems.

        Provides a listing of available operating systems to provision your new device with.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "operating_systems": [
                        {
                            "distro": "str",  # Optional.
                            "id": "str",  # Optional.
                            "licensed": bool,  # Optional. Licenced OS is priced
                              according to pricing property.
                            "name": "str",  # Optional.
                            "preinstallable": bool,  # Optional. Servers can be already
                              preinstalled with OS in order to shorten provision time.
                            "pricing": {},  # Optional. This object contains price per
                              time unit and optional multiplier value if licence price depends on
                              hardware plan or components (e.g. number of cores).
                            "provisionable_on": [
                                "str"  # Optional.
                            ],
                            "slug": "str",  # Optional.
                            "version": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_operating_systems_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organizations(
        self,
        *,
        personal: Optional[str] = None,
        without_projects: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all organizations.

        Returns a list of organizations that are accessible to the current user.

        :keyword personal: Include, exclude or show only personal organizations. Known values are:
         "include", "exclude", and "only". Default value is None.
        :paramtype personal: str
        :keyword without_projects: Include, exclude or show only organizations that have no projects.
         Known values are: "include", "exclude", and "only". Default value is None.
        :paramtype without_projects: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    },
                    "organizations": [
                        {
                            "address": {
                                "address": "str",  # Required.
                                "address2": "str",  # Optional.
                                "city": "str",  # Optional.
                                "coordinates": {
                                    "latitude": "str",  # Optional.
                                    "longitude": "str"  # Optional.
                                },
                                "country": "str",  # Required.
                                "state": "str",  # Optional.
                                "zip_code": "str"  # Required.
                            },
                            "billing_address": {
                                "address": "str",  # Required.
                                "address2": "str",  # Optional.
                                "city": "str",  # Optional.
                                "coordinates": {
                                    "latitude": "str",  # Optional.
                                    "longitude": "str"  # Optional.
                                },
                                "country": "str",  # Required.
                                "state": "str",  # Optional.
                                "zip_code": "str"  # Required.
                            },
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "credit_amount": 0.0,  # Optional.
                            "customdata": {},  # Optional. Any object.
                            "description": "str",  # Optional.
                            "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force
                              to all members to have enabled the two factor authentication after that
                              date, unless the value is null.
                            "id": "str",  # Optional.
                            "logo": b'bytes',  # Optional.
                            "members": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "memberships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "name": "str",  # Optional.
                            "projects": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "terms": 0,  # Optional.
                            "twitter": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "website": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organizations_request(
            personal=personal,
            without_projects=without_projects,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_organization(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an organization.

        Creates an organization.

        :param body: Organization to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "logo": b'bytes',  # Optional.
                    "name": "str",  # Optional.
                    "twitter": "str",  # Optional.
                    "website": "str"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_organization(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an organization.

        Creates an organization.

        :param body: Organization to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_organization(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create an organization.

        Creates an organization.

        :param body: Organization to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_organization_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_organization(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the organization.

        Deletes the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_organization_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_organization_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve an organization's details.

        Returns a single organization's details, if the user is authorized to view it.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_organization(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the organization.

        Updates the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Organization to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "logo": b'bytes',  # Optional.
                    "name": "str",  # Optional.
                    "twitter": "str",  # Optional.
                    "website": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_organization(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the organization.

        Updates the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Organization to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_organization(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the organization.

        Updates the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Organization to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "billing_address": {
                        "address": "str",  # Required.
                        "address2": "str",  # Optional.
                        "city": "str",  # Optional.
                        "coordinates": {
                            "latitude": "str",  # Optional.
                            "longitude": "str"  # Optional.
                        },
                        "country": "str",  # Required.
                        "state": "str",  # Optional.
                        "zip_code": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "credit_amount": 0.0,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "enforce_2fa_at": "2020-02-20 00:00:00",  # Optional. Force to all members to
                      have enabled the two factor authentication after that date, unless the value is
                      null.
                    "id": "str",  # Optional.
                    "logo": b'bytes',  # Optional.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "terms": 0,  # Optional.
                    "twitter": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "website": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_organization_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_capacity_per_facility(
        self, id: str, **kwargs: Any
    ) -> JSON:
        """View available hardware plans per Facility for given organization.

        Returns a list of facilities and plans with their current capacity.

        :param id: Organization UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "capacity": {
                        "ams1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "atl1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "dfw1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ewr1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "fra1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "iad1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "lax1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "nrt1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ord1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sea1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sin1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sjc1": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "syd1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        },
                        "yyz1": {
                            "baremetal_1e": {
                                "level": "str"  # Optional.
                            }
                        }
                    }
                }
                # response body for status code(s): 401, 403
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_capacity_per_facility_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_capacity_per_metro(
        self, id: str, **kwargs: Any
    ) -> JSON:
        """View available hardware plans per Metro for given organization.

        Returns a list of metros and plans with their current capacity.

        :param id: Organization UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "capacity": {
                        "am": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "at": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ch": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "da": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "dc": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "fr": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "hk": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "la": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ld": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "md": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ny": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "pa": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "se": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sg": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sl": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sp": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sv": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "sy": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "tr": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        },
                        "ty": {
                            "baremetal_0": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_1": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_2a2": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_3": {
                                "level": "str"  # Optional.
                            },
                            "baremetal_s": {
                                "level": "str"  # Optional.
                            },
                            "c2.medium.x86": {
                                "level": "str"  # Optional.
                            },
                            "m2.xlarge.x86": {
                                "level": "str"  # Optional.
                            }
                        }
                    }
                }
                # response body for status code(s): 401, 403
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_capacity_per_metro_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_customdata(
        self, id: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve the custom metadata of an organization.

        Provides the custom metadata stored for this organization in json format.

        :param id: Organization UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_organization_customdata_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_organization_devices(
        self,
        id: str,
        *,
        facility: Optional[str] = None,
        hostname: Optional[str] = None,
        reserved: Optional[bool] = None,
        tag: Optional[str] = None,
        type: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all devices of an organization.

        Provides a collection of devices for a given organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword facility: Filter by device facility. Default value is None.
        :paramtype facility: str
        :keyword hostname: Filter by partial hostname. Default value is None.
        :paramtype hostname: str
        :keyword reserved: Filter only reserved instances. Default value is None.
        :paramtype reserved: bool
        :keyword tag: Filter by device tag. Default value is None.
        :paramtype tag: str
        :keyword type: Filter by instance type (ondemand,spot,reserved). Default value is None.
        :paramtype type: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "devices": [
                        {
                            "actions": [
                                {
                                    "name": "str",  # Optional. Actions supported
                                      by the device instance.
                                    "type": "str"  # Optional. Actions supported
                                      by the device instance.
                                }
                            ],
                            "always_pxe": bool,  # Optional.
                            "billing_cycle": "str",  # Optional.
                            "bonding_mode": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "created_by": {
                                "avatar_thumb_url": "str",  # Optional. Avatar
                                  thumbnail URL of the User.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                  When the user was created.
                                "email": "str",  # Optional. Primary email address of
                                  the User.
                                "first_name": "str",  # Optional. First name of the
                                  User.
                                "full_name": "str",  # Optional. Full name of the
                                  User.
                                "href": "str",  # Optional. API URL uniquely
                                  representing the User.
                                "id": "str",  # ID of the User. Required.
                                "last_name": "str",  # Optional. Last name of the
                                  User.
                                "short_id": "str",  # Short ID of the User. Required.
                                "updated_at": "2020-02-20 00:00:00"  # Optional. When
                                  the user details were last updated.
                            },
                            "customdata": {},  # Optional. Any object.
                            "description": "str",  # Optional.
                            "facility": {
                                "address": {
                                    "address": "str",  # Required.
                                    "address2": "str",  # Optional.
                                    "city": "str",  # Optional.
                                    "coordinates": {
                                        "latitude": "str",  # Optional.
                                        "longitude": "str"  # Optional.
                                    },
                                    "country": "str",  # Required.
                                    "state": "str",  # Optional.
                                    "zip_code": "str"  # Required.
                                },
                                "code": "str",  # Optional.
                                "features": [
                                    "str"  # Optional.
                                ],
                                "id": "str",  # Optional.
                                "ip_ranges": [
                                    "str"  # Optional. IP ranges registered in
                                      facility. Can be used for GeoIP location.
                                ],
                                "metro": {
                                    "code": "str",  # Optional.
                                    "country": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "name": "str"  # Optional.
                                },
                                "name": "str"  # Optional.
                            },
                            "hardware_reservation": {
                                "href": "str"  # Required.
                            },
                            "hostname": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "image_url": "str",  # Optional.
                            "ip_addresses": [
                                {
                                    "address": "str",  # Optional.
                                    "address_family": 0,  # Optional.
                                    "assigned_to": {
                                        "href": "str"  # Required.
                                    },
                                    "cidr": 0,  # Optional.
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional.
                                    "enabled": bool,  # Optional.
                                    "gateway": "str",  # Optional.
                                    "global_ip": bool,  # Optional.
                                    "href": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "manageable": bool,  # Optional.
                                    "management": bool,  # Optional.
                                    "metro": {
                                        "code": "str",  # Optional.
                                        "country": "str",  # Optional.
                                        "id": "str",  # Optional.
                                        "name": "str"  # Optional.
                                    },
                                    "netmask": "str",  # Optional.
                                    "network": "str",  # Optional.
                                    "parent_block": {
                                        "cidr": 0,  # Optional.
                                        "href": "str",  # Optional.
                                        "netmask": "str",  # Optional.
                                        "network": "str"  # Optional.
                                    },
                                    "public": bool  # Optional.
                                }
                            ],
                            "ipxe_script_url": "str",  # Optional.
                            "iqn": "str",  # Optional.
                            "locked": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "network_ports": [
                                {
                                    "bond": {
                                        "id": "str",  # Optional. ID of the
                                          bonding port.
                                        "name": "str"  # Optional. Name of
                                          the port interface for the bond ("bond0").
                                    },
                                    "data": {
                                        "bonded": bool,  # Optional. Bonded
                                          is true for NetworkPort ports in a bond and NetworkBondPort
                                          ports that are active.
                                        "mac": "str"  # Optional. MAC address
                                          is set for NetworkPort ports.
                                    },
                                    "disbond_operation_supported": bool,  #
                                      Optional. Indicates whether or not the bond can be broken on the
                                      port (when applicable).
                                    "href": "str",  # Optional. By default,
                                      servers at Equinix Metal are configured in a "u201cbonded"u201d
                                      mode using LACP (Link Aggregation Control Protocol). Each 2-NIC
                                      server is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "id": "str",  # Optional. By default, servers
                                      at Equinix Metal are configured in a "u201cbonded"u201d mode
                                      using LACP (Link Aggregation Control Protocol). Each 2-NIC server
                                      is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "name": "str",  # Optional. By default,
                                      servers at Equinix Metal are configured in a "u201cbonded"u201d
                                      mode using LACP (Link Aggregation Control Protocol). Each 2-NIC
                                      server is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "native_virtual_network": {
                                        "assigned_to": {
                                            "href": "str"  # Required.
                                        },
                                        "assigned_to_virtual_circuit": bool,
                                          # Optional. True if the virtual network is attached to a
                                          virtual circuit. False if not.
                                        "description": "str",  # Optional. By
                                          default, servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "facility": {
                                            "href": "str"  # Required.
                                        },
                                        "href": "str",  # Optional. By
                                          default, servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "id": "str",  # Optional. By default,
                                          servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "instances": [
                                            {
                                                "href": "str"  #
                                                  Required.
                                            }
                                        ],
                                        "metal_gateways": [
                                            {
                                                "created_at":
                                                  "2020-02-20 00:00:00",  # Optional. A list of metal
                                                  gateways currently associated to this Virtual
                                                  Network.
                                                "gateway_address":
                                                  "str",  # Optional. The gateway address with subnet
                                                  CIDR value for this Metal Gateway. For example, a
                                                  Metal Gateway using an IP reservation with block
                                                  10.1.2.0/27 would have a gateway address of
                                                  10.1.2.1/27.
                                                "href": "str",  #
                                                  Optional. A list of metal gateways currently
                                                  associated to this Virtual Network.
                                                "id": "str",  #
                                                  Optional. A list of metal gateways currently
                                                  associated to this Virtual Network.
                                                "state": "str",  #
                                                  Optional. The current state of the Metal Gateway.
                                                  'Ready' indicates the gateway record has been
                                                  configured, but is currently not active on the
                                                  network. 'Active' indicates the gateway has been
                                                  configured on the network. 'Deleting' is a temporary
                                                  state used to indicate that the gateway is in the
                                                  process of being un-configured from the network,
                                                  after which the gateway record will be deleted. Known
                                                  values are: "ready", "active", and "deleting".
                                                "updated_at":
                                                  "2020-02-20 00:00:00",  # Optional. A list of metal
                                                  gateways currently associated to this Virtual
                                                  Network.
                                                "vlan": 0  #
                                                  Optional. The VLAN id of the Virtual Network record
                                                  associated to this Metal Gateway.
                                            }
                                        ],
                                        "metro": {
                                            "href": "str"  # Required.
                                        },
                                        "metro_code": "str",  # Optional. The
                                          Metro code of the metro in which this Virtual Network is
                                          defined.
                                        "vxlan": 0  # Optional. By default,
                                          servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                    },
                                    "network_type": "str",  # Optional. Composite
                                      network type of the bond. Known values are: "layer2-bonded",
                                      "layer2-individual", "layer3", "hybrid", and "hybrid-bonded".
                                    "type": "str",  # Optional. Type is either
                                      "NetworkBondPort" for bond ports or "NetworkPort" for bondable
                                      ethernet ports. Known values are: "NetworkPort" and
                                      "NetworkBondPort".
                                    "virtual_networks": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ]
                                }
                            ],
                            "operating_system": {
                                "distro": "str",  # Optional.
                                "id": "str",  # Optional.
                                "licensed": bool,  # Optional. Licenced OS is priced
                                  according to pricing property.
                                "name": "str",  # Optional.
                                "preinstallable": bool,  # Optional. Servers can be
                                  already preinstalled with OS in order to shorten provision time.
                                "pricing": {},  # Optional. This object contains
                                  price per time unit and optional multiplier value if licence price
                                  depends on hardware plan or components (e.g. number of cores).
                                "provisionable_on": [
                                    "str"  # Optional.
                                ],
                                "slug": "str",  # Optional.
                                "version": "str"  # Optional.
                            },
                            "plan": {
                                "available_in": [
                                    {
                                        "href": "str",  # Optional. href to
                                          the Facility.
                                        "price": {
                                            "hour": 0.0  # Optional.
                                              Shows which facilities the plan is available in, and the
                                              facility-based price if it is different from the default
                                              price.
                                        }
                                    }
                                ],
                                "available_in_metros": [
                                    {
                                        "href": "str",  # Optional. href to
                                          the Metro.
                                        "price": {
                                            "hour": 0.0  # Optional.
                                              Shows which metros the plan is available in, and the
                                              metro-based price if it is different from the default
                                              price.
                                        }
                                    }
                                ],
                                "class": "str",  # Optional.
                                "deployment_types": [
                                    "str"  # Optional.
                                ],
                                "description": "str",  # Optional.
                                "id": "str",  # Optional.
                                "legacy": bool,  # Optional.
                                "line": "str",  # Optional. "baremetal"
                                "name": "str",  # Optional.
                                "pricing": {},  # Optional. Any object.
                                "slug": "str",  # Optional.
                                "specs": {
                                    "cpus": [
                                        {
                                            "count": 0,  # Optional.
                                            "type": "str"  # Optional.
                                        }
                                    ],
                                    "drives": [
                                        {
                                            "category": "str",  #
                                              Optional. Known values are: "boot", "cache", and
                                              "storage".
                                            "count": 0,  # Optional.
                                            "size": "str",  # Optional.
                                            "type": "str"  # Optional.
                                              Known values are: "HDD", "SSD", and "NVME".
                                        }
                                    ],
                                    "features": {
                                        "raid": bool,  # Optional.
                                        "txt": bool,  # Optional.
                                        "uefi": bool  # Optional.
                                    },
                                    "nics": [
                                        {
                                            "count": 0,  # Optional.
                                            "type": "str"  # Optional.
                                              Known values are: "1Gbps", "10Gbps", and "25Gbps".
                                        }
                                    ]
                                },
                                "type": "str"  # Optional. The plan type. Known
                                  values are: "standard", "workload_optimized", and "custom".
                            },
                            "project": {
                                "href": "str"  # Required.
                            },
                            "project_lite": {
                                "href": "str"  # Required.
                            },
                            "provisioning_events": [
                                {
                                    "body": "str",  # Optional.
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional.
                                    "href": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "interpolated": "str",  # Optional.
                                    "relationships": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "state": "str",  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "provisioning_percentage": 0.0,  # Optional. Only visible
                              while device provisioning.
                            "root_password": "str",  # Optional. Root password is
                              automatically generated when server is provisioned and it is removed
                              after 24 hours.
                            "short_id": "str",  # Optional.
                            "spot_instance": bool,  # Optional. Whether or not the device
                              is a spot instance.
                            "spot_price_max": 0.0,  # Optional. The maximum price per
                              hour you are willing to pay to keep this spot"ninstance.  If you are
                              outbid, the termination will be set allowing two"nminutes before
                              shutdown.
                            "ssh_keys": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional. Known values are: "active",
                              "deleted", "deprovisioning", "failed", "inactive", "queued",
                              "reinstalling", "post_provisioning", "powering_on", "powering_off", and
                              "provisioning".
                            "switch_uuid": "str",  # Optional. Switch short id. This can
                              be used to determine if two devices are"nconnected to the same switch,
                              for example.
                            "tags": [
                                "str"  # Optional.
                            ],
                            "termination_time": "2020-02-20 00:00:00",  # Optional. When
                              the device will be terminated. This is commonly set in advance
                              for"nephemeral spot market instances but this field may also be set
                              with"non-demand and reservation instances to automatically delete the
                              resource"nat a given time. The termination time can also be used to
                              release a"nhardware reservation instance at a given time, keeping the
                              reservation"nopen for other uses.  On a spot market device, the
                              termination time will"nbe set automatically when outbid.
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": "str",  # Optional.
                            "userdata": "str",  # Optional.
                            "volumes": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_devices_request(
            id=id,
            facility=facility,
            hostname=hostname,
            reserved=reserved,
            tag=tag,
            type=type,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_events(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve organization's events.

        Returns a list of events for a single organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_events_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_facilities_by_organization(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all facilities visible by the organization.

        Returns a listing of available datacenters for the given organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "facilities": [
                        {
                            "address": {
                                "address": "str",  # Required.
                                "address2": "str",  # Optional.
                                "city": "str",  # Optional.
                                "coordinates": {
                                    "latitude": "str",  # Optional.
                                    "longitude": "str"  # Optional.
                                },
                                "country": "str",  # Required.
                                "state": "str",  # Optional.
                                "zip_code": "str"  # Required.
                            },
                            "code": "str",  # Optional.
                            "features": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "ip_ranges": [
                                "str"  # Optional. IP ranges registered in facility.
                                  Can be used for GeoIP location.
                            ],
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "name": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_facilities_by_organization_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_invitations(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve organization invitations.

        Returns all invitations in an organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "invitations": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "roles": [
                                "str"  # Optional.
                            ],
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": {
                                "href": "str"  # Required.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_invitations_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_organization_invitation(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an invitation for an organization.

        In order to add a user to an organization, they must first be invited.
        To invite to several projects the parameter ``projects_ids:[a,b,c]`` can be used.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Invitation to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "invitee": "str",  # Required.
                    "message": "str",  # Optional.
                    "organization_id": "str",  # Optional.
                    "projects_ids": [
                        "str"  # Optional.
                    ],
                    "roles": [
                        "str"  # Optional.
                    ]
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_organization_invitation(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an invitation for an organization.

        In order to add a user to an organization, they must first be invited.
        To invite to several projects the parameter ``projects_ids:[a,b,c]`` can be used.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Invitation to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_organization_invitation(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create an invitation for an organization.

        In order to add a user to an organization, they must first be invited.
        To invite to several projects the parameter ``projects_ids:[a,b,c]`` can be used.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Invitation to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_organization_invitation_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_operating_systems_by_organization(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all operating systems visible by the organization.

        Returns a listing of available operating systems for the given organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "operating_systems": [
                        {
                            "distro": "str",  # Optional.
                            "id": "str",  # Optional.
                            "licensed": bool,  # Optional. Licenced OS is priced
                              according to pricing property.
                            "name": "str",  # Optional.
                            "preinstallable": bool,  # Optional. Servers can be already
                              preinstalled with OS in order to shorten provision time.
                            "pricing": {},  # Optional. This object contains price per
                              time unit and optional multiplier value if licence price depends on
                              hardware plan or components (e.g. number of cores).
                            "provisionable_on": [
                                "str"  # Optional.
                            ],
                            "slug": "str",  # Optional.
                            "version": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_operating_systems_by_organization_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_payment_methods(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all payment methods of an organization.

        Returns all payment methods of an organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "payment_methods": [
                        {
                            "billing_address": {
                                "country_code_alpha2": "str",  # Optional.
                                "postal_code": "str",  # Optional.
                                "street_address": "str"  # Optional.
                            },
                            "card_type": "str",  # Optional.
                            "cardholder_name": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "created_by_user": {
                                "href": "str"  # Required.
                            },
                            "default": bool,  # Optional.
                            "email": "str",  # Optional.
                            "expiration_month": "str",  # Optional.
                            "expiration_year": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str",  # Optional.
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "projects": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "type": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_payment_methods_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_payment_method(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a payment method for the given organization.

        Creates a payment method.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Payment Method to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "default": bool,  # Optional.
                    "name": "str",  # Required.
                    "nonce": "str"  # Required.
                }

                # response body for status code(s): 201
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_payment_method(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a payment method for the given organization.

        Creates a payment method.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Payment Method to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_payment_method(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a payment method for the given organization.

        Creates a payment method.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Payment Method to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_payment_method_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_plans_by_organization(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all plans visible by the organization.

        Returns a listing of available plans for the given organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "plans": [
                        {
                            "available_in": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Facility.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          facilities the plan is available in, and the facility-based
                                          price if it is different from the default price.
                                    }
                                }
                            ],
                            "available_in_metros": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Metro.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          metros the plan is available in, and the metro-based price if
                                          it is different from the default price.
                                    }
                                }
                            ],
                            "class": "str",  # Optional.
                            "deployment_types": [
                                "str"  # Optional.
                            ],
                            "description": "str",  # Optional.
                            "id": "str",  # Optional.
                            "legacy": bool,  # Optional.
                            "line": "str",  # Optional. "baremetal"
                            "name": "str",  # Optional.
                            "pricing": {},  # Optional. Any object.
                            "slug": "str",  # Optional.
                            "specs": {
                                "cpus": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional.
                                    }
                                ],
                                "drives": [
                                    {
                                        "category": "str",  # Optional. Known
                                          values are: "boot", "cache", and "storage".
                                        "count": 0,  # Optional.
                                        "size": "str",  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "HDD", "SSD", and "NVME".
                                    }
                                ],
                                "features": {
                                    "raid": bool,  # Optional.
                                    "txt": bool,  # Optional.
                                    "uefi": bool  # Optional.
                                },
                                "nics": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "1Gbps", "10Gbps", and "25Gbps".
                                    }
                                ]
                            },
                            "type": "str"  # Optional. The plan type. Known values are:
                              "standard", "workload_optimized", and "custom".
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_plans_by_organization_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_projects(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all projects of an organization.

        Returns a collection of projects that belong to the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    },
                    "projects": [
                        {
                            "bgp_config": {
                                "href": "str"  # Required.
                            },
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "customdata": {},  # Optional. Any object.
                            "devices": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "id": "str",  # Optional.
                            "invitations": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "max_devices": {},  # Optional. Any object.
                            "members": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "memberships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "name": "str",  # Optional.
                            "network_status": {},  # Optional. Any object.
                            "payment_method": {
                                "href": "str"  # Required.
                            },
                            "ssh_keys": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "volumes": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_projects_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_organization_project(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a project for the organization.

        Creates a new project for the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Project to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "customdata": {},  # Optional. Any object.
                    "name": "str",  # Required.
                    "payment_method_id": "str"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_organization_project(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a project for the organization.

        Creates a new project for the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Project to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_organization_project(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a project for the organization.

        Creates a new project for the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Project to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_organization_project_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_organization_transfers(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all project transfer requests from or to an organization.

        Provides a collection of project transfer requests from or to the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "transfers": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "target_organization": {
                                "href": "str"  # Required.
                            },
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_organization_transfers_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def organization_list_interconnections(
        self, organization_id: str, **kwargs: Any
    ) -> JSON:
        """List organization connections.

        List the connections belonging to the organization.

        :param organization_id: UUID of the organization. Required.
        :type organization_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "interconnections": [
                        {
                            "contact_email": "str",  # Optional.
                            "description": "str",  # Optional.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "id": "str",  # Optional.
                            "metro": {
                                "code": "str",  # Optional. The location of where the
                                  shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                                "country": "str",  # Optional. The location of where
                                  the shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                                "id": "str",  # Optional. The location of where the
                                  shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                                "name": "str"  # Optional. The location of where the
                                  shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                            },
                            "mode": "str",  # Optional. The mode of the interconnection
                              (only relevant to Dedicated Ports). Shared connections won't have this
                              field. Can be either 'standard' or 'tunnel'."n  The default mode of an
                              interconnection on a Dedicated Port is 'standard'. The mode can only be
                              changed when there are no associated virtual circuits on the
                              interconnection."n  In tunnel mode, an 802.1q tunnel is added to a port
                              to send/receive double tagged packets from server instances. Known values
                              are: "standard" and "tunnel".
                            "name": "str",  # Optional.
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "ports": [
                                {
                                    "id": "str",  # Optional. For Fabric VCs,
                                      these represent Virtual Port(s) created for the interconnection.
                                      For dedicated interconnections, these represent the Dedicated
                                      Port(s).
                                    "organization": {
                                        "href": "str"  # Required.
                                    },
                                    "role": "str",  # Optional. Either 'primary'
                                      or 'secondary'. Known values are: "primary" and "secondary".
                                    "status": "str",  # Optional. For both Fabric
                                      VCs and Dedicated Ports, this will be 'requested' on creation and
                                      'deleting' on deletion. Once the Fabric VC has found its
                                      corresponding Fabric connection, this will turn to 'active'. For
                                      Dedicated Ports, once the dedicated port is associated, this will
                                      also turn to 'active'. For Fabric VCs, this can turn into an
                                      'expired' state if the service token associated is expired. Known
                                      values are: "requested", "active", "deleting", and "expired".
                                    "switch_id": "str",  # Optional. A switch
                                      'short ID'.
                                    "virtual_circuits": {
                                        "virtual_circuits": [
                                            {}
                                        ]
                                    }
                                }
                            ],
                            "redundancy": "str",  # Optional. Either 'primary', meaning a
                              single interconnection, or 'redundant', meaning a redundant
                              interconnection. Known values are: "primary" and "redundant".
                            "service_tokens": [
                                {
                                    "expires_at": "2020-02-20 00:00:00",  #
                                      Optional. The expiration date and time of the Fabric service
                                      token. Once a service token is expired, it is no longer
                                      redeemable.
                                    "id": "str",  # Optional. The UUID that can
                                      be used on the Fabric Portal to redeem either an A-Side or Z-Side
                                      Service Token."nFor Fabric VCs (Metal Billed), this UUID will
                                      represent an A-Side Service Token, which will allow
                                      interconnections"nto be made from Equinix Metal to other Service
                                      Providers on Fabric. For Fabric VCs (Fabric Billed), this UUID
                                      will"nrepresent a Z-Side Service Token, which will allow
                                      interconnections to be made to connect an owned Fabric Port or
                                      "nVirtual Device to Equinix Metal.
                                    "max_allowed_speed": 0,  # Optional. The
                                      maximum speed that can be selected on the Fabric Portal when
                                      configuring a interconnection with either "nan A-Side or Z-Side
                                      Service Token. For Fabric VCs (Metal Billed), this is what the
                                      billing is based off of, and can be one"nof the following
                                      options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                                      '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will
                                      default to 10Gbps.
                                    "role": "str",  # Optional. Either primary or
                                      secondary, depending on which interconnection the service token
                                      is associated to. Known values are: "primary" and "secondary".
                                    "service_token_type": "str",  # Optional.
                                      Either 'a_side' or 'z_side', depending on which type of Fabric VC
                                      was requested. Known values are: "a_side" and "z_side".
                                    "state": "str"  # Optional. The state of the
                                      service token that corresponds with the service"ntoken state on
                                      Fabric. An 'inactive' state refers to a token that has not
                                      been"nredeemed yet on the Fabric side, an 'active' state refers
                                      to a token that has"nalready been redeemed, and an 'expired'
                                      state refers to a token that has reached"nits expiry time. Known
                                      values are: "inactive", "active", and "expired".
                                }
                            ],
                            "speed": 0,  # Optional. For interconnections on Dedicated
                              Ports and shared connections, this represents the interconnection's speed
                              in bps. For Fabric VCs, this field refers to the maximum speed of the
                              interconnection in bps. This value will default to 10Gbps for Fabric VCs
                              (Fabric Billed).
                            "status": "str",  # Optional.
                            "tags": [
                                "str"  # Optional.
                            ],
                            "token": "str",  # Optional. This token is used for shared
                              interconnections to be used as the Fabric Token. This field is entirely
                              deprecated.
                            "type": "str"  # Optional. The 'shared' type of
                              interconnection refers to shared connections, or later also known as
                              Fabric Virtual Connections (or Fabric VCs). The 'dedicated' type of
                              interconnection refers to interconnections created with Dedicated Ports.
                              Known values are: "shared" and "dedicated".
                        }
                    ]
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_organization_list_interconnections_request(
            organization_id=organization_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_organization_interconnection(
        self,
        organization_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Request a new interconnection for the organization.

        Creates a new interconnection request. A Project ID must be specified in the request body for
        connections on shared ports.

        :param organization_id: UUID of the organization. Required.
        :type organization_id: str
        :param body: Interconnection details. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "metro": "str",  # A Metro ID or code. For interconnections with Dedicated
                      Ports, this will be the location of the issued Dedicated Ports. When creating
                      Fabric VCs (Metal Billed), this is where interconnection will be originating
                      from, as we pre-authorize the use of one of our shared ports as the origin of the
                      interconnection using A-Side service tokens. We only allow local connections for
                      Fabric VCs (Metal Billed), so the destination location must be the same as the
                      origin. For Fabric VCs (Fabric Billed), or shared connections, this will be the
                      destination of the interconnection. We allow remote connections for Fabric VCs
                      (Fabric Billed), so the origin of the interconnection can be a different metro
                      set here. Required.
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Fabric VCs won't have this field. Can be either 'standard' or
                      'tunnel'."n  The default mode of an interconnection on a Dedicated Port is
                      'standard'. The mode can only be changed when there are no associated virtual
                      circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is added to
                      a port to send/receive double tagged packets from server instances. Known values
                      are: "standard" and "tunnel".
                    "name": "str",  # Required.
                    "project": "str",  # Optional.
                    "redundancy": "str",  # Either 'primary' or 'redundant'. Required.
                    "service_token_type": "str",  # Optional. Either 'a_side' or 'z_side'.
                      Setting this field to 'a_side' will create an interconnection with Fabric VCs
                      (Metal Billed). Setting this field to 'z_side' will create an interconnection
                      with Fabric VCs (Fabric Billed). This is required when the 'type' is 'shared',
                      but this is not applicable when the 'type' is 'dedicated'. This parameter is
                      included in the specification as a developer preview and is generally
                      unavailable. Please contact our Support team for more details. Known values are:
                      "a_side" and "z_side".
                    "speed": 0,  # Optional. A interconnection speed, in bps, mbps, or gbps. For
                      Dedicated Ports, this can be 10Gbps or 100Gbps."nFor Fabric VCs, this represents
                      the maximum speed of the interconnection. For Fabric VCs (Metal Billed), this can
                      only be one of the following: "n''50mbps'', ''200mbps'', ''500mbps'', ''1gbps'',
                      ''2gbps'', ''5gbps'' or ''10gbps'', and is required for creation. For Fabric VCs
                      (Fabric Billed), this field will always default to ''10gbps'' even if it is not
                      provided."nFor example, ''500000000'', ''50m'', or' ''500mbps'' will all work as
                      valid inputs.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "type": "str",  # Either 'shared' or 'dedicated'. The 'shared' type
                      represents shared interconnections, or also known as Fabric VCs. The 'dedicated'
                      type represents dedicated interconnections, or also known as Dedicated Ports.
                      Required.
                    "vlans": [
                        0  # Optional. A list of one or two metro-based VLANs that will be
                          set on the virtual circuits of primary and/or secondary (if redundant)
                          interconnections respectively when creating Fabric VCs. VLANs can also be set
                          after the interconnection is created, but are required to fully activate the
                          interconnection. This parameter is included in the specification as a
                          developer preview and is generally unavailable. Please contact our Support
                          team for more details.
                    ]
                }

                # response body for status code(s): 201
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_organization_interconnection(
        self,
        organization_id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Request a new interconnection for the organization.

        Creates a new interconnection request. A Project ID must be specified in the request body for
        connections on shared ports.

        :param organization_id: UUID of the organization. Required.
        :type organization_id: str
        :param body: Interconnection details. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_organization_interconnection(
        self, organization_id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Request a new interconnection for the organization.

        Creates a new interconnection request. A Project ID must be specified in the request body for
        connections on shared ports.

        :param organization_id: UUID of the organization. Required.
        :type organization_id: str
        :param body: Interconnection details. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_organization_interconnection_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_payment_method(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the payment method.

        Deletes the payment method.

        :param id: Payment Method UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_payment_method_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_payment_method_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a payment method.

        Returns a payment method.

        :param id: Payment Method UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_payment_method_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_payment_method(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the payment method.

        Updates the payment method.

        :param id: Payment Method UUID. Required.
        :type id: str
        :param body: Payment Method to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "billing_address": {},  # Optional. Any object.
                    "cardholder_name": "str",  # Optional.
                    "default": bool,  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": 0,  # Optional.
                    "name": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_payment_method(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the payment method.

        Updates the payment method.

        :param id: Payment Method UUID. Required.
        :type id: str
        :param body: Payment Method to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_payment_method(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the payment method.

        Updates the payment method.

        :param id: Payment Method UUID. Required.
        :type id: str
        :param body: Payment Method to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "billing_address": {
                        "country_code_alpha2": "str",  # Optional.
                        "postal_code": "str",  # Optional.
                        "street_address": "str"  # Optional.
                    },
                    "card_type": "str",  # Optional.
                    "cardholder_name": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by_user": {
                        "href": "str"  # Required.
                    },
                    "default": bool,  # Optional.
                    "email": "str",  # Optional.
                    "expiration_month": "str",  # Optional.
                    "expiration_year": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "type": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_payment_method_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_plans(
        self,
        *,
        type: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all plans.

        Provides a listing of available plans to provision your device on.

        :keyword type: Filter plans by its plan type. Known values are: "standard",
         "workload_optimized", and "custom". Default value is None.
        :paramtype type: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "plans": [
                        {
                            "available_in": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Facility.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          facilities the plan is available in, and the facility-based
                                          price if it is different from the default price.
                                    }
                                }
                            ],
                            "available_in_metros": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Metro.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          metros the plan is available in, and the metro-based price if
                                          it is different from the default price.
                                    }
                                }
                            ],
                            "class": "str",  # Optional.
                            "deployment_types": [
                                "str"  # Optional.
                            ],
                            "description": "str",  # Optional.
                            "id": "str",  # Optional.
                            "legacy": bool,  # Optional.
                            "line": "str",  # Optional. "baremetal"
                            "name": "str",  # Optional.
                            "pricing": {},  # Optional. Any object.
                            "slug": "str",  # Optional.
                            "specs": {
                                "cpus": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional.
                                    }
                                ],
                                "drives": [
                                    {
                                        "category": "str",  # Optional. Known
                                          values are: "boot", "cache", and "storage".
                                        "count": 0,  # Optional.
                                        "size": "str",  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "HDD", "SSD", and "NVME".
                                    }
                                ],
                                "features": {
                                    "raid": bool,  # Optional.
                                    "txt": bool,  # Optional.
                                    "uefi": bool  # Optional.
                                },
                                "nics": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "1Gbps", "10Gbps", and "25Gbps".
                                    }
                                ]
                            },
                            "type": "str"  # Optional. The plan type. Known values are:
                              "standard", "workload_optimized", and "custom".
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_plans_request(
            type=type,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_port_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a port.

        Returns a port.

        :param id: Port UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_port_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def assign_port(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Assign a port to virtual network.

        Assign a hardware port to a virtual network.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "vnid": "str"  # Optional. Virtual Network ID. May be the UUID of the Virtual
                      Network record, or the VLAN value itself.
                }

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def assign_port(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Assign a port to virtual network.

        Assign a hardware port to a virtual network.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def assign_port(self, id: str, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Assign a port to virtual network.

        Assign a hardware port to a virtual network.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_assign_port_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def bond_port(
        self, id: str, *, bulk_enable: Optional[bool] = None, **kwargs: Any
    ) -> JSON:
        """Enabling bonding.

        Enabling bonding for one or all ports.

        :param id: Port UUID. Required.
        :type id: str
        :keyword bulk_enable: enable both ports. Default value is None.
        :paramtype bulk_enable: bool
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_bond_port_request(
            id=id,
            bulk_enable=bulk_enable,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def convert_layer2(
        self,
        id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Convert to Layer 2.

        Converts a bond port to Layer 2. IP assignments of the port will be removed.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Virtual Network ID. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "vnid": "str"  # Optional. Virtual Network ID. May be the UUID of the Virtual
                      Network record, or the VLAN value itself.
                }

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def convert_layer2(
        self,
        id: str,
        body: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Convert to Layer 2.

        Converts a bond port to Layer 2. IP assignments of the port will be removed.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Virtual Network ID. Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def convert_layer2(
        self, id: str, body: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> JSON:
        """Convert to Layer 2.

        Converts a bond port to Layer 2. IP assignments of the port will be removed.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Virtual Network ID. Is either a model type or a IO type. Default value is None.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        request = build_convert_layer2_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def convert_layer3(
        self,
        id: str,
        body: Optional[JSON] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Convert to Layer 3.

        Converts a bond port to Layer 3. VLANs must first be unassigned.

        :param id: Port UUID. Required.
        :type id: str
        :param body: IPs to request. Default value is None.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "request_ips": [
                        {
                            "address_family": 0,  # Optional.
                            "public": bool  # Optional.
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def convert_layer3(
        self,
        id: str,
        body: Optional[IO] = None,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Convert to Layer 3.

        Converts a bond port to Layer 3. VLANs must first be unassigned.

        :param id: Port UUID. Required.
        :type id: str
        :param body: IPs to request. Default value is None.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def convert_layer3(
        self, id: str, body: Optional[Union[JSON, IO]] = None, **kwargs: Any
    ) -> JSON:
        """Convert to Layer 3.

        Converts a bond port to Layer 3. VLANs must first be unassigned.

        :param id: Port UUID. Required.
        :type id: str
        :param body: IPs to request. Is either a model type or a IO type. Default value is None.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            if body is not None:
                _json = body
            else:
                _json = None

        request = build_convert_layer3_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def disbond_port(
        self, id: str, *, bulk_disable: Optional[bool] = None, **kwargs: Any
    ) -> JSON:
        """Disabling bonding.

        Disabling bonding for one or all ports.

        :param id: Port UUID. Required.
        :type id: str
        :keyword bulk_disable: disable both ports. Default value is None.
        :paramtype bulk_disable: bool
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_disbond_port_request(
            id=id,
            bulk_disable=bulk_disable,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_native_vlan(self, id: str, **kwargs: Any) -> JSON:
        """Remove native VLAN.

        Removes the native VLAN from this port.

        :param id: Port UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_delete_native_vlan_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def assign_native_vlan(self, id: str, *, vnid: str, **kwargs: Any) -> JSON:
        """Assign a native VLAN.

        Sets a virtual network on this port as a "native VLAN". The VLAN must have already been
        assigned using the using the "Assign a port to a virtual network" operation.

        :param id: Port UUID. Required.
        :type id: str
        :keyword vnid: Virtual Network ID. May be the UUID of the Virtual Network record, or the VLAN
         value itself (ex: '1001'). Required.
        :paramtype vnid: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_assign_native_vlan_request(
            id=id,
            vnid=vnid,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def unassign_port(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Unassign a port.

        Unassign a port for a hardware.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Virtual Network ID. May be the UUID of the Virtual Network record, or the VLAN
         value itself (ex: '1001'). Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "vnid": "str"  # Optional. Virtual Network ID. May be the UUID of the Virtual
                      Network record, or the VLAN value itself.
                }

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def unassign_port(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Unassign a port.

        Unassign a port for a hardware.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Virtual Network ID. May be the UUID of the Virtual Network record, or the VLAN
         value itself (ex: '1001'). Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def unassign_port(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Unassign a port.

        Unassign a port for a hardware.

        :param id: Port UUID. Required.
        :type id: str
        :param body: Virtual Network ID. May be the UUID of the Virtual Network record, or the VLAN
         value itself (ex: '1001'). Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bond": {
                        "id": "str",  # Optional. ID of the bonding port.
                        "name": "str"  # Optional. Name of the port interface for the bond
                          ("bond0").
                    },
                    "data": {
                        "bonded": bool,  # Optional. Bonded is true for NetworkPort ports in
                          a bond and NetworkBondPort ports that are active.
                        "mac": "str"  # Optional. MAC address is set for NetworkPort ports.
                    },
                    "disbond_operation_supported": bool,  # Optional. Indicates whether or not
                      the bond can be broken on the port (when applicable).
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "name": "str",  # Optional.
                    "native_virtual_network": {
                        "assigned_to": {
                            "href": "str"  # Required.
                        },
                        "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual
                          network is attached to a virtual circuit. False if not.
                        "description": "str",  # Optional.
                        "facility": {
                            "href": "str"  # Required.
                        },
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "instances": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "metal_gateways": [
                            {
                                "created_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "id": "str",  # Optional. A list of metal gateways
                                  currently associated to this Virtual Network.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional. A
                                  list of metal gateways currently associated to this Virtual Network.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            }
                        ],
                        "metro": {
                            "href": "str"  # Required.
                        },
                        "metro_code": "str",  # Optional. The Metro code of the metro in
                          which this Virtual Network is defined.
                        "vxlan": 0  # Optional.
                    },
                    "network_type": "str",  # Optional. Composite network type of the bond. Known
                      values are: "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                      "hybrid-bonded".
                    "type": "str",  # Optional. Type is either "NetworkBondPort" for bond ports
                      or "NetworkPort" for bondable ethernet ports. Known values are: "NetworkPort" and
                      "NetworkBondPort".
                    "virtual_networks": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_unassign_port_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_port_vlan_assignments(
        self,
        id: str,
        *,
        include: List[str] = ["port", "virtual_network"],
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """List Current VLAN assignments for a port.

        Show the port's current VLAN assignments, including if this VLAN is set as native, and the
        current state of the assignment (ex. 'assigned' or 'unassigning').

        :param id: Port UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
         Default value is ['port', 'virtual_network'].
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
         Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "vlan_assignments": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "id": "str",  # Optional.
                            "native": bool,  # Optional.
                            "port": {
                                "href": "str"  # Required.
                            },
                            "state": "str",  # Optional. Known values are: "assigned" and
                              "unassigning".
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "virtual_network": {
                                "href": "str"  # Required.
                            },
                            "vlan": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_port_vlan_assignments_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_port_vlan_assignment_by_port_id_and_assignment_id(
        self,
        id: str,
        assignment_id: str,
        *,
        include: List[str] = ["port", "virtual_network"],
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Show a particular Port VLAN assignment's details.

        Show the details of a specific Port-VLAN assignment, including the current state and if the
        VLAN is set as native.

        :param id: Port UUID. Required.
        :type id: str
        :param assignment_id: Assignment ID. Required.
        :type assignment_id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
         Default value is ['port', 'virtual_network'].
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
         Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "id": "str",  # Optional.
                    "native": bool,  # Optional.
                    "port": {
                        "href": "str"  # Required.
                    },
                    "state": "str",  # Optional. Known values are: "assigned" and "unassigning".
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "virtual_network": {
                        "href": "str"  # Required.
                    },
                    "vlan": 0  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_port_vlan_assignment_by_port_id_and_assignment_id_request(
            id=id,
            assignment_id=assignment_id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_port_vlan_assignment_batches(self, id: str, **kwargs: Any) -> JSON:
        """List the VLAN Assignment Batches for a port.

        Show all the VLAN assignment batches that have been created for managing this port's VLAN
        assignments.

        :param id: Port UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "batches": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "error_messages": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "port": {
                                "bond": {
                                    "id": "str",  # Optional. ID of the bonding
                                      port.
                                    "name": "str"  # Optional. Name of the port
                                      interface for the bond ("bond0").
                                },
                                "data": {
                                    "bonded": bool,  # Optional. Bonded is true
                                      for NetworkPort ports in a bond and NetworkBondPort ports that
                                      are active.
                                    "mac": "str"  # Optional. MAC address is set
                                      for NetworkPort ports.
                                },
                                "disbond_operation_supported": bool,  # Optional.
                                  Indicates whether or not the bond can be broken on the port (when
                                  applicable).
                                "href": "str",  # Optional. Port is a hardware port
                                  associated with a reserved or instantiated hardware device.
                                "id": "str",  # Optional. Port is a hardware port
                                  associated with a reserved or instantiated hardware device.
                                "name": "str",  # Optional. Port is a hardware port
                                  associated with a reserved or instantiated hardware device.
                                "native_virtual_network": {
                                    "assigned_to": {
                                        "href": "str"  # Required.
                                    },
                                    "assigned_to_virtual_circuit": bool,  #
                                      Optional. True if the virtual network is attached to a virtual
                                      circuit. False if not.
                                    "description": "str",  # Optional. Port is a
                                      hardware port associated with a reserved or instantiated hardware
                                      device.
                                    "facility": {
                                        "href": "str"  # Required.
                                    },
                                    "href": "str",  # Optional. Port is a
                                      hardware port associated with a reserved or instantiated hardware
                                      device.
                                    "id": "str",  # Optional. Port is a hardware
                                      port associated with a reserved or instantiated hardware device.
                                    "instances": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "metal_gateways": [
                                        {
                                            "created_at": "2020-02-20
                                              00:00:00",  # Optional. A list of metal gateways
                                              currently associated to this Virtual Network.
                                            "gateway_address": "str",  #
                                              Optional. The gateway address with subnet CIDR value for
                                              this Metal Gateway. For example, a Metal Gateway using an
                                              IP reservation with block 10.1.2.0/27 would have a
                                              gateway address of 10.1.2.1/27.
                                            "href": "str",  # Optional. A
                                              list of metal gateways currently associated to this
                                              Virtual Network.
                                            "id": "str",  # Optional. A
                                              list of metal gateways currently associated to this
                                              Virtual Network.
                                            "state": "str",  # Optional.
                                              The current state of the Metal Gateway. 'Ready' indicates
                                              the gateway record has been configured, but is currently
                                              not active on the network. 'Active' indicates the gateway
                                              has been configured on the network. 'Deleting' is a
                                              temporary state used to indicate that the gateway is in
                                              the process of being un-configured from the network,
                                              after which the gateway record will be deleted. Known
                                              values are: "ready", "active", and "deleting".
                                            "updated_at": "2020-02-20
                                              00:00:00",  # Optional. A list of metal gateways
                                              currently associated to this Virtual Network.
                                            "vlan": 0  # Optional. The
                                              VLAN id of the Virtual Network record associated to this
                                              Metal Gateway.
                                        }
                                    ],
                                    "metro": {
                                        "href": "str"  # Required.
                                    },
                                    "metro_code": "str",  # Optional. The Metro
                                      code of the metro in which this Virtual Network is defined.
                                    "vxlan": 0  # Optional. Port is a hardware
                                      port associated with a reserved or instantiated hardware device.
                                },
                                "network_type": "str",  # Optional. Composite network
                                  type of the bond. Known values are: "layer2-bonded",
                                  "layer2-individual", "layer3", "hybrid", and "hybrid-bonded".
                                "type": "str",  # Optional. Type is either
                                  "NetworkBondPort" for bond ports or "NetworkPort" for bondable
                                  ethernet ports. Known values are: "NetworkPort" and
                                  "NetworkBondPort".
                                "virtual_networks": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            },
                            "quantity": 0,  # Optional.
                            "state": "str",  # Optional. Known values are: "queued",
                              "in_progress", "completed", and "failed".
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "vlan_assignments": [
                                {
                                    "id": "str",  # Optional.
                                    "native": bool,  # Optional.
                                    "state": "str",  # Optional. Known values
                                      are: "assigned" and "unassigned".
                                    "vlan": 0  # Optional.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_port_vlan_assignment_batches_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_port_vlan_assignment_batch(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a new Port-VLAN Assignment management batch.

        Create a new asynchronous batch request which handles adding and/or removing the VLANs to which
        the port is assigned.

        :param id: Port UUID. Required.
        :type id: str
        :param body: VLAN Assignment batch details. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "vlan_assignments": [
                        {
                            "native": bool,  # Optional.
                            "state": "str",  # Optional. Known values are: "assigned" and
                              "unassigned".
                            "vlan": "str"  # Optional.
                        }
                    ]
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "error_messages": [
                        "str"  # Optional.
                    ],
                    "id": "str",  # Optional.
                    "port": {
                        "bond": {
                            "id": "str",  # Optional. ID of the bonding port.
                            "name": "str"  # Optional. Name of the port interface for the
                              bond ("bond0").
                        },
                        "data": {
                            "bonded": bool,  # Optional. Bonded is true for NetworkPort
                              ports in a bond and NetworkBondPort ports that are active.
                            "mac": "str"  # Optional. MAC address is set for NetworkPort
                              ports.
                        },
                        "disbond_operation_supported": bool,  # Optional. Indicates whether
                          or not the bond can be broken on the port (when applicable).
                        "href": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "id": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "name": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "native_virtual_network": {
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "assigned_to_virtual_circuit": bool,  # Optional. True if the
                              virtual network is attached to a virtual circuit. False if not.
                            "description": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "id": "str",  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                            "instances": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "metal_gateways": [
                                {
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "gateway_address": "str",  # Optional. The
                                      gateway address with subnet CIDR value for this Metal Gateway.
                                      For example, a Metal Gateway using an IP reservation with block
                                      10.1.2.0/27 would have a gateway address of 10.1.2.1/27.
                                    "href": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "id": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "state": "str",  # Optional. The current
                                      state of the Metal Gateway. 'Ready' indicates the gateway record
                                      has been configured, but is currently not active on the network.
                                      'Active' indicates the gateway has been configured on the
                                      network. 'Deleting' is a temporary state used to indicate that
                                      the gateway is in the process of being un-configured from the
                                      network, after which the gateway record will be deleted. Known
                                      values are: "ready", "active", and "deleting".
                                    "updated_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "vlan": 0  # Optional. The VLAN id of the
                                      Virtual Network record associated to this Metal Gateway.
                                }
                            ],
                            "metro": {
                                "href": "str"  # Required.
                            },
                            "metro_code": "str",  # Optional. The Metro code of the metro
                              in which this Virtual Network is defined.
                            "vxlan": 0  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                        },
                        "network_type": "str",  # Optional. Composite network type of the
                          bond. Known values are: "layer2-bonded", "layer2-individual", "layer3",
                          "hybrid", and "hybrid-bonded".
                        "type": "str",  # Optional. Type is either "NetworkBondPort" for bond
                          ports or "NetworkPort" for bondable ethernet ports. Known values are:
                          "NetworkPort" and "NetworkBondPort".
                        "virtual_networks": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "quantity": 0,  # Optional.
                    "state": "str",  # Optional. Known values are: "queued", "in_progress",
                      "completed", and "failed".
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "vlan_assignments": [
                        {
                            "id": "str",  # Optional.
                            "native": bool,  # Optional.
                            "state": "str",  # Optional. Known values are: "assigned" and
                              "unassigned".
                            "vlan": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_port_vlan_assignment_batch(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a new Port-VLAN Assignment management batch.

        Create a new asynchronous batch request which handles adding and/or removing the VLANs to which
        the port is assigned.

        :param id: Port UUID. Required.
        :type id: str
        :param body: VLAN Assignment batch details. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "error_messages": [
                        "str"  # Optional.
                    ],
                    "id": "str",  # Optional.
                    "port": {
                        "bond": {
                            "id": "str",  # Optional. ID of the bonding port.
                            "name": "str"  # Optional. Name of the port interface for the
                              bond ("bond0").
                        },
                        "data": {
                            "bonded": bool,  # Optional. Bonded is true for NetworkPort
                              ports in a bond and NetworkBondPort ports that are active.
                            "mac": "str"  # Optional. MAC address is set for NetworkPort
                              ports.
                        },
                        "disbond_operation_supported": bool,  # Optional. Indicates whether
                          or not the bond can be broken on the port (when applicable).
                        "href": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "id": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "name": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "native_virtual_network": {
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "assigned_to_virtual_circuit": bool,  # Optional. True if the
                              virtual network is attached to a virtual circuit. False if not.
                            "description": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "id": "str",  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                            "instances": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "metal_gateways": [
                                {
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "gateway_address": "str",  # Optional. The
                                      gateway address with subnet CIDR value for this Metal Gateway.
                                      For example, a Metal Gateway using an IP reservation with block
                                      10.1.2.0/27 would have a gateway address of 10.1.2.1/27.
                                    "href": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "id": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "state": "str",  # Optional. The current
                                      state of the Metal Gateway. 'Ready' indicates the gateway record
                                      has been configured, but is currently not active on the network.
                                      'Active' indicates the gateway has been configured on the
                                      network. 'Deleting' is a temporary state used to indicate that
                                      the gateway is in the process of being un-configured from the
                                      network, after which the gateway record will be deleted. Known
                                      values are: "ready", "active", and "deleting".
                                    "updated_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "vlan": 0  # Optional. The VLAN id of the
                                      Virtual Network record associated to this Metal Gateway.
                                }
                            ],
                            "metro": {
                                "href": "str"  # Required.
                            },
                            "metro_code": "str",  # Optional. The Metro code of the metro
                              in which this Virtual Network is defined.
                            "vxlan": 0  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                        },
                        "network_type": "str",  # Optional. Composite network type of the
                          bond. Known values are: "layer2-bonded", "layer2-individual", "layer3",
                          "hybrid", and "hybrid-bonded".
                        "type": "str",  # Optional. Type is either "NetworkBondPort" for bond
                          ports or "NetworkPort" for bondable ethernet ports. Known values are:
                          "NetworkPort" and "NetworkBondPort".
                        "virtual_networks": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "quantity": 0,  # Optional.
                    "state": "str",  # Optional. Known values are: "queued", "in_progress",
                      "completed", and "failed".
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "vlan_assignments": [
                        {
                            "id": "str",  # Optional.
                            "native": bool,  # Optional.
                            "state": "str",  # Optional. Known values are: "assigned" and
                              "unassigned".
                            "vlan": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_port_vlan_assignment_batch(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a new Port-VLAN Assignment management batch.

        Create a new asynchronous batch request which handles adding and/or removing the VLANs to which
        the port is assigned.

        :param id: Port UUID. Required.
        :type id: str
        :param body: VLAN Assignment batch details. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "error_messages": [
                        "str"  # Optional.
                    ],
                    "id": "str",  # Optional.
                    "port": {
                        "bond": {
                            "id": "str",  # Optional. ID of the bonding port.
                            "name": "str"  # Optional. Name of the port interface for the
                              bond ("bond0").
                        },
                        "data": {
                            "bonded": bool,  # Optional. Bonded is true for NetworkPort
                              ports in a bond and NetworkBondPort ports that are active.
                            "mac": "str"  # Optional. MAC address is set for NetworkPort
                              ports.
                        },
                        "disbond_operation_supported": bool,  # Optional. Indicates whether
                          or not the bond can be broken on the port (when applicable).
                        "href": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "id": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "name": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "native_virtual_network": {
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "assigned_to_virtual_circuit": bool,  # Optional. True if the
                              virtual network is attached to a virtual circuit. False if not.
                            "description": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "id": "str",  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                            "instances": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "metal_gateways": [
                                {
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "gateway_address": "str",  # Optional. The
                                      gateway address with subnet CIDR value for this Metal Gateway.
                                      For example, a Metal Gateway using an IP reservation with block
                                      10.1.2.0/27 would have a gateway address of 10.1.2.1/27.
                                    "href": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "id": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "state": "str",  # Optional. The current
                                      state of the Metal Gateway. 'Ready' indicates the gateway record
                                      has been configured, but is currently not active on the network.
                                      'Active' indicates the gateway has been configured on the
                                      network. 'Deleting' is a temporary state used to indicate that
                                      the gateway is in the process of being un-configured from the
                                      network, after which the gateway record will be deleted. Known
                                      values are: "ready", "active", and "deleting".
                                    "updated_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "vlan": 0  # Optional. The VLAN id of the
                                      Virtual Network record associated to this Metal Gateway.
                                }
                            ],
                            "metro": {
                                "href": "str"  # Required.
                            },
                            "metro_code": "str",  # Optional. The Metro code of the metro
                              in which this Virtual Network is defined.
                            "vxlan": 0  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                        },
                        "network_type": "str",  # Optional. Composite network type of the
                          bond. Known values are: "layer2-bonded", "layer2-individual", "layer3",
                          "hybrid", and "hybrid-bonded".
                        "type": "str",  # Optional. Type is either "NetworkBondPort" for bond
                          ports or "NetworkPort" for bondable ethernet ports. Known values are:
                          "NetworkPort" and "NetworkBondPort".
                        "virtual_networks": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "quantity": 0,  # Optional.
                    "state": "str",  # Optional. Known values are: "queued", "in_progress",
                      "completed", and "failed".
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "vlan_assignments": [
                        {
                            "id": "str",  # Optional.
                            "native": bool,  # Optional.
                            "state": "str",  # Optional. Known values are: "assigned" and
                              "unassigned".
                            "vlan": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_port_vlan_assignment_batch_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_port_vlan_assignment_batch_by_port_id_and_batch_id(
        self, id: str, batch_id: str, **kwargs: Any
    ) -> JSON:
        """Retrieve a VLAN Assignment Batch's details.

        Returns the details of an existing Port-VLAN Assignment batch, including the list of VLANs to
        assign or unassign, and the current state of the batch.

        :param id: Port UUID. Required.
        :type id: str
        :param batch_id: Batch ID. Required.
        :type batch_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "error_messages": [
                        "str"  # Optional.
                    ],
                    "id": "str",  # Optional.
                    "port": {
                        "bond": {
                            "id": "str",  # Optional. ID of the bonding port.
                            "name": "str"  # Optional. Name of the port interface for the
                              bond ("bond0").
                        },
                        "data": {
                            "bonded": bool,  # Optional. Bonded is true for NetworkPort
                              ports in a bond and NetworkBondPort ports that are active.
                            "mac": "str"  # Optional. MAC address is set for NetworkPort
                              ports.
                        },
                        "disbond_operation_supported": bool,  # Optional. Indicates whether
                          or not the bond can be broken on the port (when applicable).
                        "href": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "id": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "name": "str",  # Optional. Port is a hardware port associated with a
                          reserved or instantiated hardware device.
                        "native_virtual_network": {
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "assigned_to_virtual_circuit": bool,  # Optional. True if the
                              virtual network is attached to a virtual circuit. False if not.
                            "description": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional. Port is a hardware port
                              associated with a reserved or instantiated hardware device.
                            "id": "str",  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                            "instances": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "metal_gateways": [
                                {
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "gateway_address": "str",  # Optional. The
                                      gateway address with subnet CIDR value for this Metal Gateway.
                                      For example, a Metal Gateway using an IP reservation with block
                                      10.1.2.0/27 would have a gateway address of 10.1.2.1/27.
                                    "href": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "id": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "state": "str",  # Optional. The current
                                      state of the Metal Gateway. 'Ready' indicates the gateway record
                                      has been configured, but is currently not active on the network.
                                      'Active' indicates the gateway has been configured on the
                                      network. 'Deleting' is a temporary state used to indicate that
                                      the gateway is in the process of being un-configured from the
                                      network, after which the gateway record will be deleted. Known
                                      values are: "ready", "active", and "deleting".
                                    "updated_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "vlan": 0  # Optional. The VLAN id of the
                                      Virtual Network record associated to this Metal Gateway.
                                }
                            ],
                            "metro": {
                                "href": "str"  # Required.
                            },
                            "metro_code": "str",  # Optional. The Metro code of the metro
                              in which this Virtual Network is defined.
                            "vxlan": 0  # Optional. Port is a hardware port associated
                              with a reserved or instantiated hardware device.
                        },
                        "network_type": "str",  # Optional. Composite network type of the
                          bond. Known values are: "layer2-bonded", "layer2-individual", "layer3",
                          "hybrid", and "hybrid-bonded".
                        "type": "str",  # Optional. Type is either "NetworkBondPort" for bond
                          ports or "NetworkPort" for bondable ethernet ports. Known values are:
                          "NetworkPort" and "NetworkBondPort".
                        "virtual_networks": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "quantity": 0,  # Optional.
                    "state": "str",  # Optional. Known values are: "queued", "in_progress",
                      "completed", and "failed".
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "vlan_assignments": [
                        {
                            "id": "str",  # Optional.
                            "native": bool,  # Optional.
                            "state": "str",  # Optional. Known values are: "assigned" and
                              "unassigned".
                            "vlan": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_port_vlan_assignment_batch_by_port_id_and_batch_id_request(
            id=id,
            batch_id=batch_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_projects(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all projects.

        Returns a collection of projects that the current user is a member of.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    },
                    "projects": [
                        {
                            "bgp_config": {
                                "href": "str"  # Required.
                            },
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "customdata": {},  # Optional. Any object.
                            "devices": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "id": "str",  # Optional.
                            "invitations": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "max_devices": {},  # Optional. Any object.
                            "members": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "memberships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "name": "str",  # Optional.
                            "network_status": {},  # Optional. Any object.
                            "payment_method": {
                                "href": "str"  # Required.
                            },
                            "ssh_keys": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "volumes": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_projects_request(
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_project(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a project.

        Creates a new project for the user default organization. If the user don't have an
        organization, a new one will be created.

        :param body: Project to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "customdata": {},  # Optional. Any object.
                    "name": "str",  # Required.
                    "organization_id": "str",  # Optional.
                    "payment_method_id": "str"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_project(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a project.

        Creates a new project for the user default organization. If the user don't have an
        organization, a new one will be created.

        :param body: Project to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_project(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create a project.

        Creates a new project for the user default organization. If the user don't have an
        organization, a new one will be created.

        :param body: Project to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_project_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_project(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the project.

        Deletes the project.

        :param id: Project UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_project_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_project_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a project.

        Returns a single project if the user has access.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_project(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the project.

        Updates the project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Project to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "backend_transfer_enabled": bool,  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "name": "str",  # Optional.
                    "payment_method_id": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_project(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the project.

        Updates the project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Project to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_project(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the project.

        Updates the project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Project to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bgp_config": {
                        "href": "str"  # Required.
                    },
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "devices": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "id": "str",  # Optional.
                    "invitations": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "max_devices": {},  # Optional. Any object.
                    "members": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "memberships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "name": "str",  # Optional.
                    "network_status": {},  # Optional. Any object.
                    "payment_method": {
                        "href": "str"  # Required.
                    },
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_project_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_api_keys(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all API keys for the project.

        Returns all API keys for a specific project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "api_keys": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "description": "str",  # Optional. Available only for API
                              keys.
                            "id": "str",  # Optional.
                            "project": {
                                "bgp_config": {
                                    "href": "str"  # Required.
                                },
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "devices": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "id": "str",  # Optional.
                                "invitations": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "max_devices": {},  # Optional. Any object.
                                "members": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "memberships": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "name": "str",  # Optional.
                                "network_status": {},  # Optional. Any object.
                                "payment_method": {
                                    "href": "str"  # Required.
                                },
                                "ssh_keys": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "volumes": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            },
                            "read_only": bool,  # Optional.
                            "token": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": {
                                "avatar_thumb_url": "str",  # Optional.
                                "avatar_url": "str",  # Optional.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "email": "str",  # Optional.
                                "emails": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "first_name": "str",  # Optional.
                                "fraud_score": "str",  # Optional.
                                "full_name": "str",  # Optional.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "last_login_at": "2020-02-20 00:00:00",  # Optional.
                                "last_name": "str",  # Optional.
                                "max_organizations": 0,  # Optional.
                                "max_projects": 0,  # Optional.
                                "phone_number": "str",  # Optional.
                                "short_id": "str",  # Optional.
                                "timezone": "str",  # Optional.
                                "two_factor_auth": "str",  # Optional.
                                "updated_at": "2020-02-20 00:00:00"  # Optional.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_api_keys_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_project_api_key(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an API key for a project.

        Creates an API key for a project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: API Key to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "read_only": bool  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "description": "str",  # Optional. Available only for API keys.
                    "id": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "read_only": bool,  # Optional.
                    "token": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_project_api_key(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an API key for a project.

        Creates an API key for a project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: API Key to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "description": "str",  # Optional. Available only for API keys.
                    "id": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "read_only": bool,  # Optional.
                    "token": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_project_api_key(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create an API key for a project.

        Creates an API key for a project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: API Key to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "description": "str",  # Optional. Available only for API keys.
                    "id": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "read_only": bool,  # Optional.
                    "token": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_project_api_key_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_batches_by_project(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all batches by project.

        Returns all batches for the given project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "batches": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "devices": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "error_messages": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "quantity": 0,  # Optional.
                            "state": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_batches_by_project_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_bgp_config_by_project(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a bgp config.

        Returns a bgp config.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "asn": 0,  # Optional. Autonomous System Number. ASN is required with Global
                      BGP. With Local BGP the private ASN, 65000, is assigned.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "deployment_type": "str",  # Optional. In a Local BGP deployment, a customer
                      uses an internal ASN to control routes within a single Equinix Metal datacenter.
                      This means that the routes are never advertised to the global Internet. Global
                      BGP, on the other hand, requires a customer to have a registered ASN and IP
                      space. Known values are: "global" and "local".
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "max_prefix": 10,  # Optional. Default value is 10. The maximum number of
                      route filters allowed per server.
                    "md5": "str",  # Optional. (Optional) Password for BGP session in plaintext
                      (not a checksum).
                    "project": {
                        "href": "str"  # Required.
                    },
                    "ranges": [
                        {
                            "address_family": 0,  # Optional. The IP block ranges
                              associated to the ASN (Populated in Global BGP only).
                            "href": "str",  # Optional. The IP block ranges associated to
                              the ASN (Populated in Global BGP only).
                            "id": "str",  # Optional. The IP block ranges associated to
                              the ASN (Populated in Global BGP only).
                            "project": {
                                "href": "str"  # Required.
                            },
                            "range": "str"  # Optional. The IP block ranges associated to
                              the ASN (Populated in Global BGP only).
                        }
                    ],
                    "requested_at": "2020-02-20 00:00:00",  # Optional.
                    "route_object": "str",  # Optional. Specifies AS-MACRO (aka AS-SET) to use
                      when building client route filters.
                    "sessions": [
                        {
                            "address_family": "str",  # Required. Known values are:
                              "ipv4" and "ipv6".
                            "created_at": "2020-02-20 00:00:00",  # Optional. The direct
                              connections between neighboring routers that want to exchange routing
                              information.
                            "default_route": bool,  # Optional. The direct connections
                              between neighboring routers that want to exchange routing information.
                            "device": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional. The direct connections between
                              neighboring routers that want to exchange routing information.
                            "id": "str",  # Optional. The direct connections between
                              neighboring routers that want to exchange routing information.
                            "learned_routes": [
                                "str"  # Optional. The direct connections between
                                  neighboring routers that want to exchange routing information.
                            ],
                            "status": "str",  # Optional. The status of the BGP Session.
                              Multiple status values may be reported when the device is connected to
                              multiple switches, one value per switch. Each status will start with
                              "unknown" and progress to "up" or "down" depending on the connected
                              device. Subsequent "unknown" values indicate a problem acquiring status
                              from the switch. Known values are: "unknown", "up", and "down".
                            "updated_at": "2020-02-20 00:00:00"  # Optional. The direct
                              connections between neighboring routers that want to exchange routing
                              information.
                        }
                    ],
                    "status": "str"  # Optional. Status of the BGP Config. Status "requested" is
                      valid only with the "global" deployment_type. Known values are: "requested",
                      "enabled", and "disabled".
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_bgp_config_by_project_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def request_bgp_config(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Requesting bgp config.

        Requests to enable bgp configuration for a project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: BGP config Request to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "asn": 0,  # Required.
                    "deployment_type": "str",  # Required.
                    "md5": "str",  # Optional.
                    "use_case": "str"  # Optional.
                }

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def request_bgp_config(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Optional[JSON]:
        """Requesting bgp config.

        Requests to enable bgp configuration for a project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: BGP config Request to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def request_bgp_config(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        """Requesting bgp config.

        Requests to enable bgp configuration for a project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: BGP config Request to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_request_bgp_config_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_project_bgp_sessions(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve all BGP sessions for project.

        Provides a listing of available BGP sessions for the project.

        :param id: Project UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "bgp_sessions": [
                        {
                            "address_family": "str",  # Required. Known values are:
                              "ipv4" and "ipv6".
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "default_route": bool,  # Optional.
                            "device": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "learned_routes": [
                                "str"  # Optional.
                            ],
                            "status": "str",  # Optional. The status of the BGP Session.
                              Multiple status values may be reported when the device is connected to
                              multiple switches, one value per switch. Each status will start with
                              "unknown" and progress to "up" or "down" depending on the connected
                              device. Subsequent "unknown" values indicate a problem acquiring status
                              from the switch. Known values are: "unknown", "up", and "down".
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_bgp_sessions_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_customdata(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Retrieve the custom metadata of a project.

        Provides the custom metadata stored for this project in json format.

        :param id: Project UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_project_customdata_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_project_devices(
        self,
        id: str,
        *,
        facility: Optional[str] = None,
        hostname: Optional[str] = None,
        reserved: Optional[bool] = None,
        tag: Optional[str] = None,
        type: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all devices of a project.

        Provides a collection of devices for a given project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword facility: Filter by device facility. Default value is None.
        :paramtype facility: str
        :keyword hostname: Filter by partial hostname. Default value is None.
        :paramtype hostname: str
        :keyword reserved: Filter only reserved instances. Default value is None.
        :paramtype reserved: bool
        :keyword tag: Filter by device tag. Default value is None.
        :paramtype tag: str
        :keyword type: Filter by instance type (ondemand,spot,reserved). Default value is None.
        :paramtype type: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "devices": [
                        {
                            "actions": [
                                {
                                    "name": "str",  # Optional. Actions supported
                                      by the device instance.
                                    "type": "str"  # Optional. Actions supported
                                      by the device instance.
                                }
                            ],
                            "always_pxe": bool,  # Optional.
                            "billing_cycle": "str",  # Optional.
                            "bonding_mode": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "created_by": {
                                "avatar_thumb_url": "str",  # Optional. Avatar
                                  thumbnail URL of the User.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                  When the user was created.
                                "email": "str",  # Optional. Primary email address of
                                  the User.
                                "first_name": "str",  # Optional. First name of the
                                  User.
                                "full_name": "str",  # Optional. Full name of the
                                  User.
                                "href": "str",  # Optional. API URL uniquely
                                  representing the User.
                                "id": "str",  # ID of the User. Required.
                                "last_name": "str",  # Optional. Last name of the
                                  User.
                                "short_id": "str",  # Short ID of the User. Required.
                                "updated_at": "2020-02-20 00:00:00"  # Optional. When
                                  the user details were last updated.
                            },
                            "customdata": {},  # Optional. Any object.
                            "description": "str",  # Optional.
                            "facility": {
                                "address": {
                                    "address": "str",  # Required.
                                    "address2": "str",  # Optional.
                                    "city": "str",  # Optional.
                                    "coordinates": {
                                        "latitude": "str",  # Optional.
                                        "longitude": "str"  # Optional.
                                    },
                                    "country": "str",  # Required.
                                    "state": "str",  # Optional.
                                    "zip_code": "str"  # Required.
                                },
                                "code": "str",  # Optional.
                                "features": [
                                    "str"  # Optional.
                                ],
                                "id": "str",  # Optional.
                                "ip_ranges": [
                                    "str"  # Optional. IP ranges registered in
                                      facility. Can be used for GeoIP location.
                                ],
                                "metro": {
                                    "code": "str",  # Optional.
                                    "country": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "name": "str"  # Optional.
                                },
                                "name": "str"  # Optional.
                            },
                            "hardware_reservation": {
                                "href": "str"  # Required.
                            },
                            "hostname": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "image_url": "str",  # Optional.
                            "ip_addresses": [
                                {
                                    "address": "str",  # Optional.
                                    "address_family": 0,  # Optional.
                                    "assigned_to": {
                                        "href": "str"  # Required.
                                    },
                                    "cidr": 0,  # Optional.
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional.
                                    "enabled": bool,  # Optional.
                                    "gateway": "str",  # Optional.
                                    "global_ip": bool,  # Optional.
                                    "href": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "manageable": bool,  # Optional.
                                    "management": bool,  # Optional.
                                    "metro": {
                                        "code": "str",  # Optional.
                                        "country": "str",  # Optional.
                                        "id": "str",  # Optional.
                                        "name": "str"  # Optional.
                                    },
                                    "netmask": "str",  # Optional.
                                    "network": "str",  # Optional.
                                    "parent_block": {
                                        "cidr": 0,  # Optional.
                                        "href": "str",  # Optional.
                                        "netmask": "str",  # Optional.
                                        "network": "str"  # Optional.
                                    },
                                    "public": bool  # Optional.
                                }
                            ],
                            "ipxe_script_url": "str",  # Optional.
                            "iqn": "str",  # Optional.
                            "locked": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "network_ports": [
                                {
                                    "bond": {
                                        "id": "str",  # Optional. ID of the
                                          bonding port.
                                        "name": "str"  # Optional. Name of
                                          the port interface for the bond ("bond0").
                                    },
                                    "data": {
                                        "bonded": bool,  # Optional. Bonded
                                          is true for NetworkPort ports in a bond and NetworkBondPort
                                          ports that are active.
                                        "mac": "str"  # Optional. MAC address
                                          is set for NetworkPort ports.
                                    },
                                    "disbond_operation_supported": bool,  #
                                      Optional. Indicates whether or not the bond can be broken on the
                                      port (when applicable).
                                    "href": "str",  # Optional. By default,
                                      servers at Equinix Metal are configured in a "u201cbonded"u201d
                                      mode using LACP (Link Aggregation Control Protocol). Each 2-NIC
                                      server is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "id": "str",  # Optional. By default, servers
                                      at Equinix Metal are configured in a "u201cbonded"u201d mode
                                      using LACP (Link Aggregation Control Protocol). Each 2-NIC server
                                      is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "name": "str",  # Optional. By default,
                                      servers at Equinix Metal are configured in a "u201cbonded"u201d
                                      mode using LACP (Link Aggregation Control Protocol). Each 2-NIC
                                      server is configured with a single bond (namely bond0) with both
                                      interfaces eth0 and eth1 as members of the bond in a default
                                      Layer 3 mode. Some device plans may have a different number of
                                      ports and bonds available.
                                    "native_virtual_network": {
                                        "assigned_to": {
                                            "href": "str"  # Required.
                                        },
                                        "assigned_to_virtual_circuit": bool,
                                          # Optional. True if the virtual network is attached to a
                                          virtual circuit. False if not.
                                        "description": "str",  # Optional. By
                                          default, servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "facility": {
                                            "href": "str"  # Required.
                                        },
                                        "href": "str",  # Optional. By
                                          default, servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "id": "str",  # Optional. By default,
                                          servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "instances": [
                                            {
                                                "href": "str"  #
                                                  Required.
                                            }
                                        ],
                                        "metal_gateways": [
                                            {
                                                "created_at":
                                                  "2020-02-20 00:00:00",  # Optional. A list of metal
                                                  gateways currently associated to this Virtual
                                                  Network.
                                                "gateway_address":
                                                  "str",  # Optional. The gateway address with subnet
                                                  CIDR value for this Metal Gateway. For example, a
                                                  Metal Gateway using an IP reservation with block
                                                  10.1.2.0/27 would have a gateway address of
                                                  10.1.2.1/27.
                                                "href": "str",  #
                                                  Optional. A list of metal gateways currently
                                                  associated to this Virtual Network.
                                                "id": "str",  #
                                                  Optional. A list of metal gateways currently
                                                  associated to this Virtual Network.
                                                "state": "str",  #
                                                  Optional. The current state of the Metal Gateway.
                                                  'Ready' indicates the gateway record has been
                                                  configured, but is currently not active on the
                                                  network. 'Active' indicates the gateway has been
                                                  configured on the network. 'Deleting' is a temporary
                                                  state used to indicate that the gateway is in the
                                                  process of being un-configured from the network,
                                                  after which the gateway record will be deleted. Known
                                                  values are: "ready", "active", and "deleting".
                                                "updated_at":
                                                  "2020-02-20 00:00:00",  # Optional. A list of metal
                                                  gateways currently associated to this Virtual
                                                  Network.
                                                "vlan": 0  #
                                                  Optional. The VLAN id of the Virtual Network record
                                                  associated to this Metal Gateway.
                                            }
                                        ],
                                        "metro": {
                                            "href": "str"  # Required.
                                        },
                                        "metro_code": "str",  # Optional. The
                                          Metro code of the metro in which this Virtual Network is
                                          defined.
                                        "vxlan": 0  # Optional. By default,
                                          servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                    },
                                    "network_type": "str",  # Optional. Composite
                                      network type of the bond. Known values are: "layer2-bonded",
                                      "layer2-individual", "layer3", "hybrid", and "hybrid-bonded".
                                    "type": "str",  # Optional. Type is either
                                      "NetworkBondPort" for bond ports or "NetworkPort" for bondable
                                      ethernet ports. Known values are: "NetworkPort" and
                                      "NetworkBondPort".
                                    "virtual_networks": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ]
                                }
                            ],
                            "operating_system": {
                                "distro": "str",  # Optional.
                                "id": "str",  # Optional.
                                "licensed": bool,  # Optional. Licenced OS is priced
                                  according to pricing property.
                                "name": "str",  # Optional.
                                "preinstallable": bool,  # Optional. Servers can be
                                  already preinstalled with OS in order to shorten provision time.
                                "pricing": {},  # Optional. This object contains
                                  price per time unit and optional multiplier value if licence price
                                  depends on hardware plan or components (e.g. number of cores).
                                "provisionable_on": [
                                    "str"  # Optional.
                                ],
                                "slug": "str",  # Optional.
                                "version": "str"  # Optional.
                            },
                            "plan": {
                                "available_in": [
                                    {
                                        "href": "str",  # Optional. href to
                                          the Facility.
                                        "price": {
                                            "hour": 0.0  # Optional.
                                              Shows which facilities the plan is available in, and the
                                              facility-based price if it is different from the default
                                              price.
                                        }
                                    }
                                ],
                                "available_in_metros": [
                                    {
                                        "href": "str",  # Optional. href to
                                          the Metro.
                                        "price": {
                                            "hour": 0.0  # Optional.
                                              Shows which metros the plan is available in, and the
                                              metro-based price if it is different from the default
                                              price.
                                        }
                                    }
                                ],
                                "class": "str",  # Optional.
                                "deployment_types": [
                                    "str"  # Optional.
                                ],
                                "description": "str",  # Optional.
                                "id": "str",  # Optional.
                                "legacy": bool,  # Optional.
                                "line": "str",  # Optional. "baremetal"
                                "name": "str",  # Optional.
                                "pricing": {},  # Optional. Any object.
                                "slug": "str",  # Optional.
                                "specs": {
                                    "cpus": [
                                        {
                                            "count": 0,  # Optional.
                                            "type": "str"  # Optional.
                                        }
                                    ],
                                    "drives": [
                                        {
                                            "category": "str",  #
                                              Optional. Known values are: "boot", "cache", and
                                              "storage".
                                            "count": 0,  # Optional.
                                            "size": "str",  # Optional.
                                            "type": "str"  # Optional.
                                              Known values are: "HDD", "SSD", and "NVME".
                                        }
                                    ],
                                    "features": {
                                        "raid": bool,  # Optional.
                                        "txt": bool,  # Optional.
                                        "uefi": bool  # Optional.
                                    },
                                    "nics": [
                                        {
                                            "count": 0,  # Optional.
                                            "type": "str"  # Optional.
                                              Known values are: "1Gbps", "10Gbps", and "25Gbps".
                                        }
                                    ]
                                },
                                "type": "str"  # Optional. The plan type. Known
                                  values are: "standard", "workload_optimized", and "custom".
                            },
                            "project": {
                                "href": "str"  # Required.
                            },
                            "project_lite": {
                                "href": "str"  # Required.
                            },
                            "provisioning_events": [
                                {
                                    "body": "str",  # Optional.
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional.
                                    "href": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "interpolated": "str",  # Optional.
                                    "relationships": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "state": "str",  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "provisioning_percentage": 0.0,  # Optional. Only visible
                              while device provisioning.
                            "root_password": "str",  # Optional. Root password is
                              automatically generated when server is provisioned and it is removed
                              after 24 hours.
                            "short_id": "str",  # Optional.
                            "spot_instance": bool,  # Optional. Whether or not the device
                              is a spot instance.
                            "spot_price_max": 0.0,  # Optional. The maximum price per
                              hour you are willing to pay to keep this spot"ninstance.  If you are
                              outbid, the termination will be set allowing two"nminutes before
                              shutdown.
                            "ssh_keys": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional. Known values are: "active",
                              "deleted", "deprovisioning", "failed", "inactive", "queued",
                              "reinstalling", "post_provisioning", "powering_on", "powering_off", and
                              "provisioning".
                            "switch_uuid": "str",  # Optional. Switch short id. This can
                              be used to determine if two devices are"nconnected to the same switch,
                              for example.
                            "tags": [
                                "str"  # Optional.
                            ],
                            "termination_time": "2020-02-20 00:00:00",  # Optional. When
                              the device will be terminated. This is commonly set in advance
                              for"nephemeral spot market instances but this field may also be set
                              with"non-demand and reservation instances to automatically delete the
                              resource"nat a given time. The termination time can also be used to
                              release a"nhardware reservation instance at a given time, keeping the
                              reservation"nopen for other uses.  On a spot market device, the
                              termination time will"nbe set automatically when outbid.
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": "str",  # Optional.
                            "userdata": "str",  # Optional.
                            "volumes": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_devices_request(
            id=id,
            facility=facility,
            hostname=hostname,
            reserved=reserved,
            tag=tag,
            type=type,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_device(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a device.

        Creates a new device and provisions it in the specified location.

        Device type-specific options are accepted.  For example, ``baremetal`` devices accept
        ``operating_system``\ , ``hostname``\ , and ``plan``. These parameters may not be accepted for
        other device types. The default device type is ``baremetal``.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Device to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 201
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_device(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a device.

        Creates a new device and provisions it in the specified location.

        Device type-specific options are accepted.  For example, ``baremetal`` devices accept
        ``operating_system``\ , ``hostname``\ , and ``plan``. These parameters may not be accepted for
        other device types. The default device type is ``baremetal``.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Device to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_device(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a device.

        Creates a new device and provisions it in the specified location.

        Device type-specific options are accepted.  For example, ``baremetal`` devices accept
        ``operating_system``\ , ``hostname``\ , and ``plan``. These parameters may not be accepted for
        other device types. The default device type is ``baremetal``.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Device to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "actions": [
                        {
                            "name": "str",  # Optional. Actions supported by the device
                              instance.
                            "type": "str"  # Optional. Actions supported by the device
                              instance.
                        }
                    ],
                    "always_pxe": bool,  # Optional.
                    "billing_cycle": "str",  # Optional.
                    "bonding_mode": 0,  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional. Avatar thumbnail URL of the
                          User.
                        "created_at": "2020-02-20 00:00:00",  # Optional. When the user was
                          created.
                        "email": "str",  # Optional. Primary email address of the User.
                        "first_name": "str",  # Optional. First name of the User.
                        "full_name": "str",  # Optional. Full name of the User.
                        "href": "str",  # Optional. API URL uniquely representing the User.
                        "id": "str",  # ID of the User. Required.
                        "last_name": "str",  # Optional. Last name of the User.
                        "short_id": "str",  # Short ID of the User. Required.
                        "updated_at": "2020-02-20 00:00:00"  # Optional. When the user
                          details were last updated.
                    },
                    "customdata": {},  # Optional. Any object.
                    "description": "str",  # Optional.
                    "facility": {
                        "address": {
                            "address": "str",  # Required.
                            "address2": "str",  # Optional.
                            "city": "str",  # Optional.
                            "coordinates": {
                                "latitude": "str",  # Optional.
                                "longitude": "str"  # Optional.
                            },
                            "country": "str",  # Required.
                            "state": "str",  # Optional.
                            "zip_code": "str"  # Required.
                        },
                        "code": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "id": "str",  # Optional.
                        "ip_ranges": [
                            "str"  # Optional. IP ranges registered in facility. Can be
                              used for GeoIP location.
                        ],
                        "metro": {
                            "code": "str",  # Optional.
                            "country": "str",  # Optional.
                            "id": "str",  # Optional.
                            "name": "str"  # Optional.
                        },
                        "name": "str"  # Optional.
                    },
                    "hardware_reservation": {
                        "href": "str"  # Required.
                    },
                    "hostname": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "image_url": "str",  # Optional.
                    "ip_addresses": [
                        {
                            "address": "str",  # Optional.
                            "address_family": 0,  # Optional.
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "enabled": bool,  # Optional.
                            "gateway": "str",  # Optional.
                            "global_ip": bool,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "manageable": bool,  # Optional.
                            "management": bool,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "parent_block": {
                                "cidr": 0,  # Optional.
                                "href": "str",  # Optional.
                                "netmask": "str",  # Optional.
                                "network": "str"  # Optional.
                            },
                            "public": bool  # Optional.
                        }
                    ],
                    "ipxe_script_url": "str",  # Optional.
                    "iqn": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "network_ports": [
                        {
                            "bond": {
                                "id": "str",  # Optional. ID of the bonding port.
                                "name": "str"  # Optional. Name of the port interface
                                  for the bond ("bond0").
                            },
                            "data": {
                                "bonded": bool,  # Optional. Bonded is true for
                                  NetworkPort ports in a bond and NetworkBondPort ports that are
                                  active.
                                "mac": "str"  # Optional. MAC address is set for
                                  NetworkPort ports.
                            },
                            "disbond_operation_supported": bool,  # Optional. Indicates
                              whether or not the bond can be broken on the port (when applicable).
                            "href": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "id": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "name": "str",  # Optional. By default, servers at Equinix
                              Metal are configured in a "u201cbonded"u201d mode using LACP (Link
                              Aggregation Control Protocol). Each 2-NIC server is configured with a
                              single bond (namely bond0) with both interfaces eth0 and eth1 as members
                              of the bond in a default Layer 3 mode. Some device plans may have a
                              different number of ports and bonds available.
                            "native_virtual_network": {
                                "assigned_to": {
                                    "href": "str"  # Required.
                                },
                                "assigned_to_virtual_circuit": bool,  # Optional.
                                  True if the virtual network is attached to a virtual circuit. False
                                  if not.
                                "description": "str",  # Optional. By default,
                                  servers at Equinix Metal are configured in a "u201cbonded"u201d mode
                                  using LACP (Link Aggregation Control Protocol). Each 2-NIC server is
                                  configured with a single bond (namely bond0) with both interfaces
                                  eth0 and eth1 as members of the bond in a default Layer 3 mode. Some
                                  device plans may have a different number of ports and bonds
                                  available.
                                "facility": {
                                    "href": "str"  # Required.
                                },
                                "href": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "id": "str",  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                                "instances": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "metal_gateways": [
                                    {
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "gateway_address": "str",  #
                                          Optional. The gateway address with subnet CIDR value for this
                                          Metal Gateway. For example, a Metal Gateway using an IP
                                          reservation with block 10.1.2.0/27 would have a gateway
                                          address of 10.1.2.1/27.
                                        "href": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "id": "str",  # Optional. A list of
                                          metal gateways currently associated to this Virtual Network.
                                        "state": "str",  # Optional. The
                                          current state of the Metal Gateway. 'Ready' indicates the
                                          gateway record has been configured, but is currently not
                                          active on the network. 'Active' indicates the gateway has
                                          been configured on the network. 'Deleting' is a temporary
                                          state used to indicate that the gateway is in the process of
                                          being un-configured from the network, after which the gateway
                                          record will be deleted. Known values are: "ready", "active",
                                          and "deleting".
                                        "updated_at": "2020-02-20 00:00:00",
                                          # Optional. A list of metal gateways currently associated to
                                          this Virtual Network.
                                        "vlan": 0  # Optional. The VLAN id of
                                          the Virtual Network record associated to this Metal Gateway.
                                    }
                                ],
                                "metro": {
                                    "href": "str"  # Required.
                                },
                                "metro_code": "str",  # Optional. The Metro code of
                                  the metro in which this Virtual Network is defined.
                                "vxlan": 0  # Optional. By default, servers at
                                  Equinix Metal are configured in a "u201cbonded"u201d mode using LACP
                                  (Link Aggregation Control Protocol). Each 2-NIC server is configured
                                  with a single bond (namely bond0) with both interfaces eth0 and eth1
                                  as members of the bond in a default Layer 3 mode. Some device plans
                                  may have a different number of ports and bonds available.
                            },
                            "network_type": "str",  # Optional. Composite network type of
                              the bond. Known values are: "layer2-bonded", "layer2-individual",
                              "layer3", "hybrid", and "hybrid-bonded".
                            "type": "str",  # Optional. Type is either "NetworkBondPort"
                              for bond ports or "NetworkPort" for bondable ethernet ports. Known values
                              are: "NetworkPort" and "NetworkBondPort".
                            "virtual_networks": [
                                {
                                    "href": "str"  # Required.
                                }
                            ]
                        }
                    ],
                    "operating_system": {
                        "distro": "str",  # Optional.
                        "id": "str",  # Optional.
                        "licensed": bool,  # Optional. Licenced OS is priced according to
                          pricing property.
                        "name": "str",  # Optional.
                        "preinstallable": bool,  # Optional. Servers can be already
                          preinstalled with OS in order to shorten provision time.
                        "pricing": {},  # Optional. This object contains price per time unit
                          and optional multiplier value if licence price depends on hardware plan or
                          components (e.g. number of cores).
                        "provisionable_on": [
                            "str"  # Optional.
                        ],
                        "slug": "str",  # Optional.
                        "version": "str"  # Optional.
                    },
                    "plan": {
                        "available_in": [
                            {
                                "href": "str",  # Optional. href to the Facility.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which
                                      facilities the plan is available in, and the facility-based price
                                      if it is different from the default price.
                                }
                            }
                        ],
                        "available_in_metros": [
                            {
                                "href": "str",  # Optional. href to the Metro.
                                "price": {
                                    "hour": 0.0  # Optional. Shows which metros
                                      the plan is available in, and the metro-based price if it is
                                      different from the default price.
                                }
                            }
                        ],
                        "class": "str",  # Optional.
                        "deployment_types": [
                            "str"  # Optional.
                        ],
                        "description": "str",  # Optional.
                        "id": "str",  # Optional.
                        "legacy": bool,  # Optional.
                        "line": "str",  # Optional. "baremetal"
                        "name": "str",  # Optional.
                        "pricing": {},  # Optional. Any object.
                        "slug": "str",  # Optional.
                        "specs": {
                            "cpus": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional.
                                }
                            ],
                            "drives": [
                                {
                                    "category": "str",  # Optional. Known values
                                      are: "boot", "cache", and "storage".
                                    "count": 0,  # Optional.
                                    "size": "str",  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "HDD", "SSD", and "NVME".
                                }
                            ],
                            "features": {
                                "raid": bool,  # Optional.
                                "txt": bool,  # Optional.
                                "uefi": bool  # Optional.
                            },
                            "nics": [
                                {
                                    "count": 0,  # Optional.
                                    "type": "str"  # Optional. Known values are:
                                      "1Gbps", "10Gbps", and "25Gbps".
                                }
                            ]
                        },
                        "type": "str"  # Optional. The plan type. Known values are:
                          "standard", "workload_optimized", and "custom".
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "project_lite": {
                        "href": "str"  # Required.
                    },
                    "provisioning_events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "provisioning_percentage": 0.0,  # Optional. Only visible while device
                      provisioning.
                    "root_password": "str",  # Optional. Root password is automatically generated
                      when server is provisioned and it is removed after 24 hours.
                    "short_id": "str",  # Optional.
                    "spot_instance": bool,  # Optional. Whether or not the device is a spot
                      instance.
                    "spot_price_max": 0.0,  # Optional. The maximum price per hour you are
                      willing to pay to keep this spot"ninstance.  If you are outbid, the termination
                      will be set allowing two"nminutes before shutdown.
                    "ssh_keys": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional. Known values are: "active", "deleted",
                      "deprovisioning", "failed", "inactive", "queued", "reinstalling",
                      "post_provisioning", "powering_on", "powering_off", and "provisioning".
                    "switch_uuid": "str",  # Optional. Switch short id. This can be used to
                      determine if two devices are"nconnected to the same switch, for example.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "termination_time": "2020-02-20 00:00:00",  # Optional. When the device will
                      be terminated. This is commonly set in advance for"nephemeral spot market
                      instances but this field may also be set with"non-demand and reservation
                      instances to automatically delete the resource"nat a given time. The termination
                      time can also be used to release a"nhardware reservation instance at a given
                      time, keeping the reservation"nopen for other uses.  On a spot market device, the
                      termination time will"nbe set automatically when outbid.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": "str",  # Optional.
                    "userdata": "str",  # Optional.
                    "volumes": [
                        {
                            "href": "str"  # Required.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_device_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_device_batch(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a devices batch.

        Creates new devices in batch and provisions them in our datacenter.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Batches to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "batches": [
                        {
                            "hostnames": [
                                "str"  # Optional.
                            ],
                            "quantity": 0  # Optional. The number of devices to create in
                              this batch. The hostname may contain an ``{{index}}`` placeholder, which
                              will be replaced with the index of the device in the batch. For example,
                              if the hostname is ``device-{{index}}``"" , the first device in the batch
                              will have the hostname ``device-01``"" , the second device will have the
                              hostname ``device-02``"" , and so on.
                        }
                    ]
                }

                # response body for status code(s): 201
                response == {
                    "batches": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "devices": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "error_messages": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "quantity": 0,  # Optional.
                            "state": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_device_batch(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a devices batch.

        Creates new devices in batch and provisions them in our datacenter.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Batches to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "batches": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "devices": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "error_messages": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "quantity": 0,  # Optional.
                            "state": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_device_batch(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a devices batch.

        Creates new devices in batch and provisions them in our datacenter.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Batches to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "batches": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "devices": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "error_messages": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "quantity": 0,  # Optional.
                            "state": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_device_batch_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_events(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve project's events.

        Returns a list of events for a single project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "events": [
                        {
                            "body": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "interpolated": "str",  # Optional.
                            "relationships": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "state": "str",  # Optional.
                            "type": "str"  # Optional.
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_events_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_facilities_by_project(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all facilities visible by the project.

        Returns a listing of available datacenters for the given project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "facilities": [
                        {
                            "address": {
                                "address": "str",  # Required.
                                "address2": "str",  # Optional.
                                "city": "str",  # Optional.
                                "coordinates": {
                                    "latitude": "str",  # Optional.
                                    "longitude": "str"  # Optional.
                                },
                                "country": "str",  # Required.
                                "state": "str",  # Optional.
                                "zip_code": "str"  # Required.
                            },
                            "code": "str",  # Optional.
                            "features": [
                                "str"  # Optional.
                            ],
                            "id": "str",  # Optional.
                            "ip_ranges": [
                                "str"  # Optional. IP ranges registered in facility.
                                  Can be used for GeoIP location.
                            ],
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "name": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_facilities_by_project_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_global_bgp_ranges(self, id: str, **kwargs: Any) -> JSON:
        """Retrieve all global bgp ranges.

        Returns all global bgp ranges for a project.

        :param id: Project UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "global_bgp_ranges": [
                        {
                            "address_family": 0,  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "range": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_global_bgp_ranges_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_hardware_reservations(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all hardware reservations for a given project.

        Provides a collection of hardware reservations for a given project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "hardware_reservations": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "custom_rate": 0.0,  # Optional. Amount that will be charged
                              for every billing_cycle.
                            "device": {
                                "actions": [
                                    {
                                        "name": "str",  # Optional. Actions
                                          supported by the device instance.
                                        "type": "str"  # Optional. Actions
                                          supported by the device instance.
                                    }
                                ],
                                "always_pxe": bool,  # Optional.
                                "billing_cycle": "str",  # Optional.
                                "bonding_mode": 0,  # Optional.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "created_by": {
                                    "avatar_thumb_url": "str",  # Optional.
                                      Avatar thumbnail URL of the User.
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. When the user was created.
                                    "email": "str",  # Optional. Primary email
                                      address of the User.
                                    "first_name": "str",  # Optional. First name
                                      of the User.
                                    "full_name": "str",  # Optional. Full name of
                                      the User.
                                    "href": "str",  # Optional. API URL uniquely
                                      representing the User.
                                    "id": "str",  # ID of the User. Required.
                                    "last_name": "str",  # Optional. Last name of
                                      the User.
                                    "short_id": "str",  # Short ID of the User.
                                      Required.
                                    "updated_at": "2020-02-20 00:00:00"  #
                                      Optional. When the user details were last updated.
                                },
                                "customdata": {},  # Optional. Any object.
                                "description": "str",  # Optional.
                                "facility": {
                                    "address": {
                                        "address": "str",  # Required.
                                        "address2": "str",  # Optional.
                                        "city": "str",  # Optional.
                                        "coordinates": {
                                            "latitude": "str",  #
                                              Optional.
                                            "longitude": "str"  #
                                              Optional.
                                        },
                                        "country": "str",  # Required.
                                        "state": "str",  # Optional.
                                        "zip_code": "str"  # Required.
                                    },
                                    "code": "str",  # Optional.
                                    "features": [
                                        "str"  # Optional.
                                    ],
                                    "id": "str",  # Optional.
                                    "ip_ranges": [
                                        "str"  # Optional. IP ranges
                                          registered in facility. Can be used for GeoIP location.
                                    ],
                                    "metro": {
                                        "code": "str",  # Optional.
                                        "country": "str",  # Optional.
                                        "id": "str",  # Optional.
                                        "name": "str"  # Optional.
                                    },
                                    "name": "str"  # Optional.
                                },
                                "hardware_reservation": {
                                    "href": "str"  # Required.
                                },
                                "hostname": "str",  # Optional.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "image_url": "str",  # Optional.
                                "ip_addresses": [
                                    {
                                        "address": "str",  # Optional.
                                        "address_family": 0,  # Optional.
                                        "assigned_to": {
                                            "href": "str"  # Required.
                                        },
                                        "cidr": 0,  # Optional.
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional.
                                        "enabled": bool,  # Optional.
                                        "gateway": "str",  # Optional.
                                        "global_ip": bool,  # Optional.
                                        "href": "str",  # Optional.
                                        "id": "str",  # Optional.
                                        "manageable": bool,  # Optional.
                                        "management": bool,  # Optional.
                                        "metro": {
                                            "code": "str",  # Optional.
                                            "country": "str",  #
                                              Optional.
                                            "id": "str",  # Optional.
                                            "name": "str"  # Optional.
                                        },
                                        "netmask": "str",  # Optional.
                                        "network": "str",  # Optional.
                                        "parent_block": {
                                            "cidr": 0,  # Optional.
                                            "href": "str",  # Optional.
                                            "netmask": "str",  #
                                              Optional.
                                            "network": "str"  # Optional.
                                        },
                                        "public": bool  # Optional.
                                    }
                                ],
                                "ipxe_script_url": "str",  # Optional.
                                "iqn": "str",  # Optional.
                                "locked": bool,  # Optional.
                                "metro": {
                                    "code": "str",  # Optional.
                                    "country": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "name": "str"  # Optional.
                                },
                                "network_ports": [
                                    {
                                        "bond": {
                                            "id": "str",  # Optional. ID
                                              of the bonding port.
                                            "name": "str"  # Optional.
                                              Name of the port interface for the bond ("bond0").
                                        },
                                        "data": {
                                            "bonded": bool,  # Optional.
                                              Bonded is true for NetworkPort ports in a bond and
                                              NetworkBondPort ports that are active.
                                            "mac": "str"  # Optional. MAC
                                              address is set for NetworkPort ports.
                                        },
                                        "disbond_operation_supported": bool,
                                          # Optional. Indicates whether or not the bond can be broken
                                          on the port (when applicable).
                                        "href": "str",  # Optional. By
                                          default, servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "id": "str",  # Optional. By default,
                                          servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "name": "str",  # Optional. By
                                          default, servers at Equinix Metal are configured in a
                                          "u201cbonded"u201d mode using LACP (Link Aggregation Control
                                          Protocol). Each 2-NIC server is configured with a single bond
                                          (namely bond0) with both interfaces eth0 and eth1 as members
                                          of the bond in a default Layer 3 mode. Some device plans may
                                          have a different number of ports and bonds available.
                                        "native_virtual_network": {
                                            "assigned_to": {
                                                "href": "str"  #
                                                  Required.
                                            },
                "assigned_to_virtual_circuit": bool,  # Optional. True if
                                              the virtual network is attached to a virtual circuit.
                                              False if not.
                                            "description": "str",  #
                                              Optional. By default, servers at Equinix Metal are
                                              configured in a "u201cbonded"u201d mode using LACP (Link
                                              Aggregation Control Protocol). Each 2-NIC server is
                                              configured with a single bond (namely bond0) with both
                                              interfaces eth0 and eth1 as members of the bond in a
                                              default Layer 3 mode. Some device plans may have a
                                              different number of ports and bonds available.
                                            "facility": {
                                                "href": "str"  #
                                                  Required.
                                            },
                                            "href": "str",  # Optional.
                                              By default, servers at Equinix Metal are configured in a
                                              "u201cbonded"u201d mode using LACP (Link Aggregation
                                              Control Protocol). Each 2-NIC server is configured with a
                                              single bond (namely bond0) with both interfaces eth0 and
                                              eth1 as members of the bond in a default Layer 3 mode.
                                              Some device plans may have a different number of ports
                                              and bonds available.
                                            "id": "str",  # Optional. By
                                              default, servers at Equinix Metal are configured in a
                                              "u201cbonded"u201d mode using LACP (Link Aggregation
                                              Control Protocol). Each 2-NIC server is configured with a
                                              single bond (namely bond0) with both interfaces eth0 and
                                              eth1 as members of the bond in a default Layer 3 mode.
                                              Some device plans may have a different number of ports
                                              and bonds available.
                                            "instances": [
                                                {
                                                    "href": "str"
                                                      # Required.
                                                }
                                            ],
                                            "metal_gateways": [
                                                {
                                                    "created_at":
                                                      "2020-02-20 00:00:00",  # Optional. A list of
                                                      metal gateways currently associated to this
                                                      Virtual Network.
                "gateway_address": "str",  # Optional. The
                                                      gateway address with subnet CIDR value for this
                                                      Metal Gateway. For example, a Metal Gateway using
                                                      an IP reservation with block 10.1.2.0/27 would
                                                      have a gateway address of 10.1.2.1/27.
                                                    "href":
                                                      "str",  # Optional. A list of metal gateways
                                                      currently associated to this Virtual Network.
                                                    "id": "str",
                                                      # Optional. A list of metal gateways currently
                                                      associated to this Virtual Network.
                                                    "state":
                                                      "str",  # Optional. The current state of the
                                                      Metal Gateway. 'Ready' indicates the gateway
                                                      record has been configured, but is currently not
                                                      active on the network. 'Active' indicates the
                                                      gateway has been configured on the network.
                                                      'Deleting' is a temporary state used to indicate
                                                      that the gateway is in the process of being
                                                      un-configured from the network, after which the
                                                      gateway record will be deleted. Known values are:
                                                      "ready", "active", and "deleting".
                                                    "updated_at":
                                                      "2020-02-20 00:00:00",  # Optional. A list of
                                                      metal gateways currently associated to this
                                                      Virtual Network.
                                                    "vlan": 0  #
                                                      Optional. The VLAN id of the Virtual Network
                                                      record associated to this Metal Gateway.
                                                }
                                            ],
                                            "metro": {
                                                "href": "str"  #
                                                  Required.
                                            },
                                            "metro_code": "str",  #
                                              Optional. The Metro code of the metro in which this
                                              Virtual Network is defined.
                                            "vxlan": 0  # Optional. By
                                              default, servers at Equinix Metal are configured in a
                                              "u201cbonded"u201d mode using LACP (Link Aggregation
                                              Control Protocol). Each 2-NIC server is configured with a
                                              single bond (namely bond0) with both interfaces eth0 and
                                              eth1 as members of the bond in a default Layer 3 mode.
                                              Some device plans may have a different number of ports
                                              and bonds available.
                                        },
                                        "network_type": "str",  # Optional.
                                          Composite network type of the bond. Known values are:
                                          "layer2-bonded", "layer2-individual", "layer3", "hybrid", and
                                          "hybrid-bonded".
                                        "type": "str",  # Optional. Type is
                                          either "NetworkBondPort" for bond ports or "NetworkPort" for
                                          bondable ethernet ports. Known values are: "NetworkPort" and
                                          "NetworkBondPort".
                                        "virtual_networks": [
                                            {
                                                "href": "str"  #
                                                  Required.
                                            }
                                        ]
                                    }
                                ],
                                "operating_system": {
                                    "distro": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "licensed": bool,  # Optional. Licenced OS is
                                      priced according to pricing property.
                                    "name": "str",  # Optional.
                                    "preinstallable": bool,  # Optional. Servers
                                      can be already preinstalled with OS in order to shorten provision
                                      time.
                                    "pricing": {},  # Optional. This object
                                      contains price per time unit and optional multiplier value if
                                      licence price depends on hardware plan or components (e.g. number
                                      of cores).
                                    "provisionable_on": [
                                        "str"  # Optional.
                                    ],
                                    "slug": "str",  # Optional.
                                    "version": "str"  # Optional.
                                },
                                "plan": {
                                    "available_in": [
                                        {
                                            "href": "str",  # Optional.
                                              href to the Facility.
                                            "price": {
                                                "hour": 0.0  #
                                                  Optional. Shows which facilities the plan is
                                                  available in, and the facility-based price if it is
                                                  different from the default price.
                                            }
                                        }
                                    ],
                                    "available_in_metros": [
                                        {
                                            "href": "str",  # Optional.
                                              href to the Metro.
                                            "price": {
                                                "hour": 0.0  #
                                                  Optional. Shows which metros the plan is available
                                                  in, and the metro-based price if it is different from
                                                  the default price.
                                            }
                                        }
                                    ],
                                    "class": "str",  # Optional.
                                    "deployment_types": [
                                        "str"  # Optional.
                                    ],
                                    "description": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "legacy": bool,  # Optional.
                                    "line": "str",  # Optional. "baremetal"
                                    "name": "str",  # Optional.
                                    "pricing": {},  # Optional. Any object.
                                    "slug": "str",  # Optional.
                                    "specs": {
                                        "cpus": [
                                            {
                                                "count": 0,  #
                                                  Optional.
                                                "type": "str"  #
                                                  Optional.
                                            }
                                        ],
                                        "drives": [
                                            {
                                                "category": "str",  #
                                                  Optional. Known values are: "boot", "cache", and
                                                  "storage".
                                                "count": 0,  #
                                                  Optional.
                                                "size": "str",  #
                                                  Optional.
                                                "type": "str"  #
                                                  Optional. Known values are: "HDD", "SSD", and "NVME".
                                            }
                                        ],
                                        "features": {
                                            "raid": bool,  # Optional.
                                            "txt": bool,  # Optional.
                                            "uefi": bool  # Optional.
                                        },
                                        "nics": [
                                            {
                                                "count": 0,  #
                                                  Optional.
                                                "type": "str"  #
                                                  Optional. Known values are: "1Gbps", "10Gbps", and
                                                  "25Gbps".
                                            }
                                        ]
                                    },
                                    "type": "str"  # Optional. The plan type.
                                      Known values are: "standard", "workload_optimized", and "custom".
                                },
                                "project": {
                                    "href": "str"  # Required.
                                },
                                "project_lite": {
                                    "href": "str"  # Required.
                                },
                                "provisioning_events": [
                                    {
                                        "body": "str",  # Optional.
                                        "created_at": "2020-02-20 00:00:00",
                                          # Optional.
                                        "href": "str",  # Optional.
                                        "id": "str",  # Optional.
                                        "interpolated": "str",  # Optional.
                                        "relationships": [
                                            {
                                                "href": "str"  #
                                                  Required.
                                            }
                                        ],
                                        "state": "str",  # Optional.
                                        "type": "str"  # Optional.
                                    }
                                ],
                                "provisioning_percentage": 0.0,  # Optional. Only
                                  visible while device provisioning.
                                "root_password": "str",  # Optional. Root password is
                                  automatically generated when server is provisioned and it is removed
                                  after 24 hours.
                                "short_id": "str",  # Optional.
                                "spot_instance": bool,  # Optional. Whether or not
                                  the device is a spot instance.
                                "spot_price_max": 0.0,  # Optional. The maximum price
                                  per hour you are willing to pay to keep this spot"ninstance.  If you
                                  are outbid, the termination will be set allowing two"nminutes before
                                  shutdown.
                                "ssh_keys": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "state": "str",  # Optional. Known values are:
                                  "active", "deleted", "deprovisioning", "failed", "inactive",
                                  "queued", "reinstalling", "post_provisioning", "powering_on",
                                  "powering_off", and "provisioning".
                                "switch_uuid": "str",  # Optional. Switch short id.
                                  This can be used to determine if two devices are"nconnected to the
                                  same switch, for example.
                                "tags": [
                                    "str"  # Optional.
                                ],
                                "termination_time": "2020-02-20 00:00:00",  #
                                  Optional. When the device will be terminated. This is commonly set in
                                  advance for"nephemeral spot market instances but this field may also
                                  be set with"non-demand and reservation instances to automatically
                                  delete the resource"nat a given time. The termination time can also
                                  be used to release a"nhardware reservation instance at a given time,
                                  keeping the reservation"nopen for other uses.  On a spot market
                                  device, the termination time will"nbe set automatically when outbid.
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "user": "str",  # Optional.
                                "userdata": "str",  # Optional.
                                "volumes": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            },
                            "facility": {
                                "address": {
                                    "address": "str",  # Required.
                                    "address2": "str",  # Optional.
                                    "city": "str",  # Optional.
                                    "coordinates": {
                                        "latitude": "str",  # Optional.
                                        "longitude": "str"  # Optional.
                                    },
                                    "country": "str",  # Required.
                                    "state": "str",  # Optional.
                                    "zip_code": "str"  # Required.
                                },
                                "code": "str",  # Optional.
                                "features": [
                                    "str"  # Optional.
                                ],
                                "id": "str",  # Optional.
                                "ip_ranges": [
                                    "str"  # Optional. IP ranges registered in
                                      facility. Can be used for GeoIP location.
                                ],
                                "metro": {
                                    "code": "str",  # Optional.
                                    "country": "str",  # Optional.
                                    "id": "str",  # Optional.
                                    "name": "str"  # Optional.
                                },
                                "name": "str"  # Optional.
                            },
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "need_of_service": bool,  # Optional. Whether this Device
                              requires assistance from Metal Equinix.
                            "plan": {
                                "available_in": [
                                    {
                                        "href": "str",  # Optional. href to
                                          the Facility.
                                        "price": {
                                            "hour": 0.0  # Optional.
                                              Shows which facilities the plan is available in, and the
                                              facility-based price if it is different from the default
                                              price.
                                        }
                                    }
                                ],
                                "available_in_metros": [
                                    {
                                        "href": "str",  # Optional. href to
                                          the Metro.
                                        "price": {
                                            "hour": 0.0  # Optional.
                                              Shows which metros the plan is available in, and the
                                              metro-based price if it is different from the default
                                              price.
                                        }
                                    }
                                ],
                                "class": "str",  # Optional.
                                "deployment_types": [
                                    "str"  # Optional.
                                ],
                                "description": "str",  # Optional.
                                "id": "str",  # Optional.
                                "legacy": bool,  # Optional.
                                "line": "str",  # Optional. "baremetal"
                                "name": "str",  # Optional.
                                "pricing": {},  # Optional. Any object.
                                "slug": "str",  # Optional.
                                "specs": {
                                    "cpus": [
                                        {
                                            "count": 0,  # Optional.
                                            "type": "str"  # Optional.
                                        }
                                    ],
                                    "drives": [
                                        {
                                            "category": "str",  #
                                              Optional. Known values are: "boot", "cache", and
                                              "storage".
                                            "count": 0,  # Optional.
                                            "size": "str",  # Optional.
                                            "type": "str"  # Optional.
                                              Known values are: "HDD", "SSD", and "NVME".
                                        }
                                    ],
                                    "features": {
                                        "raid": bool,  # Optional.
                                        "txt": bool,  # Optional.
                                        "uefi": bool  # Optional.
                                    },
                                    "nics": [
                                        {
                                            "count": 0,  # Optional.
                                            "type": "str"  # Optional.
                                              Known values are: "1Gbps", "10Gbps", and "25Gbps".
                                        }
                                    ]
                                },
                                "type": "str"  # Optional. The plan type. Known
                                  values are: "standard", "workload_optimized", and "custom".
                            },
                            "project": {
                                "bgp_config": {
                                    "href": "str"  # Required.
                                },
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "devices": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "id": "str",  # Optional.
                                "invitations": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "max_devices": {},  # Optional. Any object.
                                "members": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "memberships": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "name": "str",  # Optional.
                                "network_status": {},  # Optional. Any object.
                                "payment_method": {
                                    "href": "str"  # Required.
                                },
                                "ssh_keys": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "volumes": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            },
                            "provisionable": bool,  # Optional. Whether the reserved
                              server is provisionable or not. Spare devices can't be provisioned unless
                              they are activated first.
                            "short_id": "str",  # Optional. Short version of the ID.
                            "spare": bool,  # Optional. Whether the Hardware Reservation
                              is a spare. Spare Hardware Reservations are used when a Hardware
                              Reservations requires service from Metal Equinix.
                            "switch_uuid": "str"  # Optional. Switch short id. This can
                              be used to determine if two devices are connected to the same switch, for
                              example.
                        }
                    ],
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_hardware_reservations_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ip_reservations(
        self,
        id: str,
        *,
        types: Optional[List[str]] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        per_page: int = 250,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all ip reservations.

        Provides a paginated list of IP reservations for a single project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword types: Filter project IP reservations by reservation type. Default value is None.
        :paramtype types: list[str]
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword per_page: Items returned per page. Default value is 250.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ip_addresses": [
                        {}
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_ip_reservations_request(
            id=id,
            types=types,
            include=include,
            exclude=exclude,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def request_ip_reservation(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Requesting IP reservations.

        Request more IP space for a project in order to have additional IP addresses to assign to
        devices.  If the request is within the max quota, an IP reservation will be created. If the
        project will exceed its IP quota, a request will be submitted for review, and will return an IP
        Reservation with a ``state`` of ``pending``. You can automatically have the request fail with
        HTTP status 422 instead of triggering the review process by providing the
        ``fail_on_approval_required`` parameter set to ``true`` in the request.

        :param id: Project UUID. Required.
        :type id: str
        :param body: IP Reservation Request to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def request_ip_reservation(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Requesting IP reservations.

        Request more IP space for a project in order to have additional IP addresses to assign to
        devices.  If the request is within the max quota, an IP reservation will be created. If the
        project will exceed its IP quota, a request will be submitted for review, and will return an IP
        Reservation with a ``state`` of ``pending``. You can automatically have the request fail with
        HTTP status 422 instead of triggering the review process by providing the
        ``fail_on_approval_required`` parameter set to ``true`` in the request.

        :param id: Project UUID. Required.
        :type id: str
        :param body: IP Reservation Request to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def request_ip_reservation(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Requesting IP reservations.

        Request more IP space for a project in order to have additional IP addresses to assign to
        devices.  If the request is within the max quota, an IP reservation will be created. If the
        project will exceed its IP quota, a request will be submitted for review, and will return an IP
        Reservation with a ``state`` of ``pending``. You can automatically have the request fail with
        HTTP status 422 instead of triggering the review process by providing the
        ``fail_on_approval_required`` parameter set to ``true`` in the request.

        :param id: Project UUID. Required.
        :type id: str
        :param body: IP Reservation Request to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_request_ip_reservation_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_licenses(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all licenses.

        Provides a collection of licenses for a given project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "licenses": [
                        {
                            "description": "str",  # Optional.
                            "id": "str",  # Optional.
                            "license_key": "str",  # Optional.
                            "licensee_product": {
                                "href": "str"  # Required.
                            },
                            "project": {
                                "href": "str"  # Required.
                            },
                            "size": 0.0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_licenses_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_license(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a License.

        Creates a new license for the given project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: License to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "licensee_product_id": "str",  # Optional.
                    "size": 0.0  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_license(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a License.

        Creates a new license for the given project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: License to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_license(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a License.

        Creates a new license for the given project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: License to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "description": "str",  # Optional.
                    "id": "str",  # Optional.
                    "license_key": "str",  # Optional.
                    "licensee_product": {
                        "href": "str"  # Required.
                    },
                    "project": {
                        "href": "str"  # Required.
                    },
                    "size": 0.0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_license_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_plans_by_project(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all plans visible by the project.

        Returns a listing of available plans for the given project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "plans": [
                        {
                            "available_in": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Facility.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          facilities the plan is available in, and the facility-based
                                          price if it is different from the default price.
                                    }
                                }
                            ],
                            "available_in_metros": [
                                {
                                    "href": "str",  # Optional. href to the
                                      Metro.
                                    "price": {
                                        "hour": 0.0  # Optional. Shows which
                                          metros the plan is available in, and the metro-based price if
                                          it is different from the default price.
                                    }
                                }
                            ],
                            "class": "str",  # Optional.
                            "deployment_types": [
                                "str"  # Optional.
                            ],
                            "description": "str",  # Optional.
                            "id": "str",  # Optional.
                            "legacy": bool,  # Optional.
                            "line": "str",  # Optional. "baremetal"
                            "name": "str",  # Optional.
                            "pricing": {},  # Optional. Any object.
                            "slug": "str",  # Optional.
                            "specs": {
                                "cpus": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional.
                                    }
                                ],
                                "drives": [
                                    {
                                        "category": "str",  # Optional. Known
                                          values are: "boot", "cache", and "storage".
                                        "count": 0,  # Optional.
                                        "size": "str",  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "HDD", "SSD", and "NVME".
                                    }
                                ],
                                "features": {
                                    "raid": bool,  # Optional.
                                    "txt": bool,  # Optional.
                                    "uefi": bool  # Optional.
                                },
                                "nics": [
                                    {
                                        "count": 0,  # Optional.
                                        "type": "str"  # Optional. Known
                                          values are: "1Gbps", "10Gbps", and "25Gbps".
                                    }
                                ]
                            },
                            "type": "str"  # Optional. The plan type. Known values are:
                              "standard", "workload_optimized", and "custom".
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_plans_by_project_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def list_spot_market_requests(self, id: str, **kwargs: Any) -> JSON:
        """List spot market requests.

        View all spot market requests for a given project.

        :param id: Project UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "spot_market_requests": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "devices_max": 0,  # Optional.
                            "devices_min": 0,  # Optional.
                            "end_at": "2020-02-20 00:00:00",  # Optional.
                            "facilities": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "instances": {
                                "href": "str"  # Required.
                            },
                            "max_bid_price": 0.0,  # Optional.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "project": {
                                "href": "str"  # Required.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_list_spot_market_requests_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_spot_market_request(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a spot market request.

        Creates a new spot market request.

        Type-specific options (such as operating_system for baremetal devices) should be included in
        the main data structure alongside hostname and plan.

        The features attribute allows you to optionally specify what features your server should have.
        For example, if you require a server with a TPM chip, you may specify ``{ "features": { "tpm":
        "required" } }`` (or ``{ "features": ["tpm"] }`` in shorthand).

        The request will fail if there are no available servers matching your criteria. Alternatively,
        if you do not require a certain feature, but would prefer to be assigned a server with that
        feature if there are any available, you may specify that feature with a preferred value (see
        the example request below).

        The request will not fail if we have no servers with that feature in our inventory.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Spot Market Request to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "devices_max": 0,  # Optional.
                    "devices_min": 0,  # Optional.
                    "end_at": "2020-02-20 00:00:00",  # Optional.
                    "facilities": [
                        "str"  # Optional.
                    ],
                    "instance_attributes": {
                        "always_pxe": bool,  # Optional.
                        "billing_cycle": "str",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "description": "str",  # Optional.
                        "features": [
                            "str"  # Optional.
                        ],
                        "hostname": "str",  # Optional.
                        "hostnames": [
                            "str"  # Optional.
                        ],
                        "locked": bool,  # Optional.
                        "no_ssh_keys": bool,  # Optional.
                        "operating_system": "str",  # Optional.
                        "plan": "str",  # Optional.
                        "private_ipv4_subnet_size": 0,  # Optional.
                        "project_ssh_keys": [
                            "str"  # Optional.
                        ],
                        "public_ipv4_subnet_size": 0,  # Optional.
                        "tags": [
                            "str"  # Optional.
                        ],
                        "termination_time": "2020-02-20 00:00:00",  # Optional.
                        "user_ssh_keys": [
                            "str"  # Optional. The UUIDs of users whose SSH keys should
                              be included on the provisioned device.
                        ],
                        "userdata": "str"  # Optional.
                    },
                    "max_bid_price": 0.0,  # Optional.
                    "metro": "str"  # Optional. The metro ID or code the spot market request will
                      be created in.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "devices_max": 0,  # Optional.
                    "devices_min": 0,  # Optional.
                    "end_at": "2020-02-20 00:00:00",  # Optional.
                    "facilities": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": {
                        "href": "str"  # Required.
                    },
                    "max_bid_price": 0.0,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "project": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_spot_market_request(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a spot market request.

        Creates a new spot market request.

        Type-specific options (such as operating_system for baremetal devices) should be included in
        the main data structure alongside hostname and plan.

        The features attribute allows you to optionally specify what features your server should have.
        For example, if you require a server with a TPM chip, you may specify ``{ "features": { "tpm":
        "required" } }`` (or ``{ "features": ["tpm"] }`` in shorthand).

        The request will fail if there are no available servers matching your criteria. Alternatively,
        if you do not require a certain feature, but would prefer to be assigned a server with that
        feature if there are any available, you may specify that feature with a preferred value (see
        the example request below).

        The request will not fail if we have no servers with that feature in our inventory.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Spot Market Request to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "devices_max": 0,  # Optional.
                    "devices_min": 0,  # Optional.
                    "end_at": "2020-02-20 00:00:00",  # Optional.
                    "facilities": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": {
                        "href": "str"  # Required.
                    },
                    "max_bid_price": 0.0,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "project": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_spot_market_request(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a spot market request.

        Creates a new spot market request.

        Type-specific options (such as operating_system for baremetal devices) should be included in
        the main data structure alongside hostname and plan.

        The features attribute allows you to optionally specify what features your server should have.
        For example, if you require a server with a TPM chip, you may specify ``{ "features": { "tpm":
        "required" } }`` (or ``{ "features": ["tpm"] }`` in shorthand).

        The request will fail if there are no available servers matching your criteria. Alternatively,
        if you do not require a certain feature, but would prefer to be assigned a server with that
        feature if there are any available, you may specify that feature with a preferred value (see
        the example request below).

        The request will not fail if we have no servers with that feature in our inventory.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Spot Market Request to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "devices_max": 0,  # Optional.
                    "devices_min": 0,  # Optional.
                    "end_at": "2020-02-20 00:00:00",  # Optional.
                    "facilities": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": {
                        "href": "str"  # Required.
                    },
                    "max_bid_price": 0.0,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "project": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_spot_market_request_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_ssh_keys(
        self,
        id: str,
        *,
        search_string: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a project's ssh keys.

        Returns a collection of the project's ssh keys.

        :param id: Project UUID. Required.
        :type id: str
        :keyword search_string: Search by key, label, or fingerprint. Default value is None.
        :paramtype search_string: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ssh_keys": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "entity": {
                                "href": "str"  # Required.
                            },
                            "fingerprint": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "key": "str",  # Optional.
                            "label": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_ssh_keys_request(
            id=id,
            search_string=search_string,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_project_ssh_key(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a ssh key for the given project.

        Creates a ssh key.

        :param id: Project UUID. Required.
        :type id: str
        :param body: ssh key to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "instances_ids": [
                        "str"  # Optional. List of instance UUIDs to associate SSH key with,
                          when empty array is sent all instances belonging"n      to entity will be
                          included.
                    ],
                    "key": "str",  # Optional.
                    "label": "str"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_project_ssh_key(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a ssh key for the given project.

        Creates a ssh key.

        :param id: Project UUID. Required.
        :type id: str
        :param body: ssh key to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_project_ssh_key(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a ssh key for the given project.

        Creates a ssh key.

        :param id: Project UUID. Required.
        :type id: str
        :param body: ssh key to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_project_ssh_key_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_transfer_request(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a transfer request.

        Organization owners can transfer their projects to other organizations.

        :param id: UUID of the project to be transferred. Required.
        :type id: str
        :param body: Transfer Request to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "target_organization_id": "str"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "target_organization": {
                        "href": "str"  # Required.
                    },
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_transfer_request(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a transfer request.

        Organization owners can transfer their projects to other organizations.

        :param id: UUID of the project to be transferred. Required.
        :type id: str
        :param body: Transfer Request to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "target_organization": {
                        "href": "str"  # Required.
                    },
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_transfer_request(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a transfer request.

        Organization owners can transfer their projects to other organizations.

        :param id: UUID of the project to be transferred. Required.
        :type id: str
        :param body: Transfer Request to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "target_organization": {
                        "href": "str"  # Required.
                    },
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_transfer_request_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_usage(
        self,
        id: str,
        *,
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all usages for project.

        Returns all usages for a project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword created_after: Filter usages created after this date. Default value is None.
        :paramtype created_after: str
        :keyword created_before: Filter usages created before this date. Default value is None.
        :paramtype created_before: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "usages": [
                        {
                            "facility": "str",  # Optional.
                            "name": "str",  # Optional.
                            "plan": "str",  # Optional.
                            "plan_version": "str",  # Optional.
                            "price": "str",  # Optional.
                            "quantity": "str",  # Optional.
                            "total": "str",  # Optional.
                            "type": "str",  # Optional.
                            "unit": "str"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_usage_request(
            id=id,
            created_after=created_after,
            created_before=created_before,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_virtual_networks(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        facility: Optional[str] = None,
        metro: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all virtual networks.

        Provides a list of virtual networks for a single project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword facility: Filter by Facility ID (uuid) or Facility Code. Default value is None.
        :paramtype facility: str
        :keyword metro: Filter by Metro ID (uuid) or Metro Code. Default value is None.
        :paramtype metro: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "virtual_networks": [
                        {
                            "assigned_to": {
                                "href": "str"  # Required.
                            },
                            "assigned_to_virtual_circuit": bool,  # Optional. True if the
                              virtual network is attached to a virtual circuit. False if not.
                            "description": "str",  # Optional.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "instances": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "metal_gateways": [
                                {
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "gateway_address": "str",  # Optional. The
                                      gateway address with subnet CIDR value for this Metal Gateway.
                                      For example, a Metal Gateway using an IP reservation with block
                                      10.1.2.0/27 would have a gateway address of 10.1.2.1/27.
                                    "href": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "id": "str",  # Optional. A list of metal
                                      gateways currently associated to this Virtual Network.
                                    "state": "str",  # Optional. The current
                                      state of the Metal Gateway. 'Ready' indicates the gateway record
                                      has been configured, but is currently not active on the network.
                                      'Active' indicates the gateway has been configured on the
                                      network. 'Deleting' is a temporary state used to indicate that
                                      the gateway is in the process of being un-configured from the
                                      network, after which the gateway record will be deleted. Known
                                      values are: "ready", "active", and "deleting".
                                    "updated_at": "2020-02-20 00:00:00",  #
                                      Optional. A list of metal gateways currently associated to this
                                      Virtual Network.
                                    "vlan": 0  # Optional. The VLAN id of the
                                      Virtual Network record associated to this Metal Gateway.
                                }
                            ],
                            "metro": {
                                "href": "str"  # Required.
                            },
                            "metro_code": "str",  # Optional. The Metro code of the metro
                              in which this Virtual Network is defined.
                            "vxlan": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_virtual_networks_request(
            id=id,
            include=include,
            exclude=exclude,
            facility=facility,
            metro=metro,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_virtual_network(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a virtual network.

        Creates an virtual network.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Virtual Network to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "facility": "str",  # Optional. The UUID (or facility code) for the Facility
                      in which to create this Virtual network.
                    "metro": "str",  # Optional. The UUID (or metro code) for the Metro in which
                      to create this Virtual Network.
                    "vxlan": 0  # Optional. VLAN ID between 2-3999. Must be unique for the
                      project within the Metro in which this Virtual Network is being created. If no
                      value is specified, the next-available VLAN ID in the range 1000-1999 will be
                      automatically selected.
                }

                # response body for status code(s): 201
                response == {
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual network
                      is attached to a virtual circuit. False if not.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "metal_gateways": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "gateway_address": "str",  # Optional. The gateway address
                              with subnet CIDR value for this Metal Gateway. For example, a Metal
                              Gateway using an IP reservation with block 10.1.2.0/27 would have a
                              gateway address of 10.1.2.1/27.
                            "href": "str",  # Optional. A list of metal gateways
                              currently associated to this Virtual Network.
                            "id": "str",  # Optional. A list of metal gateways currently
                              associated to this Virtual Network.
                            "state": "str",  # Optional. The current state of the Metal
                              Gateway. 'Ready' indicates the gateway record has been configured, but is
                              currently not active on the network. 'Active' indicates the gateway has
                              been configured on the network. 'Deleting' is a temporary state used to
                              indicate that the gateway is in the process of being un-configured from
                              the network, after which the gateway record will be deleted. Known values
                              are: "ready", "active", and "deleting".
                            "updated_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "vlan": 0  # Optional. The VLAN id of the Virtual Network
                              record associated to this Metal Gateway.
                        }
                    ],
                    "metro": {
                        "href": "str"  # Required.
                    },
                    "metro_code": "str",  # Optional. The Metro code of the metro in which this
                      Virtual Network is defined.
                    "vxlan": 0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_virtual_network(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a virtual network.

        Creates an virtual network.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Virtual Network to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual network
                      is attached to a virtual circuit. False if not.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "metal_gateways": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "gateway_address": "str",  # Optional. The gateway address
                              with subnet CIDR value for this Metal Gateway. For example, a Metal
                              Gateway using an IP reservation with block 10.1.2.0/27 would have a
                              gateway address of 10.1.2.1/27.
                            "href": "str",  # Optional. A list of metal gateways
                              currently associated to this Virtual Network.
                            "id": "str",  # Optional. A list of metal gateways currently
                              associated to this Virtual Network.
                            "state": "str",  # Optional. The current state of the Metal
                              Gateway. 'Ready' indicates the gateway record has been configured, but is
                              currently not active on the network. 'Active' indicates the gateway has
                              been configured on the network. 'Deleting' is a temporary state used to
                              indicate that the gateway is in the process of being un-configured from
                              the network, after which the gateway record will be deleted. Known values
                              are: "ready", "active", and "deleting".
                            "updated_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "vlan": 0  # Optional. The VLAN id of the Virtual Network
                              record associated to this Metal Gateway.
                        }
                    ],
                    "metro": {
                        "href": "str"  # Required.
                    },
                    "metro_code": "str",  # Optional. The Metro code of the metro in which this
                      Virtual Network is defined.
                    "vxlan": 0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_virtual_network(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a virtual network.

        Creates an virtual network.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Virtual Network to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual network
                      is attached to a virtual circuit. False if not.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "metal_gateways": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "gateway_address": "str",  # Optional. The gateway address
                              with subnet CIDR value for this Metal Gateway. For example, a Metal
                              Gateway using an IP reservation with block 10.1.2.0/27 would have a
                              gateway address of 10.1.2.1/27.
                            "href": "str",  # Optional. A list of metal gateways
                              currently associated to this Virtual Network.
                            "id": "str",  # Optional. A list of metal gateways currently
                              associated to this Virtual Network.
                            "state": "str",  # Optional. The current state of the Metal
                              Gateway. 'Ready' indicates the gateway record has been configured, but is
                              currently not active on the network. 'Active' indicates the gateway has
                              been configured on the network. 'Deleting' is a temporary state used to
                              indicate that the gateway is in the process of being un-configured from
                              the network, after which the gateway record will be deleted. Known values
                              are: "ready", "active", and "deleting".
                            "updated_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "vlan": 0  # Optional. The VLAN id of the Virtual Network
                              record associated to this Metal Gateway.
                        }
                    ],
                    "metro": {
                        "href": "str"  # Required.
                    },
                    "metro_code": "str",  # Optional. The Metro code of the metro in which this
                      Virtual Network is defined.
                    "vxlan": 0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_virtual_network_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_vrfs(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        metro: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all VRFs in the project.

        Returns the list of VRFs for a single project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword metro: Filter by Metro ID (uuid) or Metro Code. Default value is None.
        :paramtype metro: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "vrfs": [
                        {
                            "created_by": {
                                "avatar_thumb_url": "str",  # Optional.
                                "avatar_url": "str",  # Optional.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "email": "str",  # Optional.
                                "emails": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "first_name": "str",  # Optional.
                                "fraud_score": "str",  # Optional.
                                "full_name": "str",  # Optional.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "last_login_at": "2020-02-20 00:00:00",  # Optional.
                                "last_name": "str",  # Optional.
                                "max_organizations": 0,  # Optional.
                                "max_projects": 0,  # Optional.
                                "phone_number": "str",  # Optional.
                                "short_id": "str",  # Optional.
                                "timezone": "str",  # Optional.
                                "two_factor_auth": "str",  # Optional.
                                "updated_at": "2020-02-20 00:00:00"  # Optional.
                            },
                            "description": "str",  # Optional. Optional field that can be
                              set to describe the VRF.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "ip_ranges": [
                                "str"  # Optional. A list of CIDR network addresses.
                                  Like ["10.0.0.0/16", "2001:d78::/56"].
                            ],
                            "local_asn": 0,  # Optional. A 4-byte ASN associated with the
                              VRF.
                            "metro": {
                                "code": "str",  # Optional.
                                "country": "str",  # Optional.
                                "id": "str",  # Optional.
                                "name": "str"  # Optional.
                            },
                            "name": "str",  # Optional.
                            "project": {
                                "bgp_config": {
                                    "href": "str"  # Required.
                                },
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "devices": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "id": "str",  # Optional.
                                "invitations": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "max_devices": {},  # Optional. Any object.
                                "members": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "memberships": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "name": "str",  # Optional.
                                "network_status": {},  # Optional. Any object.
                                "payment_method": {
                                    "href": "str"  # Required.
                                },
                                "ssh_keys": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "volumes": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            }
                        }
                    ]
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_vrfs_request(
            id=id,
            include=include,
            exclude=exclude,
            metro=metro,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_vrf(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a new VRF in the specified project.

        Creates a new VRF in the specified project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: VRF to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"]. IPv4 blocks must be between /8 and /29 in
                          size. IPv6 blocks must be between /56 and /64. A VRF""'s IP ranges must be
                          defined in order to create VRF IP Reservations, which can then be used for
                          Metal Gateways or Virtual Circuits.
                    ],
                    "local_asn": 0,  # Optional.
                    "metro": "str",  # The UUID (or metro code) for the Metro in which to create
                      this VRF. Required.
                    "name": "str"  # Required.
                }

                # response body for status code(s): 201
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_vrf(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a new VRF in the specified project.

        Creates a new VRF in the specified project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: VRF to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_vrf(self, id: str, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create a new VRF in the specified project.

        Creates a new VRF in the specified project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: VRF to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_vrf_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def project_list_interconnections(
        self, project_id: str, **kwargs: Any
    ) -> JSON:
        """List project connections.

        List the connections belonging to the project.

        :param project_id: UUID of the project. Required.
        :type project_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "interconnections": [
                        {
                            "contact_email": "str",  # Optional.
                            "description": "str",  # Optional.
                            "facility": {
                                "href": "str"  # Required.
                            },
                            "id": "str",  # Optional.
                            "metro": {
                                "code": "str",  # Optional. The location of where the
                                  shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                                "country": "str",  # Optional. The location of where
                                  the shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                                "id": "str",  # Optional. The location of where the
                                  shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                                "name": "str"  # Optional. The location of where the
                                  shared or Dedicated Port is located. For interconnections with
                                  Dedicated Ports,"n  this will be the location of the Dedicated Ports.
                                  For Fabric VCs (Metal Billed), this is where interconnection will be
                                  originating from, as we pre-authorize the use of one of our shared
                                  ports"n  as the origin of the interconnection using A-Side service
                                  tokens. We only allow local connections for Fabric VCs (Metal
                                  Billed), so the destination location must be the same as the origin.
                                  For Fabric VCs (Fabric Billed), "n  this will be the destination of
                                  the interconnection. We allow remote connections for Fabric VCs
                                  (Fabric Billed), so the origin of the interconnection can be a
                                  different metro set here.
                            },
                            "mode": "str",  # Optional. The mode of the interconnection
                              (only relevant to Dedicated Ports). Shared connections won't have this
                              field. Can be either 'standard' or 'tunnel'."n  The default mode of an
                              interconnection on a Dedicated Port is 'standard'. The mode can only be
                              changed when there are no associated virtual circuits on the
                              interconnection."n  In tunnel mode, an 802.1q tunnel is added to a port
                              to send/receive double tagged packets from server instances. Known values
                              are: "standard" and "tunnel".
                            "name": "str",  # Optional.
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "ports": [
                                {
                                    "id": "str",  # Optional. For Fabric VCs,
                                      these represent Virtual Port(s) created for the interconnection.
                                      For dedicated interconnections, these represent the Dedicated
                                      Port(s).
                                    "organization": {
                                        "href": "str"  # Required.
                                    },
                                    "role": "str",  # Optional. Either 'primary'
                                      or 'secondary'. Known values are: "primary" and "secondary".
                                    "status": "str",  # Optional. For both Fabric
                                      VCs and Dedicated Ports, this will be 'requested' on creation and
                                      'deleting' on deletion. Once the Fabric VC has found its
                                      corresponding Fabric connection, this will turn to 'active'. For
                                      Dedicated Ports, once the dedicated port is associated, this will
                                      also turn to 'active'. For Fabric VCs, this can turn into an
                                      'expired' state if the service token associated is expired. Known
                                      values are: "requested", "active", "deleting", and "expired".
                                    "switch_id": "str",  # Optional. A switch
                                      'short ID'.
                                    "virtual_circuits": {
                                        "virtual_circuits": [
                                            {}
                                        ]
                                    }
                                }
                            ],
                            "redundancy": "str",  # Optional. Either 'primary', meaning a
                              single interconnection, or 'redundant', meaning a redundant
                              interconnection. Known values are: "primary" and "redundant".
                            "service_tokens": [
                                {
                                    "expires_at": "2020-02-20 00:00:00",  #
                                      Optional. The expiration date and time of the Fabric service
                                      token. Once a service token is expired, it is no longer
                                      redeemable.
                                    "id": "str",  # Optional. The UUID that can
                                      be used on the Fabric Portal to redeem either an A-Side or Z-Side
                                      Service Token."nFor Fabric VCs (Metal Billed), this UUID will
                                      represent an A-Side Service Token, which will allow
                                      interconnections"nto be made from Equinix Metal to other Service
                                      Providers on Fabric. For Fabric VCs (Fabric Billed), this UUID
                                      will"nrepresent a Z-Side Service Token, which will allow
                                      interconnections to be made to connect an owned Fabric Port or
                                      "nVirtual Device to Equinix Metal.
                                    "max_allowed_speed": 0,  # Optional. The
                                      maximum speed that can be selected on the Fabric Portal when
                                      configuring a interconnection with either "nan A-Side or Z-Side
                                      Service Token. For Fabric VCs (Metal Billed), this is what the
                                      billing is based off of, and can be one"nof the following
                                      options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                                      '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will
                                      default to 10Gbps.
                                    "role": "str",  # Optional. Either primary or
                                      secondary, depending on which interconnection the service token
                                      is associated to. Known values are: "primary" and "secondary".
                                    "service_token_type": "str",  # Optional.
                                      Either 'a_side' or 'z_side', depending on which type of Fabric VC
                                      was requested. Known values are: "a_side" and "z_side".
                                    "state": "str"  # Optional. The state of the
                                      service token that corresponds with the service"ntoken state on
                                      Fabric. An 'inactive' state refers to a token that has not
                                      been"nredeemed yet on the Fabric side, an 'active' state refers
                                      to a token that has"nalready been redeemed, and an 'expired'
                                      state refers to a token that has reached"nits expiry time. Known
                                      values are: "inactive", "active", and "expired".
                                }
                            ],
                            "speed": 0,  # Optional. For interconnections on Dedicated
                              Ports and shared connections, this represents the interconnection's speed
                              in bps. For Fabric VCs, this field refers to the maximum speed of the
                              interconnection in bps. This value will default to 10Gbps for Fabric VCs
                              (Fabric Billed).
                            "status": "str",  # Optional.
                            "tags": [
                                "str"  # Optional.
                            ],
                            "token": "str",  # Optional. This token is used for shared
                              interconnections to be used as the Fabric Token. This field is entirely
                              deprecated.
                            "type": "str"  # Optional. The 'shared' type of
                              interconnection refers to shared connections, or later also known as
                              Fabric Virtual Connections (or Fabric VCs). The 'dedicated' type of
                              interconnection refers to interconnections created with Dedicated Ports.
                              Known values are: "shared" and "dedicated".
                        }
                    ]
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_project_list_interconnections_request(
            project_id=project_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_project_interconnection(
        self,
        project_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Request a new interconnection for the project's organization.

        Creates a new interconnection request.

        :param project_id: UUID of the project. Required.
        :type project_id: str
        :param body: Interconnection details. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "metro": "str",  # A Metro ID or code. For interconnections with Dedicated
                      Ports, this will be the location of the issued Dedicated Ports. When creating
                      Fabric VCs (Metal Billed), this is where interconnection will be originating
                      from, as we pre-authorize the use of one of our shared ports as the origin of the
                      interconnection using A-Side service tokens. We only allow local connections for
                      Fabric VCs (Metal Billed), so the destination location must be the same as the
                      origin. For Fabric VCs (Fabric Billed), or shared connections, this will be the
                      destination of the interconnection. We allow remote connections for Fabric VCs
                      (Fabric Billed), so the origin of the interconnection can be a different metro
                      set here. Required.
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Fabric VCs won't have this field. Can be either 'standard' or
                      'tunnel'."n  The default mode of an interconnection on a Dedicated Port is
                      'standard'. The mode can only be changed when there are no associated virtual
                      circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is added to
                      a port to send/receive double tagged packets from server instances. Known values
                      are: "standard" and "tunnel".
                    "name": "str",  # Required.
                    "project": "str",  # Optional.
                    "redundancy": "str",  # Either 'primary' or 'redundant'. Required.
                    "service_token_type": "str",  # Optional. Either 'a_side' or 'z_side'.
                      Setting this field to 'a_side' will create an interconnection with Fabric VCs
                      (Metal Billed). Setting this field to 'z_side' will create an interconnection
                      with Fabric VCs (Fabric Billed). This is required when the 'type' is 'shared',
                      but this is not applicable when the 'type' is 'dedicated'. This parameter is
                      included in the specification as a developer preview and is generally
                      unavailable. Please contact our Support team for more details. Known values are:
                      "a_side" and "z_side".
                    "speed": 0,  # Optional. A interconnection speed, in bps, mbps, or gbps. For
                      Dedicated Ports, this can be 10Gbps or 100Gbps."nFor Fabric VCs, this represents
                      the maximum speed of the interconnection. For Fabric VCs (Metal Billed), this can
                      only be one of the following: "n''50mbps'', ''200mbps'', ''500mbps'', ''1gbps'',
                      ''2gbps'', ''5gbps'' or ''10gbps'', and is required for creation. For Fabric VCs
                      (Fabric Billed), this field will always default to ''10gbps'' even if it is not
                      provided."nFor example, ''500000000'', ''50m'', or' ''500mbps'' will all work as
                      valid inputs.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "type": "str",  # Either 'shared' or 'dedicated'. The 'shared' type
                      represents shared interconnections, or also known as Fabric VCs. The 'dedicated'
                      type represents dedicated interconnections, or also known as Dedicated Ports.
                      Required.
                    "vlans": [
                        0  # Optional. A list of one or two metro-based VLANs that will be
                          set on the virtual circuits of primary and/or secondary (if redundant)
                          interconnections respectively when creating Fabric VCs. VLANs can also be set
                          after the interconnection is created, but are required to fully activate the
                          interconnection. This parameter is included in the specification as a
                          developer preview and is generally unavailable. Please contact our Support
                          team for more details.
                    ]
                }

                # response body for status code(s): 201
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_project_interconnection(
        self,
        project_id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Request a new interconnection for the project's organization.

        Creates a new interconnection request.

        :param project_id: UUID of the project. Required.
        :type project_id: str
        :param body: Interconnection details. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_project_interconnection(
        self, project_id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Request a new interconnection for the project's organization.

        Creates a new interconnection request.

        :param project_id: UUID of the project. Required.
        :type project_id: str
        :param body: Interconnection details. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "contact_email": "str",  # Optional.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "id": "str",  # Optional.
                    "metro": {
                        "code": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "country": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "id": "str",  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                        "name": "str"  # Optional. The location of where the shared or
                          Dedicated Port is located. For interconnections with Dedicated Ports,"n  this
                          will be the location of the Dedicated Ports. For Fabric VCs (Metal Billed),
                          this is where interconnection will be originating from, as we pre-authorize
                          the use of one of our shared ports"n  as the origin of the interconnection
                          using A-Side service tokens. We only allow local connections for Fabric VCs
                          (Metal Billed), so the destination location must be the same as the origin.
                          For Fabric VCs (Fabric Billed), "n  this will be the destination of the
                          interconnection. We allow remote connections for Fabric VCs (Fabric Billed),
                          so the origin of the interconnection can be a different metro set here.
                    },
                    "mode": "str",  # Optional. The mode of the interconnection (only relevant to
                      Dedicated Ports). Shared connections won't have this field. Can be either
                      'standard' or 'tunnel'."n  The default mode of an interconnection on a Dedicated
                      Port is 'standard'. The mode can only be changed when there are no associated
                      virtual circuits on the interconnection."n  In tunnel mode, an 802.1q tunnel is
                      added to a port to send/receive double tagged packets from server instances.
                      Known values are: "standard" and "tunnel".
                    "name": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "ports": [
                        {
                            "id": "str",  # Optional. For Fabric VCs, these represent
                              Virtual Port(s) created for the interconnection. For dedicated
                              interconnections, these represent the Dedicated Port(s).
                            "organization": {
                                "href": "str"  # Required.
                            },
                            "role": "str",  # Optional. Either 'primary' or 'secondary'.
                              Known values are: "primary" and "secondary".
                            "status": "str",  # Optional. For both Fabric VCs and
                              Dedicated Ports, this will be 'requested' on creation and 'deleting' on
                              deletion. Once the Fabric VC has found its corresponding Fabric
                              connection, this will turn to 'active'. For Dedicated Ports, once the
                              dedicated port is associated, this will also turn to 'active'. For Fabric
                              VCs, this can turn into an 'expired' state if the service token
                              associated is expired. Known values are: "requested", "active",
                              "deleting", and "expired".
                            "switch_id": "str",  # Optional. A switch 'short ID'.
                            "virtual_circuits": {
                                "virtual_circuits": [
                                    {}
                                ]
                            }
                        }
                    ],
                    "redundancy": "str",  # Optional. Either 'primary', meaning a single
                      interconnection, or 'redundant', meaning a redundant interconnection. Known
                      values are: "primary" and "redundant".
                    "service_tokens": [
                        {
                            "expires_at": "2020-02-20 00:00:00",  # Optional. The
                              expiration date and time of the Fabric service token. Once a service
                              token is expired, it is no longer redeemable.
                            "id": "str",  # Optional. The UUID that can be used on the
                              Fabric Portal to redeem either an A-Side or Z-Side Service Token."nFor
                              Fabric VCs (Metal Billed), this UUID will represent an A-Side Service
                              Token, which will allow interconnections"nto be made from Equinix Metal
                              to other Service Providers on Fabric. For Fabric VCs (Fabric Billed),
                              this UUID will"nrepresent a Z-Side Service Token, which will allow
                              interconnections to be made to connect an owned Fabric Port or "nVirtual
                              Device to Equinix Metal.
                            "max_allowed_speed": 0,  # Optional. The maximum speed that
                              can be selected on the Fabric Portal when configuring a interconnection
                              with either "nan A-Side or Z-Side Service Token. For Fabric VCs (Metal
                              Billed), this is what the billing is based off of, and can be one"nof the
                              following options, '50mbps', '200mbps', '500mbps', '1gbps', '2gbps',
                              '5gbps' or '10gbps'. For Fabric VCs"n(Fabric Billed), this will default
                              to 10Gbps.
                            "role": "str",  # Optional. Either primary or secondary,
                              depending on which interconnection the service token is associated to.
                              Known values are: "primary" and "secondary".
                            "service_token_type": "str",  # Optional. Either 'a_side' or
                              'z_side', depending on which type of Fabric VC was requested. Known
                              values are: "a_side" and "z_side".
                            "state": "str"  # Optional. The state of the service token
                              that corresponds with the service"ntoken state on Fabric. An 'inactive'
                              state refers to a token that has not been"nredeemed yet on the Fabric
                              side, an 'active' state refers to a token that has"nalready been
                              redeemed, and an 'expired' state refers to a token that has reached"nits
                              expiry time. Known values are: "inactive", "active", and "expired".
                        }
                    ],
                    "speed": 0,  # Optional. For interconnections on Dedicated Ports and shared
                      connections, this represents the interconnection's speed in bps. For Fabric VCs,
                      this field refers to the maximum speed of the interconnection in bps. This value
                      will default to 10Gbps for Fabric VCs (Fabric Billed).
                    "status": "str",  # Optional.
                    "tags": [
                        "str"  # Optional.
                    ],
                    "token": "str",  # Optional. This token is used for shared interconnections
                      to be used as the Fabric Token. This field is entirely deprecated.
                    "type": "str"  # Optional. The 'shared' type of interconnection refers to
                      shared connections, or later also known as Fabric Virtual Connections (or Fabric
                      VCs). The 'dedicated' type of interconnection refers to interconnections created
                      with Dedicated Ports. Known values are: "shared" and "dedicated".
                }
                # response body for status code(s): 403, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_project_interconnection_request(
            project_id=project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 403, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_project_invitations(
        self,
        project_id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve project invitations.

        Returns all invitations in a project.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "invitations": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "roles": [
                                "str"  # Optional.
                            ],
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": {
                                "href": "str"  # Required.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_invitations_request(
            project_id=project_id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_project_invitation(
        self,
        project_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an invitation for a project.

        In order to add a user to a project, they must first be invited.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: Invitation to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "invitee": "str",  # Required.
                    "message": "str",  # Optional.
                    "organization_id": "str",  # Optional.
                    "projects_ids": [
                        "str"  # Optional.
                    ],
                    "roles": [
                        "str"  # Optional.
                    ]
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_project_invitation(
        self,
        project_id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create an invitation for a project.

        In order to add a user to a project, they must first be invited.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: Invitation to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_project_invitation(
        self, project_id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create an invitation for a project.

        In order to add a user to a project, they must first be invited.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: Invitation to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "invitation": {
                        "href": "str"  # Required.
                    },
                    "invited_by": {
                        "href": "str"  # Required.
                    },
                    "invitee": "str",  # Optional.
                    "nonce": "str",  # Optional.
                    "organization": {
                        "href": "str"  # Required.
                    },
                    "projects": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "roles": [
                        "str"  # Optional.
                    ],
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_project_invitation_request(
            project_id=project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ip_reservation_customdata(
        self, project_id: str, id: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Retrieve the custom metadata of an IP Reservation.

        Provides the custom metadata stored for this IP Reservation in json format.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param id: Ip Reservation UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_ip_reservation_customdata_request(
            project_id=project_id,
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_project_memberships(
        self,
        project_id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve project memberships.

        Returns all memberships in a project.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "memberships": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "project": {
                                "href": "str"  # Required.
                            },
                            "roles": [
                                "str"  # Optional.
                            ],
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": {
                                "href": "str"  # Required.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_project_memberships_request(
            project_id=project_id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_metal_gateways_by_project(
        self, project_id: str, *, page: int = 1, per_page: int = 10, **kwargs: Any
    ) -> JSON:
        """Returns all metal gateways for a project.

        Return all metal gateways for a project.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "metal_gateways": [
                        {}
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_metal_gateways_by_project_request(
            project_id=project_id,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_metal_gateway(
        self,
        project_id: str,
        body: JSON,
        *,
        page: int = 1,
        per_page: int = 10,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a metal gateway.

        Create a metal gateway in a project.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: Metal Gateway to create. Required.
        :type body: JSON
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_metal_gateway(
        self,
        project_id: str,
        body: IO,
        *,
        page: int = 1,
        per_page: int = 10,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a metal gateway.

        Create a metal gateway in a project.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: Metal Gateway to create. Required.
        :type body: IO
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_metal_gateway(
        self,
        project_id: str,
        body: Union[JSON, IO],
        *,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Create a metal gateway.

        Create a metal gateway in a project.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: Metal Gateway to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_metal_gateway_request(
            project_id=project_id,
            page=page,
            per_page=per_page,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_self_service_reservations(
        self, project_id: str, *, page: int = 1, per_page: int = 10, **kwargs: Any
    ) -> JSON:
        """Retrieve all reservations.

        Returns all reservations.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reservations": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "item": [
                                {
                                    "amount": 0.0,  # Optional.
                                    "id": "str",  # Optional.
                                    "metro_code": "str",  # Optional.
                                    "metro_id": "str",  # Optional.
                                    "metro_name": "str",  # Optional.
                                    "plan_id": "str",  # Optional.
                                    "plan_name": "str",  # Optional.
                                    "plan_slug": "str",  # Optional.
                                    "quantity": 0,  # Optional.
                                    "term": "str"  # Optional.
                                }
                            ],
                            "notes": "str",  # Optional.
                            "organization": "str",  # Optional.
                            "organization_id": "str",  # Optional.
                            "period": {
                                "count": 0.0,  # Optional. Known values are: 12 and
                                  36.
                                "unit": "str"  # Optional. "monthly"
                            },
                            "project": "str",  # Optional.
                            "project_id": "str",  # Optional.
                            "start_date": "2020-02-20 00:00:00",  # Optional.
                            "status": "str",  # Optional.
                            "total_cost": 0  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_self_service_reservations_request(
            project_id=project_id,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_self_service_reservation(
        self,
        project_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a reservation.

        Creates a reservation.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: reservation to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "item": [
                        {
                            "amount": 0.0,  # Optional.
                            "metro_id": "str",  # Optional.
                            "plan_id": "str",  # Optional.
                            "quantity": 0,  # Optional.
                            "term": "str"  # Optional.
                        }
                    ],
                    "notes": "str",  # Optional.
                    "period": {
                        "count": 0.0,  # Optional. Known values are: 12 and 36.
                        "unit": "str"  # Optional. "monthly"
                    },
                    "start_date": "2020-02-20 00:00:00"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "item": [
                        {
                            "amount": 0.0,  # Optional.
                            "id": "str",  # Optional.
                            "metro_code": "str",  # Optional.
                            "metro_id": "str",  # Optional.
                            "metro_name": "str",  # Optional.
                            "plan_id": "str",  # Optional.
                            "plan_name": "str",  # Optional.
                            "plan_slug": "str",  # Optional.
                            "quantity": 0,  # Optional.
                            "term": "str"  # Optional.
                        }
                    ],
                    "notes": "str",  # Optional.
                    "organization": "str",  # Optional.
                    "organization_id": "str",  # Optional.
                    "period": {
                        "count": 0.0,  # Optional. Known values are: 12 and 36.
                        "unit": "str"  # Optional. "monthly"
                    },
                    "project": "str",  # Optional.
                    "project_id": "str",  # Optional.
                    "start_date": "2020-02-20 00:00:00",  # Optional.
                    "status": "str",  # Optional.
                    "total_cost": 0  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_self_service_reservation(
        self,
        project_id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Create a reservation.

        Creates a reservation.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: reservation to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "item": [
                        {
                            "amount": 0.0,  # Optional.
                            "id": "str",  # Optional.
                            "metro_code": "str",  # Optional.
                            "metro_id": "str",  # Optional.
                            "metro_name": "str",  # Optional.
                            "plan_id": "str",  # Optional.
                            "plan_name": "str",  # Optional.
                            "plan_slug": "str",  # Optional.
                            "quantity": 0,  # Optional.
                            "term": "str"  # Optional.
                        }
                    ],
                    "notes": "str",  # Optional.
                    "organization": "str",  # Optional.
                    "organization_id": "str",  # Optional.
                    "period": {
                        "count": 0.0,  # Optional. Known values are: 12 and 36.
                        "unit": "str"  # Optional. "monthly"
                    },
                    "project": "str",  # Optional.
                    "project_id": "str",  # Optional.
                    "start_date": "2020-02-20 00:00:00",  # Optional.
                    "status": "str",  # Optional.
                    "total_cost": 0  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_self_service_reservation(
        self, project_id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a reservation.

        Creates a reservation.

        :param project_id: Project UUID. Required.
        :type project_id: str
        :param body: reservation to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "item": [
                        {
                            "amount": 0.0,  # Optional.
                            "id": "str",  # Optional.
                            "metro_code": "str",  # Optional.
                            "metro_id": "str",  # Optional.
                            "metro_name": "str",  # Optional.
                            "plan_id": "str",  # Optional.
                            "plan_name": "str",  # Optional.
                            "plan_slug": "str",  # Optional.
                            "quantity": 0,  # Optional.
                            "term": "str"  # Optional.
                        }
                    ],
                    "notes": "str",  # Optional.
                    "organization": "str",  # Optional.
                    "organization_id": "str",  # Optional.
                    "period": {
                        "count": 0.0,  # Optional. Known values are: 12 and 36.
                        "unit": "str"  # Optional. "monthly"
                    },
                    "project": "str",  # Optional.
                    "project_id": "str",  # Optional.
                    "start_date": "2020-02-20 00:00:00",  # Optional.
                    "status": "str",  # Optional.
                    "total_cost": 0  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_self_service_reservation_request(
            project_id=project_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_self_service_reservation(
        self, id: str, project_id: str, **kwargs: Any
    ) -> JSON:
        """Retrieve a reservation.

        Returns a reservation.

        :param id: Reservation short_id. Required.
        :type id: str
        :param project_id: Project UUID. Required.
        :type project_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "item": [
                        {
                            "amount": 0.0,  # Optional.
                            "id": "str",  # Optional.
                            "metro_code": "str",  # Optional.
                            "metro_id": "str",  # Optional.
                            "metro_name": "str",  # Optional.
                            "plan_id": "str",  # Optional.
                            "plan_name": "str",  # Optional.
                            "plan_slug": "str",  # Optional.
                            "quantity": 0,  # Optional.
                            "term": "str"  # Optional.
                        }
                    ],
                    "notes": "str",  # Optional.
                    "organization": "str",  # Optional.
                    "organization_id": "str",  # Optional.
                    "period": {
                        "count": 0.0,  # Optional. Known values are: 12 and 36.
                        "unit": "str"  # Optional. "monthly"
                    },
                    "project": "str",  # Optional.
                    "project_id": "str",  # Optional.
                    "start_date": "2020-02-20 00:00:00",  # Optional.
                    "status": "str",  # Optional.
                    "total_cost": 0  # Optional.
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_self_service_reservation_request(
            id=id,
            project_id=project_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def reset_password(self, **kwargs: Any) -> JSON:
        """Reset current user password.

        Resets current user password.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "new_password": "str"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_reset_password_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def create_password_reset_token(
        self, *, email: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Create a password reset token.

        Creates a password reset token.

        :keyword email: Email of user to create password reset token. Required.
        :paramtype email: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_create_password_reset_token_request(
            email=email,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def delete_spot_market_request(
        self, id: str, *, force_termination: Optional[bool] = None, **kwargs: Any
    ) -> Optional[JSON]:
        """Delete the spot market request.

        Deletes the spot market request.

        :param id: SpotMarketRequest UUID. Required.
        :type id: str
        :keyword force_termination: Terminate associated spot instances. Default value is None.
        :paramtype force_termination: bool
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_spot_market_request_request(
            id=id,
            force_termination=force_termination,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_spot_market_request_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a spot market request.

        Returns a single spot market request.

        :param id: SpotMarketRequest UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "devices_max": 0,  # Optional.
                    "devices_min": 0,  # Optional.
                    "end_at": "2020-02-20 00:00:00",  # Optional.
                    "facilities": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": {
                        "href": "str"  # Required.
                    },
                    "max_bid_price": 0.0,  # Optional.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "project": {
                        "href": "str"  # Required.
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_spot_market_request_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_ssh_keys(
        self,
        *,
        search_string: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all ssh keys.

        Returns a collection of the users ssh keys.

        :keyword search_string: Search by key, label, or fingerprint. Default value is None.
        :paramtype search_string: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ssh_keys": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "entity": {
                                "href": "str"  # Required.
                            },
                            "fingerprint": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "key": "str",  # Optional.
                            "label": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_ssh_keys_request(
            search_string=search_string,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_ssh_key(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a ssh key for the current user.

        Creates a ssh key.

        :param body: ssh key to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "instances_ids": [
                        "str"  # Optional. List of instance UUIDs to associate SSH key with,
                          when empty array is sent all instances belonging"n      to entity will be
                          included.
                    ],
                    "key": "str",  # Optional.
                    "label": "str"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_ssh_key(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a ssh key for the current user.

        Creates a ssh key.

        :param body: ssh key to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_ssh_key(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create a ssh key for the current user.

        Creates a ssh key.

        :param body: ssh key to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_ssh_key_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_ssh_key(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the ssh key.

        Deletes the ssh key.

        :param id: ssh key UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_ssh_key_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_ssh_key_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a ssh key.

        Returns a single ssh key if the user has access.

        :param id: SSH Key UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_ssh_key_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_ssh_key(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the ssh key.

        Updates the ssh key.

        :param id: SSH Key UUID. Required.
        :type id: str
        :param body: ssh key to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "key": "str",  # Optional.
                    "label": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_ssh_key(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the ssh key.

        Updates the ssh key.

        :param id: SSH Key UUID. Required.
        :type id: str
        :param body: ssh key to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_ssh_key(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update the ssh key.

        Updates the ssh key.

        :param id: SSH Key UUID. Required.
        :type id: str
        :param body: ssh key to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "entity": {
                        "href": "str"  # Required.
                    },
                    "fingerprint": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "key": "str",  # Optional.
                    "label": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_ssh_key_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def request_suppert(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[JSON]:
        """Create a support ticket.

        Support Ticket.

        :param body: Support Request to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "device_id": "str",  # Optional.
                    "message": "str",  # Required.
                    "priority": "str",  # Optional. Known values are: "urgent", "high", "medium",
                      and "low".
                    "project_id": "str",  # Optional.
                    "subject": "str"  # Required.
                }

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def request_suppert(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[JSON]:
        """Create a support ticket.

        Support Ticket.

        :param body: Support Request to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def request_suppert(
        self, body: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        """Create a support ticket.

        Support Ticket.

        :param body: Support Request to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_request_suppert_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def decline_transfer_request(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Decline a transfer request.

        Decline a transfer request.

        :param id: Transfer request UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_decline_transfer_request_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_transfer_request_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """View a transfer request.

        Returns a single transfer request.

        :param id: Transfer request UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "project": {
                        "href": "str"  # Required.
                    },
                    "target_organization": {
                        "href": "str"  # Required.
                    },
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_transfer_request_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def accept_transfer_request(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Accept a transfer request.

        Accept a transfer request.

        :param id: Transfer request UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_accept_transfer_request_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_current_user(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve the current user.

        Returns the user object for the currently logged-in user.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_current_user_request(
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_current_user(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Update the current user.

        Updates the currently logged-in user.

        :param body: User to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "customdata": {},  # Optional. Any object.
                    "first_name": "str",  # Optional.
                    "last_name": "str",  # Optional.
                    "password": "str",  # Optional.
                    "phone_number": "str",  # Optional.
                    "timezone": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_current_user(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Update the current user.

        Updates the currently logged-in user.

        :param body: User to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_current_user(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Update the current user.

        Updates the currently logged-in user.

        :param body: User to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_current_user_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_api_key(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an API key.

        Creates a API key for the current user.

        :param body: API key to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "read_only": bool  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "description": "str",  # Optional. Available only for API keys.
                    "id": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "read_only": bool,  # Optional.
                    "token": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_api_key(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an API key.

        Creates a API key for the current user.

        :param body: API key to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "description": "str",  # Optional. Available only for API keys.
                    "id": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "read_only": bool,  # Optional.
                    "token": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_api_key(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create an API key.

        Creates a API key for the current user.

        :param body: API key to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "description": "str",  # Optional. Available only for API keys.
                    "id": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    },
                    "read_only": bool,  # Optional.
                    "token": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00",  # Optional.
                    "user": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    }
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_api_key_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_api_keys(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all user API keys.

        Returns all API keys for the current user.

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "api_keys": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "description": "str",  # Optional. Available only for API
                              keys.
                            "id": "str",  # Optional.
                            "project": {
                                "bgp_config": {
                                    "href": "str"  # Required.
                                },
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "devices": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "id": "str",  # Optional.
                                "invitations": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "max_devices": {},  # Optional. Any object.
                                "members": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "memberships": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "name": "str",  # Optional.
                                "network_status": {},  # Optional. Any object.
                                "payment_method": {
                                    "href": "str"  # Required.
                                },
                                "ssh_keys": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "volumes": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            },
                            "read_only": bool,  # Optional.
                            "token": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00",  # Optional.
                            "user": {
                                "avatar_thumb_url": "str",  # Optional.
                                "avatar_url": "str",  # Optional.
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "email": "str",  # Optional.
                                "emails": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "first_name": "str",  # Optional.
                                "fraud_score": "str",  # Optional.
                                "full_name": "str",  # Optional.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "last_login_at": "2020-02-20 00:00:00",  # Optional.
                                "last_name": "str",  # Optional.
                                "max_organizations": 0,  # Optional.
                                "max_projects": 0,  # Optional.
                                "phone_number": "str",  # Optional.
                                "short_id": "str",  # Optional.
                                "timezone": "str",  # Optional.
                                "two_factor_auth": "str",  # Optional.
                                "updated_at": "2020-02-20 00:00:00"  # Optional.
                            }
                        }
                    ]
                }
                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_api_keys_request(
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_user_api_key(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the API key.

        Deletes the current user API key.

        :param id: API Key UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_user_api_key_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def disable_tfa_app(self, **kwargs: Any) -> Optional[JSON]:
        """Disable two factor authentication.

        Disables two factor authentication.

        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_disable_tfa_app_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def enable_tfa_app(self, **kwargs: Any) -> Optional[JSON]:
        """Enable two factor auth using app.

        Enables two factor authentication using authenticator app.

        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_enable_tfa_app_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_recovery_codes(self, **kwargs: Any) -> JSON:
        """Retrieve my recovery codes.

        Returns my recovery codes.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "recovery_codes": [
                        "str"  # Optional.
                    ]
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_recovery_codes_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def regenerate_codes(self, **kwargs: Any) -> JSON:
        """Generate new recovery codes.

        Generate a new set of recovery codes.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "recovery_codes": [
                        "str"  # Optional.
                    ]
                }
                # response body for status code(s): 401, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_regenerate_codes_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def disable_tfa_sms(self, **kwargs: Any) -> Optional[JSON]:
        """Disable two factor authentication.

        Disables two factor authentication.

        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_disable_tfa_sms_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def enable_tfa_sms(self, **kwargs: Any) -> Optional[JSON]:
        """Enable two factor auth using sms.

        Enables two factor authentication with sms.

        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_enable_tfa_sms_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def receive_codes(self, **kwargs: Any) -> Optional[JSON]:
        """Receive an OTP per sms.

        Sends an OTP to the user's mobile phone.

        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401, 422, 500
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_receive_codes_request(
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 422, 500]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 500:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_ensure_otp(self, otp: str, **kwargs: Any) -> Optional[JSON]:
        """Verify user by providing an OTP.

        It verifies the user once a valid OTP is provided. It gives back a session token, essentially
        logging in the user.

        :param otp: OTP. Required.
        :type otp: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 400, 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_ensure_otp_request(
            otp=otp,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 400:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def validate_userdata(
        self, *, userdata: Optional[str] = None, **kwargs: Any
    ) -> Optional[JSON]:
        """Validate user data.

        Validates user data (Userdata).

        :keyword userdata: Userdata to validate. Default value is None.
        :paramtype userdata: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_validate_userdata_request(
            userdata=userdata,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_users(
        self,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all users.

        Returns a list of users that the are accessible to the current user (all users in the current
        users projects, essentially).

        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "meta": {
                        "first": {
                            "href": "str"  # Required.
                        },
                        "last": {
                            "href": "str"  # Required.
                        },
                        "next": {
                            "href": "str"  # Required.
                        },
                        "previous": {
                            "href": "str"  # Required.
                        },
                        "self": {
                            "href": "str"  # Required.
                        },
                        "total": 0  # Optional.
                    },
                    "users": [
                        {
                            "avatar_thumb_url": "str",  # Optional.
                            "avatar_url": "str",  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "customdata": {},  # Optional. Any object.
                            "email": "str",  # Optional.
                            "emails": [
                                {
                                    "href": "str"  # Required.
                                }
                            ],
                            "first_name": "str",  # Optional.
                            "fraud_score": "str",  # Optional.
                            "full_name": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "last_login_at": "2020-02-20 00:00:00",  # Optional.
                            "last_name": "str",  # Optional.
                            "max_organizations": 0,  # Optional.
                            "max_projects": 0,  # Optional.
                            "phone_number": "str",  # Optional.
                            "short_id": "str",  # Optional.
                            "timezone": "str",  # Optional.
                            "two_factor_auth": "str",  # Optional.
                            "updated_at": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
                # response body for status code(s): 401
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_users_request(
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def create_user(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a user.

        Creates a user.

        :param body: User to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "avatar": b'bytes',  # Optional.
                    "company_name": "str",  # Optional.
                    "company_url": "str",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "emails": [
                        {
                            "address": "str",  # Required.
                            "default": bool  # Optional. Required.
                        }
                    ],
                    "first_name": "str",  # Required.
                    "invitation_id": "str",  # Optional.
                    "last_name": "str",  # Required.
                    "level": "str",  # Optional.
                    "locked": bool,  # Optional.
                    "nonce": "str",  # Optional.
                    "password": "str",  # Optional.
                    "phone_number": "str",  # Optional.
                    "social_accounts": {},  # Optional. Any object.
                    "timezone": "str",  # Optional.
                    "title": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "verified_at": "2020-02-20 00:00:00"  # Optional.
                }

                # response body for status code(s): 201
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def create_user(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a user.

        Creates a user.

        :param body: User to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def create_user(self, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create a user.

        Creates a user.

        :param body: User to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 201
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_create_user_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_user_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a user.

        Returns a single user if the user has access.

        :param id: User UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "avatar_thumb_url": "str",  # Optional.
                    "avatar_url": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "customdata": {},  # Optional. Any object.
                    "email": "str",  # Optional.
                    "emails": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "first_name": "str",  # Optional.
                    "fraud_score": "str",  # Optional.
                    "full_name": "str",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "last_login_at": "2020-02-20 00:00:00",  # Optional.
                    "last_name": "str",  # Optional.
                    "max_organizations": 0,  # Optional.
                    "max_projects": 0,  # Optional.
                    "phone_number": "str",  # Optional.
                    "short_id": "str",  # Optional.
                    "timezone": "str",  # Optional.
                    "two_factor_auth": "str",  # Optional.
                    "updated_at": "2020-02-20 00:00:00"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_user_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_user_customdata(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Retrieve the custom metadata of a user.

        Provides the custom metadata stored for this user in json format.

        :param id: User UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_find_user_customdata_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def create_validation_request(
        self, *, login: str, **kwargs: Any
    ) -> Optional[JSON]:
        """Create an email verification request.

        Creates an email verification request.

        :keyword login: Email for verification request. Required.
        :paramtype login: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_create_validation_request_request(
            login=login,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @overload
    async def consume_verification_request(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[JSON]:
        """Verify a user using an email verification token.

        Consumes an email verification token and verifies the user associated with it.

        :param body: Email to create. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "user_token": "str"  # User verification token. Required.
                }

                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def consume_verification_request(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[JSON]:
        """Verify a user using an email verification token.

        Consumes an email verification token and verifies the user associated with it.

        :param body: Email to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def consume_verification_request(
        self, body: Union[JSON, IO], **kwargs: Any
    ) -> Optional[JSON]:
        """Verify a user using an email verification token.

        Consumes an email verification token and verifies the user associated with it.

        :param body: Email to create. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_consume_verification_request_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_virtual_circuit_events(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> JSON:
        """Retrieve interconnection events.

        Returns a list of the virtual circuit events.

        :param id: Virtual Circuit UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :keyword page: Page to return. Default value is 1.
        :paramtype page: int
        :keyword per_page: Items returned per page. Default value is 10.
        :paramtype per_page: int
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "body": "str",  # Optional.
                    "created_at": "2020-02-20 00:00:00",  # Optional.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "interpolated": "str",  # Optional.
                    "relationships": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "state": "str",  # Optional.
                    "type": "str"  # Optional.
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_virtual_circuit_events_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_virtual_circuit(self, id: str, **kwargs: Any) -> JSON:
        """Delete a virtual circuit.

        Delete a virtual circuit from a Dedicated Port.

        :param id: Virtual Circuit UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_delete_virtual_circuit_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_virtual_circuit(self, id: str, **kwargs: Any) -> JSON:
        """Get a virtual circuit.

        Get the details of a virtual circuit.

        :param id: Virtual Circuit UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_virtual_circuit_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_virtual_circuit(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a virtual circuit.

        Update the details of a virtual circuit.

        :param id: Virtual Circuit UUID. Required.
        :type id: str
        :param body: Updated Virtual Circuit details. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {}

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_virtual_circuit(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update a virtual circuit.

        Update the details of a virtual circuit.

        :param id: Virtual Circuit UUID. Required.
        :type id: str
        :param body: Updated Virtual Circuit details. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_virtual_circuit(
        self, id: str, body: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Update a virtual circuit.

        Update the details of a virtual circuit.

        :param id: Virtual Circuit UUID. Required.
        :type id: str
        :param body: Updated Virtual Circuit details. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_virtual_circuit_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 202:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_virtual_network(self, id: str, **kwargs: Any) -> JSON:
        """Delete a virtual network.

        Deletes a virtual network.

        :param id: Virtual Network UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual network
                      is attached to a virtual circuit. False if not.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "metal_gateways": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "gateway_address": "str",  # Optional. The gateway address
                              with subnet CIDR value for this Metal Gateway. For example, a Metal
                              Gateway using an IP reservation with block 10.1.2.0/27 would have a
                              gateway address of 10.1.2.1/27.
                            "href": "str",  # Optional. A list of metal gateways
                              currently associated to this Virtual Network.
                            "id": "str",  # Optional. A list of metal gateways currently
                              associated to this Virtual Network.
                            "state": "str",  # Optional. The current state of the Metal
                              Gateway. 'Ready' indicates the gateway record has been configured, but is
                              currently not active on the network. 'Active' indicates the gateway has
                              been configured on the network. 'Deleting' is a temporary state used to
                              indicate that the gateway is in the process of being un-configured from
                              the network, after which the gateway record will be deleted. Known values
                              are: "ready", "active", and "deleting".
                            "updated_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "vlan": 0  # Optional. The VLAN id of the Virtual Network
                              record associated to this Metal Gateway.
                        }
                    ],
                    "metro": {
                        "href": "str"  # Required.
                    },
                    "metro_code": "str",  # Optional. The Metro code of the metro in which this
                      Virtual Network is defined.
                    "vxlan": 0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_delete_virtual_network_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def get_virtual_network(self, id: str, **kwargs: Any) -> JSON:
        """Get a virtual network.

        Get a virtual network.

        :param id: Virtual Network UUID. Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "assigned_to": {
                        "href": "str"  # Required.
                    },
                    "assigned_to_virtual_circuit": bool,  # Optional. True if the virtual network
                      is attached to a virtual circuit. False if not.
                    "description": "str",  # Optional.
                    "facility": {
                        "href": "str"  # Required.
                    },
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "instances": [
                        {
                            "href": "str"  # Required.
                        }
                    ],
                    "metal_gateways": [
                        {
                            "created_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "gateway_address": "str",  # Optional. The gateway address
                              with subnet CIDR value for this Metal Gateway. For example, a Metal
                              Gateway using an IP reservation with block 10.1.2.0/27 would have a
                              gateway address of 10.1.2.1/27.
                            "href": "str",  # Optional. A list of metal gateways
                              currently associated to this Virtual Network.
                            "id": "str",  # Optional. A list of metal gateways currently
                              associated to this Virtual Network.
                            "state": "str",  # Optional. The current state of the Metal
                              Gateway. 'Ready' indicates the gateway record has been configured, but is
                              currently not active on the network. 'Active' indicates the gateway has
                              been configured on the network. 'Deleting' is a temporary state used to
                              indicate that the gateway is in the process of being un-configured from
                              the network, after which the gateway record will be deleted. Known values
                              are: "ready", "active", and "deleting".
                            "updated_at": "2020-02-20 00:00:00",  # Optional. A list of
                              metal gateways currently associated to this Virtual Network.
                            "vlan": 0  # Optional. The VLAN id of the Virtual Network
                              record associated to this Metal Gateway.
                        }
                    ],
                    "metro": {
                        "href": "str"  # Required.
                    },
                    "metro_code": "str",  # Optional. The Metro code of the metro in which this
                      Virtual Network is defined.
                    "vxlan": 0  # Optional.
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_get_virtual_network_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def delete_vrf(self, id: str, **kwargs: Any) -> Optional[JSON]:
        """Delete the VRF.

        Deletes the VRF.

        :param id: VRF UUID. Required.
        :type id: str
        :return: JSON object or None
        :rtype: JSON or None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[JSON]]

        request = build_delete_vrf_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    @distributed_trace_async
    async def find_vrf_by_id(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve a VRF.

        Returns a single VRF resource.

        :param id: VRF UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 401, 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_vrf_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    async def update_vrf(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the VRF.

        Updates the VRF.

        :param id: VRF UUID. Required.
        :type id: str
        :param body: VRF to update. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "description": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"]. IPv4 blocks must be between /8 and /29 in
                          size. IPv6 blocks must be between /56 and /64. A VRF""'s IP ranges must be
                          defined in order to create VRF IP Reservations, which can then be used for
                          Metal Gateways or Virtual Circuits. Adding a new CIDR address to the list
                          will result in the creation of a new IP Range for this VRF. Removal of an
                          existing CIDR address from the list will result in the deletion of an
                          existing IP Range for this VRF. Deleting an IP Range will result in the
                          deletion of any VRF IP Reservations contained within the IP Range, as well as
                          the VRF IP Reservation""'s associated Metal Gateways or Virtual Circuits. If
                          you do not wish to add or remove IP Ranges, either include the full existing
                          list of IP Ranges in the update request, or do not specify the ``ip_ranges``
                          field in the update request. Specifying a value of ``[]`` will remove all
                          existing IP Ranges from the VRF.
                    ],
                    "local_asn": 0,  # Optional. The new ``local_asn`` value for the VRF. This
                      field cannot be updated when there are active Interconnection Virtual Circuits
                      associated to the VRF.
                    "name": "str"  # Optional.
                }

                # response body for status code(s): 200
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @overload
    async def update_vrf(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Update the VRF.

        Updates the VRF.

        :param id: VRF UUID. Required.
        :type id: str
        :param body: VRF to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """

    @distributed_trace_async
    async def update_vrf(self, id: str, body: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Update the VRF.

        Updates the VRF.

        :param id: VRF UUID. Required.
        :type id: str
        :param body: VRF to update. Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created_by": {
                        "avatar_thumb_url": "str",  # Optional.
                        "avatar_url": "str",  # Optional.
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "email": "str",  # Optional.
                        "emails": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "first_name": "str",  # Optional.
                        "fraud_score": "str",  # Optional.
                        "full_name": "str",  # Optional.
                        "href": "str",  # Optional.
                        "id": "str",  # Optional.
                        "last_login_at": "2020-02-20 00:00:00",  # Optional.
                        "last_name": "str",  # Optional.
                        "max_organizations": 0,  # Optional.
                        "max_projects": 0,  # Optional.
                        "phone_number": "str",  # Optional.
                        "short_id": "str",  # Optional.
                        "timezone": "str",  # Optional.
                        "two_factor_auth": "str",  # Optional.
                        "updated_at": "2020-02-20 00:00:00"  # Optional.
                    },
                    "description": "str",  # Optional. Optional field that can be set to describe
                      the VRF.
                    "href": "str",  # Optional.
                    "id": "str",  # Optional.
                    "ip_ranges": [
                        "str"  # Optional. A list of CIDR network addresses. Like
                          ["10.0.0.0/16", "2001:d78::/56"].
                    ],
                    "local_asn": 0,  # Optional. A 4-byte ASN associated with the VRF.
                    "metro": {
                        "code": "str",  # Optional.
                        "country": "str",  # Optional.
                        "id": "str",  # Optional.
                        "name": "str"  # Optional.
                    },
                    "name": "str",  # Optional.
                    "project": {
                        "bgp_config": {
                            "href": "str"  # Required.
                        },
                        "created_at": "2020-02-20 00:00:00",  # Optional.
                        "customdata": {},  # Optional. Any object.
                        "devices": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "id": "str",  # Optional.
                        "invitations": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "max_devices": {},  # Optional. Any object.
                        "members": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "memberships": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "name": "str",  # Optional.
                        "network_status": {},  # Optional. Any object.
                        "payment_method": {
                            "href": "str"  # Required.
                        },
                        "ssh_keys": [
                            {
                                "href": "str"  # Required.
                            }
                        ],
                        "updated_at": "2020-02-20 00:00:00",  # Optional.
                        "volumes": [
                            {
                                "href": "str"  # Required.
                            }
                        ]
                    }
                }
                # response body for status code(s): 401, 403, 404, 422
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_update_vrf_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 401:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 422:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace_async
    async def find_vrf_ip_reservations(
        self,
        id: str,
        *,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> JSON:
        """Retrieve all VRF IP Reservations in the VRF.

        Returns the list of VRF IP Reservations for the VRF.

        :param id: VRF UUID. Required.
        :type id: str
        :keyword include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply nested objects.
         Default value is None.
        :paramtype include: list[str]
        :keyword exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply nested objects.
         Default value is None.
        :paramtype exclude: list[str]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "ip_addresses": [
                        {
                            "address_family": 0,  # Optional.
                            "cidr": 0,  # Optional.
                            "created_at": "2020-02-20 00:00:00",  # Optional.
                            "created_by": {
                                "href": "str"  # Required.
                            },
                            "details": "str",  # Optional.
                            "href": "str",  # Optional.
                            "id": "str",  # Optional.
                            "metal_gateway": {
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "gateway_address": "str",  # Optional. The gateway
                                  address with subnet CIDR value for this Metal Gateway. For example, a
                                  Metal Gateway using an IP reservation with block 10.1.2.0/27 would
                                  have a gateway address of 10.1.2.1/27.
                                "href": "str",  # Optional.
                                "id": "str",  # Optional.
                                "state": "str",  # Optional. The current state of the
                                  Metal Gateway. 'Ready' indicates the gateway record has been
                                  configured, but is currently not active on the network. 'Active'
                                  indicates the gateway has been configured on the network. 'Deleting'
                                  is a temporary state used to indicate that the gateway is in the
                                  process of being un-configured from the network, after which the
                                  gateway record will be deleted. Known values are: "ready", "active",
                                  and "deleting".
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "vlan": 0  # Optional. The VLAN id of the Virtual
                                  Network record associated to this Metal Gateway.
                            },
                            "netmask": "str",  # Optional.
                            "network": "str",  # Optional.
                            "project": {
                                "bgp_config": {
                                    "href": "str"  # Required.
                                },
                                "created_at": "2020-02-20 00:00:00",  # Optional.
                                "customdata": {},  # Optional. Any object.
                                "devices": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "id": "str",  # Optional.
                                "invitations": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "max_devices": {},  # Optional. Any object.
                                "members": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "memberships": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "name": "str",  # Optional.
                                "network_status": {},  # Optional. Any object.
                                "payment_method": {
                                    "href": "str"  # Required.
                                },
                                "ssh_keys": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ],
                                "updated_at": "2020-02-20 00:00:00",  # Optional.
                                "volumes": [
                                    {
                                        "href": "str"  # Required.
                                    }
                                ]
                            },
                            "state": "str",  # Optional.
                            "tags": [
                                "str"  # Optional.
                            ],
                            "type": "str",  # Required. "vrf"
                            "vrf": {
                                "created_by": {
                                    "avatar_thumb_url": "str",  # Optional.
                                      Required.
                                    "avatar_url": "str",  # Optional. Required.
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. Required.
                                    "customdata": {},  # Optional. Any object.
                                    "email": "str",  # Optional. Required.
                                    "emails": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "first_name": "str",  # Optional. Required.
                                    "fraud_score": "str",  # Optional. Required.
                                    "full_name": "str",  # Optional. Required.
                                    "href": "str",  # Optional. Required.
                                    "id": "str",  # Optional. Required.
                                    "last_login_at": "2020-02-20 00:00:00",  #
                                      Optional. Required.
                                    "last_name": "str",  # Optional. Required.
                                    "max_organizations": 0,  # Optional.
                                      Required.
                                    "max_projects": 0,  # Optional. Required.
                                    "phone_number": "str",  # Optional. Required.
                                    "short_id": "str",  # Optional. Required.
                                    "timezone": "str",  # Optional. Required.
                                    "two_factor_auth": "str",  # Optional.
                                      Required.
                                    "updated_at": "2020-02-20 00:00:00"  #
                                      Optional. Required.
                                },
                                "description": "str",  # Optional. Optional field
                                  that can be set to describe the VRF.
                                "href": "str",  # Optional. Required.
                                "id": "str",  # Optional. Required.
                                "ip_ranges": [
                                    "str"  # Optional. A list of CIDR network
                                      addresses. Like ["10.0.0.0/16", "2001:d78::/56"].
                                ],
                                "local_asn": 0,  # Optional. A 4-byte ASN associated
                                  with the VRF.
                                "metro": {
                                    "code": "str",  # Optional. Required.
                                    "country": "str",  # Optional. Required.
                                    "id": "str",  # Optional. Required.
                                    "name": "str"  # Optional. Required.
                                },
                                "name": "str",  # Optional. Required.
                                "project": {
                                    "bgp_config": {
                                        "href": "str"  # Required.
                                    },
                                    "created_at": "2020-02-20 00:00:00",  #
                                      Optional. Required.
                                    "customdata": {},  # Optional. Any object.
                                    "devices": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "id": "str",  # Optional. Required.
                                    "invitations": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "max_devices": {},  # Optional. Any object.
                                    "members": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "memberships": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "name": "str",  # Optional. Required.
                                    "network_status": {},  # Optional. Any
                                      object.
                                    "payment_method": {
                                        "href": "str"  # Required.
                                    },
                                    "ssh_keys": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ],
                                    "updated_at": "2020-02-20 00:00:00",  #
                                      Optional. Required.
                                    "volumes": [
                                        {
                                            "href": "str"  # Required.
                                        }
                                    ]
                                }
                            }
                        }
                    ]
                }
                # response body for status code(s): 403, 404
                response == {
                    "error": "str",  # Optional. A description of the error that caused the
                      request to fail.
                    "errors": [
                        "str"  # Optional. A list of errors that contributed to the request
                          failing.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_find_vrf_ip_reservations_request(
            id=id,
            include=include,
            exclude=exclude,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 403:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 404:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

# coding=utf-8
# pylint: disable=too-many-lines
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.3, generator: @autorest/python@6.1.6)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import datetime
import sys
from typing import Any, Dict, IO, List, Optional, TYPE_CHECKING, Union

from .. import _serialization

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from .. import models as _models
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class Address(_serialization.Model):
    """Address.

    All required parameters must be populated in order to send to Azure.

    :ivar address: Required.
    :vartype address: str
    :ivar address2:
    :vartype address2: str
    :ivar city:
    :vartype city: str
    :ivar coordinates:
    :vartype coordinates: ~equinixmetalpy.models.Coordinates
    :ivar country: Required.
    :vartype country: str
    :ivar state:
    :vartype state: str
    :ivar zip_code: Required.
    :vartype zip_code: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "address": {"required": True},
        "country": {"required": True},
        "zip_code": {"required": True},
    }

    _attribute_map = {
        "address": {"key": "address", "type": "str"},
        "address2": {"key": "address2", "type": "str"},
        "city": {"key": "city", "type": "str"},
        "coordinates": {"key": "coordinates", "type": "Coordinates"},
        "country": {"key": "country", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "zip_code": {"key": "zip_code", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address: str,
        country: str,
        zip_code: str,
        address2: Optional[str] = None,
        city: Optional[str] = None,
        coordinates: Optional["_models.Coordinates"] = None,
        state: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address: Required.
        :paramtype address: str
        :keyword address2:
        :paramtype address2: str
        :keyword city:
        :paramtype city: str
        :keyword coordinates:
        :paramtype coordinates: ~equinixmetalpy.models.Coordinates
        :keyword country: Required.
        :paramtype country: str
        :keyword state:
        :paramtype state: str
        :keyword zip_code: Required.
        :paramtype zip_code: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.address = address
        self.address2 = address2
        self.city = city
        self.coordinates = coordinates
        self.country = country
        self.state = state
        self.zip_code = zip_code
        self.href = href


class BondPortData(_serialization.Model):
    """BondPortData.

    :ivar id: ID of the bonding port.
    :vartype id: str
    :ivar name: Name of the port interface for the bond ("bond0").
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword id: ID of the bonding port.
        :paramtype id: str
        :keyword name: Name of the port interface for the bond ("bond0").
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.id = id
        self.name = name
        self.href = href


class Coordinates(_serialization.Model):
    """Coordinates.

    :ivar latitude:
    :vartype latitude: str
    :ivar longitude:
    :vartype longitude: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "latitude": {"key": "latitude", "type": "str"},
        "longitude": {"key": "longitude", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        latitude: Optional[str] = None,
        longitude: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword latitude:
        :paramtype latitude: str
        :keyword longitude:
        :paramtype longitude: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.latitude = latitude
        self.longitude = longitude
        self.href = href


class CreateDeviceRequest(_serialization.Model):
    """CreateDeviceRequest."""

    _attribute_map = {}

    def __init__(self, **kwargs):
        """ """
        super().__init__(**kwargs)


class Device(_serialization.Model):  # pylint: disable=too-many-instance-attributes
    """Device.

    :ivar always_pxe:
    :vartype always_pxe: bool
    :ivar billing_cycle:
    :vartype billing_cycle: str
    :ivar bonding_mode:
    :vartype bonding_mode: int
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar created_by: The user that created the device.
    :vartype created_by: ~equinixmetalpy.models.DeviceCreatedBy
    :ivar customdata: Dictionary of :code:`<any>`.
    :vartype customdata: dict[str, any]
    :ivar description:
    :vartype description: str
    :ivar facility:
    :vartype facility: ~equinixmetalpy.models.Facility
    :ivar hardware_reservation:
    :vartype hardware_reservation: ~equinixmetalpy.models.Href
    :ivar hostname:
    :vartype hostname: str
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar image_url:
    :vartype image_url: str
    :ivar ip_addresses:
    :vartype ip_addresses: list[~equinixmetalpy.models.IPAssignment]
    :ivar ipxe_script_url:
    :vartype ipxe_script_url: str
    :ivar iqn:
    :vartype iqn: str
    :ivar locked:
    :vartype locked: bool
    :ivar metro: The metro the facility is in.
    :vartype metro: ~equinixmetalpy.models.DeviceMetro
    :ivar network_ports: By default, servers at Equinix Metal are configured in a “bonded” mode
     using LACP (Link Aggregation Control Protocol). Each 2-NIC server is configured with a single
     bond (namely bond0) with both interfaces eth0 and eth1 as members of the bond in a default
     Layer 3 mode. Some device plans may have a different number of ports and bonds available.
    :vartype network_ports: list[~equinixmetalpy.models.Port]
    :ivar operating_system:
    :vartype operating_system: ~equinixmetalpy.models.OperatingSystem
    :ivar actions: Actions supported by the device instance.
    :vartype actions: list[~equinixmetalpy.models.DeviceActionsInner]
    :ivar plan:
    :vartype plan: ~equinixmetalpy.models.Plan
    :ivar project: Full version of project object when included.
    :vartype project: ~equinixmetalpy.models.DeviceProject
    :ivar project_lite: Lite version of project object when included.
    :vartype project_lite: ~equinixmetalpy.models.DeviceProjectLite
    :ivar provisioning_events:
    :vartype provisioning_events: list[~equinixmetalpy.models.Event]
    :ivar provisioning_percentage: Only visible while device provisioning.
    :vartype provisioning_percentage: float
    :ivar root_password: Root password is automatically generated when server is provisioned and it
     is removed after 24 hours.
    :vartype root_password: str
    :ivar short_id:
    :vartype short_id: str
    :ivar spot_instance: Whether or not the device is a spot instance.
    :vartype spot_instance: bool
    :ivar spot_price_max: The maximum price per hour you are willing to pay to keep this spot
     instance.  If you are outbid, the termination will be set allowing two
     minutes before shutdown.
    :vartype spot_price_max: float
    :ivar ssh_keys:
    :vartype ssh_keys: list[~equinixmetalpy.models.Href]
    :ivar state: Known values are: "active", "deleted", "deprovisioning", "failed", "inactive",
     "queued", "reinstalling", "post_provisioning", "powering_on", "powering_off", and
     "provisioning".
    :vartype state: str or ~equinixmetalpy.models.DeviceState
    :ivar switch_uuid: Switch short id. This can be used to determine if two devices are
     connected to the same switch, for example.
    :vartype switch_uuid: str
    :ivar tags:
    :vartype tags: list[str]
    :ivar termination_time: When the device will be terminated. This is commonly set in advance for
     ephemeral spot market instances but this field may also be set with
     on-demand and reservation instances to automatically delete the resource
     at a given time. The termination time can also be used to release a
     hardware reservation instance at a given time, keeping the reservation
     open for other uses.  On a spot market device, the termination time will
     be set automatically when outbid.
    :vartype termination_time: ~datetime.datetime
    :ivar updated_at:
    :vartype updated_at: ~datetime.datetime
    :ivar user:
    :vartype user: str
    :ivar userdata:
    :vartype userdata: str
    :ivar volumes:
    :vartype volumes: list[~equinixmetalpy.models.Href]
    """

    _attribute_map = {
        "always_pxe": {"key": "always_pxe", "type": "bool"},
        "billing_cycle": {"key": "billing_cycle", "type": "str"},
        "bonding_mode": {"key": "bonding_mode", "type": "int"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "created_by": {"key": "created_by", "type": "DeviceCreatedBy"},
        "customdata": {"key": "customdata", "type": "{object}"},
        "description": {"key": "description", "type": "str"},
        "facility": {"key": "facility", "type": "Facility"},
        "hardware_reservation": {"key": "hardware_reservation", "type": "Href"},
        "hostname": {"key": "hostname", "type": "str"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "image_url": {"key": "image_url", "type": "str"},
        "ip_addresses": {"key": "ip_addresses", "type": "[IPAssignment]"},
        "ipxe_script_url": {"key": "ipxe_script_url", "type": "str"},
        "iqn": {"key": "iqn", "type": "str"},
        "locked": {"key": "locked", "type": "bool"},
        "metro": {"key": "metro", "type": "DeviceMetro"},
        "network_ports": {"key": "network_ports", "type": "[Port]"},
        "operating_system": {"key": "operating_system", "type": "OperatingSystem"},
        "actions": {"key": "actions", "type": "[DeviceActionsInner]"},
        "plan": {"key": "plan", "type": "Plan"},
        "project": {"key": "project", "type": "DeviceProject"},
        "project_lite": {"key": "project_lite", "type": "DeviceProjectLite"},
        "provisioning_events": {"key": "provisioning_events", "type": "[Event]"},
        "provisioning_percentage": {"key": "provisioning_percentage", "type": "float"},
        "root_password": {"key": "root_password", "type": "str"},
        "short_id": {"key": "short_id", "type": "str"},
        "spot_instance": {"key": "spot_instance", "type": "bool"},
        "spot_price_max": {"key": "spot_price_max", "type": "float"},
        "ssh_keys": {"key": "ssh_keys", "type": "[Href]"},
        "state": {"key": "state", "type": "str"},
        "switch_uuid": {"key": "switch_uuid", "type": "str"},
        "tags": {"key": "tags", "type": "[str]"},
        "termination_time": {"key": "termination_time", "type": "iso-8601"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
        "user": {"key": "user", "type": "str"},
        "userdata": {"key": "userdata", "type": "str"},
        "volumes": {"key": "volumes", "type": "[Href]"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        always_pxe: Optional[bool] = None,
        billing_cycle: Optional[str] = None,
        bonding_mode: Optional[int] = None,
        created_at: Optional[datetime.datetime] = None,
        created_by: Optional["_models.DeviceCreatedBy"] = None,
        customdata: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        facility: Optional["_models.Facility"] = None,
        hardware_reservation: Optional["_models.Href"] = None,
        hostname: Optional[str] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        image_url: Optional[str] = None,
        ip_addresses: Optional[List["_models.IPAssignment"]] = None,
        ipxe_script_url: Optional[str] = None,
        iqn: Optional[str] = None,
        locked: Optional[bool] = None,
        metro: Optional["_models.DeviceMetro"] = None,
        network_ports: Optional[List["_models.Port"]] = None,
        operating_system: Optional["_models.OperatingSystem"] = None,
        actions: Optional[List["_models.DeviceActionsInner"]] = None,
        plan: Optional["_models.Plan"] = None,
        project: Optional["_models.DeviceProject"] = None,
        project_lite: Optional["_models.DeviceProjectLite"] = None,
        provisioning_events: Optional[List["_models.Event"]] = None,
        provisioning_percentage: Optional[float] = None,
        root_password: Optional[str] = None,
        short_id: Optional[str] = None,
        spot_instance: Optional[bool] = None,
        spot_price_max: Optional[float] = None,
        ssh_keys: Optional[List["_models.Href"]] = None,
        state: Optional[Union[str, "_models.DeviceState"]] = None,
        switch_uuid: Optional[str] = None,
        tags: Optional[List[str]] = None,
        termination_time: Optional[datetime.datetime] = None,
        updated_at: Optional[datetime.datetime] = None,
        user: Optional[str] = None,
        userdata: Optional[str] = None,
        volumes: Optional[List["_models.Href"]] = None,
        **kwargs
    ):
        """
        :keyword always_pxe:
        :paramtype always_pxe: bool
        :keyword billing_cycle:
        :paramtype billing_cycle: str
        :keyword bonding_mode:
        :paramtype bonding_mode: int
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword created_by: The user that created the device.
        :paramtype created_by: ~equinixmetalpy.models.DeviceCreatedBy
        :keyword customdata: Dictionary of :code:`<any>`.
        :paramtype customdata: dict[str, any]
        :keyword description:
        :paramtype description: str
        :keyword facility:
        :paramtype facility: ~equinixmetalpy.models.Facility
        :keyword hardware_reservation:
        :paramtype hardware_reservation: ~equinixmetalpy.models.Href
        :keyword hostname:
        :paramtype hostname: str
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword image_url:
        :paramtype image_url: str
        :keyword ip_addresses:
        :paramtype ip_addresses: list[~equinixmetalpy.models.IPAssignment]
        :keyword ipxe_script_url:
        :paramtype ipxe_script_url: str
        :keyword iqn:
        :paramtype iqn: str
        :keyword locked:
        :paramtype locked: bool
        :keyword metro: The metro the facility is in.
        :paramtype metro: ~equinixmetalpy.models.DeviceMetro
        :keyword network_ports: By default, servers at Equinix Metal are configured in a “bonded” mode
         using LACP (Link Aggregation Control Protocol). Each 2-NIC server is configured with a single
         bond (namely bond0) with both interfaces eth0 and eth1 as members of the bond in a default
         Layer 3 mode. Some device plans may have a different number of ports and bonds available.
        :paramtype network_ports: list[~equinixmetalpy.models.Port]
        :keyword operating_system:
        :paramtype operating_system: ~equinixmetalpy.models.OperatingSystem
        :keyword actions: Actions supported by the device instance.
        :paramtype actions: list[~equinixmetalpy.models.DeviceActionsInner]
        :keyword plan:
        :paramtype plan: ~equinixmetalpy.models.Plan
        :keyword project: Full version of project object when included.
        :paramtype project: ~equinixmetalpy.models.DeviceProject
        :keyword project_lite: Lite version of project object when included.
        :paramtype project_lite: ~equinixmetalpy.models.DeviceProjectLite
        :keyword provisioning_events:
        :paramtype provisioning_events: list[~equinixmetalpy.models.Event]
        :keyword provisioning_percentage: Only visible while device provisioning.
        :paramtype provisioning_percentage: float
        :keyword root_password: Root password is automatically generated when server is provisioned and
         it is removed after 24 hours.
        :paramtype root_password: str
        :keyword short_id:
        :paramtype short_id: str
        :keyword spot_instance: Whether or not the device is a spot instance.
        :paramtype spot_instance: bool
        :keyword spot_price_max: The maximum price per hour you are willing to pay to keep this spot
         instance.  If you are outbid, the termination will be set allowing two
         minutes before shutdown.
        :paramtype spot_price_max: float
        :keyword ssh_keys:
        :paramtype ssh_keys: list[~equinixmetalpy.models.Href]
        :keyword state: Known values are: "active", "deleted", "deprovisioning", "failed", "inactive",
         "queued", "reinstalling", "post_provisioning", "powering_on", "powering_off", and
         "provisioning".
        :paramtype state: str or ~equinixmetalpy.models.DeviceState
        :keyword switch_uuid: Switch short id. This can be used to determine if two devices are
         connected to the same switch, for example.
        :paramtype switch_uuid: str
        :keyword tags:
        :paramtype tags: list[str]
        :keyword termination_time: When the device will be terminated. This is commonly set in advance
         for
         ephemeral spot market instances but this field may also be set with
         on-demand and reservation instances to automatically delete the resource
         at a given time. The termination time can also be used to release a
         hardware reservation instance at a given time, keeping the reservation
         open for other uses.  On a spot market device, the termination time will
         be set automatically when outbid.
        :paramtype termination_time: ~datetime.datetime
        :keyword updated_at:
        :paramtype updated_at: ~datetime.datetime
        :keyword user:
        :paramtype user: str
        :keyword userdata:
        :paramtype userdata: str
        :keyword volumes:
        :paramtype volumes: list[~equinixmetalpy.models.Href]
        """
        super().__init__(**kwargs)
        self.always_pxe = always_pxe
        self.billing_cycle = billing_cycle
        self.bonding_mode = bonding_mode
        self.created_at = created_at
        self.created_by = created_by
        self.customdata = customdata
        self.description = description
        self.facility = facility
        self.hardware_reservation = hardware_reservation
        self.hostname = hostname
        self.href = href
        self.id = id
        self.image_url = image_url
        self.ip_addresses = ip_addresses
        self.ipxe_script_url = ipxe_script_url
        self.iqn = iqn
        self.locked = locked
        self.metro = metro
        self.network_ports = network_ports
        self.operating_system = operating_system
        self.actions = actions
        self.plan = plan
        self.project = project
        self.project_lite = project_lite
        self.provisioning_events = provisioning_events
        self.provisioning_percentage = provisioning_percentage
        self.root_password = root_password
        self.short_id = short_id
        self.spot_instance = spot_instance
        self.spot_price_max = spot_price_max
        self.ssh_keys = ssh_keys
        self.state = state
        self.switch_uuid = switch_uuid
        self.tags = tags
        self.termination_time = termination_time
        self.updated_at = updated_at
        self.user = user
        self.userdata = userdata
        self.volumes = volumes


class DeviceActionsInner(_serialization.Model):
    """DeviceActionsInner.

    :ivar type:
    :vartype type: str
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "type": {"key": "type", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        type: Optional[str] = None,
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword type:
        :paramtype type: str
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.type = type
        self.name = name
        self.href = href


class UserLite(_serialization.Model):
    """UserLite.

    All required parameters must be populated in order to send to Azure.

    :ivar avatar_thumb_url: Avatar thumbnail URL of the User.
    :vartype avatar_thumb_url: str
    :ivar created_at: When the user was created.
    :vartype created_at: ~datetime.datetime
    :ivar email: Primary email address of the User.
    :vartype email: str
    :ivar first_name: First name of the User.
    :vartype first_name: str
    :ivar full_name: Full name of the User.
    :vartype full_name: str
    :ivar href: API URL uniquely representing the User.
    :vartype href: str
    :ivar id: ID of the User. Required.
    :vartype id: str
    :ivar last_name: Last name of the User.
    :vartype last_name: str
    :ivar short_id: Short ID of the User. Required.
    :vartype short_id: str
    :ivar updated_at: When the user details were last updated.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        "id": {"required": True},
        "short_id": {"required": True},
    }

    _attribute_map = {
        "avatar_thumb_url": {"key": "avatar_thumb_url", "type": "str"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "email": {"key": "email", "type": "str"},
        "first_name": {"key": "first_name", "type": "str"},
        "full_name": {"key": "full_name", "type": "str"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "last_name": {"key": "last_name", "type": "str"},
        "short_id": {"key": "short_id", "type": "str"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        short_id: str,
        avatar_thumb_url: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        email: Optional[str] = None,
        first_name: Optional[str] = None,
        full_name: Optional[str] = None,
        href: Optional[str] = None,
        last_name: Optional[str] = None,
        updated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword avatar_thumb_url: Avatar thumbnail URL of the User.
        :paramtype avatar_thumb_url: str
        :keyword created_at: When the user was created.
        :paramtype created_at: ~datetime.datetime
        :keyword email: Primary email address of the User.
        :paramtype email: str
        :keyword first_name: First name of the User.
        :paramtype first_name: str
        :keyword full_name: Full name of the User.
        :paramtype full_name: str
        :keyword href: API URL uniquely representing the User.
        :paramtype href: str
        :keyword id: ID of the User. Required.
        :paramtype id: str
        :keyword last_name: Last name of the User.
        :paramtype last_name: str
        :keyword short_id: Short ID of the User. Required.
        :paramtype short_id: str
        :keyword updated_at: When the user details were last updated.
        :paramtype updated_at: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.avatar_thumb_url = avatar_thumb_url
        self.created_at = created_at
        self.email = email
        self.first_name = first_name
        self.full_name = full_name
        self.href = href
        self.id = id
        self.last_name = last_name
        self.short_id = short_id
        self.updated_at = updated_at


class DeviceCreatedBy(UserLite):
    """The user that created the device.

    All required parameters must be populated in order to send to Azure.

    :ivar avatar_thumb_url: Avatar thumbnail URL of the User.
    :vartype avatar_thumb_url: str
    :ivar created_at: When the user was created.
    :vartype created_at: ~datetime.datetime
    :ivar email: Primary email address of the User.
    :vartype email: str
    :ivar first_name: First name of the User.
    :vartype first_name: str
    :ivar full_name: Full name of the User.
    :vartype full_name: str
    :ivar href: API URL uniquely representing the User.
    :vartype href: str
    :ivar id: ID of the User. Required.
    :vartype id: str
    :ivar last_name: Last name of the User.
    :vartype last_name: str
    :ivar short_id: Short ID of the User. Required.
    :vartype short_id: str
    :ivar updated_at: When the user details were last updated.
    :vartype updated_at: ~datetime.datetime
    """

    _validation = {
        "id": {"required": True},
        "short_id": {"required": True},
    }

    _attribute_map = {
        "avatar_thumb_url": {"key": "avatar_thumb_url", "type": "str"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "email": {"key": "email", "type": "str"},
        "first_name": {"key": "first_name", "type": "str"},
        "full_name": {"key": "full_name", "type": "str"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "last_name": {"key": "last_name", "type": "str"},
        "short_id": {"key": "short_id", "type": "str"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        short_id: str,
        avatar_thumb_url: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        email: Optional[str] = None,
        first_name: Optional[str] = None,
        full_name: Optional[str] = None,
        href: Optional[str] = None,
        last_name: Optional[str] = None,
        updated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword avatar_thumb_url: Avatar thumbnail URL of the User.
        :paramtype avatar_thumb_url: str
        :keyword created_at: When the user was created.
        :paramtype created_at: ~datetime.datetime
        :keyword email: Primary email address of the User.
        :paramtype email: str
        :keyword first_name: First name of the User.
        :paramtype first_name: str
        :keyword full_name: Full name of the User.
        :paramtype full_name: str
        :keyword href: API URL uniquely representing the User.
        :paramtype href: str
        :keyword id: ID of the User. Required.
        :paramtype id: str
        :keyword last_name: Last name of the User.
        :paramtype last_name: str
        :keyword short_id: Short ID of the User. Required.
        :paramtype short_id: str
        :keyword updated_at: When the user details were last updated.
        :paramtype updated_at: ~datetime.datetime
        """
        super().__init__(
            avatar_thumb_url=avatar_thumb_url,
            created_at=created_at,
            email=email,
            first_name=first_name,
            full_name=full_name,
            href=href,
            id=id,
            last_name=last_name,
            short_id=short_id,
            updated_at=updated_at,
            **kwargs
        )


class DeviceCreateInput(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """DeviceCreateInput.

    All required parameters must be populated in order to send to Azure.

    :ivar always_pxe: When true, devices with a ``custom_ipxe`` OS will always boot to iPXE. The
     default setting of false ensures that iPXE will be used on only the
     first boot.
    :vartype always_pxe: bool
    :ivar billing_cycle: The billing cycle of the device. Known values are: "hourly", "daily",
     "monthly", and "yearly".
    :vartype billing_cycle: str or ~equinixmetalpy.models.DeviceCreateInputBillingCycle
    :ivar customdata: Customdata is an arbitrary JSON value that can be accessed via the
     metadata service.
    :vartype customdata: dict[str, any]
    :ivar description: Any description of the device or how it will be used. This may be used
     to inform other API consumers with project access.
    :vartype description: str
    :ivar features: The features attribute allows you to optionally specify what features your
     server should have.

     In the API shorthand syntax, all features listed are ``required``\ :

     .. code-block::

        { "features": ["tpm"] }

     Alternatively, if you do not require a certain feature, but would prefer to be assigned a
     server with that feature if there are any available, you may specify that feature with a
     ``preferred`` value. The request will not fail if we have no servers with that feature in our
     inventory. The API offers an alternative syntax for mixing preferred and required features:

     .. code-block::

        { "features": { "tpm": "required", "raid": "preferred" } }

     The request will only fail if there are no available servers matching the required ``tpm``
     criteria.
    :vartype features: list[str]
    :ivar hardware_reservation_id: The Hardware Reservation UUID to provision. Alternatively,
     ``next-available`` can be specified to select from any of the available hardware reservations.
     An error will be returned if the requested reservation option is not available.

     See `Reserved Hardware <https://metal.equinix.com/developers/docs/deploy/reserved/>`_ for more
     details.
    :vartype hardware_reservation_id: str
    :ivar hostname: The hostname to use within the operating system. The same hostname may be used
     on multiple devices within a project.
    :vartype hostname: str
    :ivar ip_addresses: The `ip_addresses attribute will allow you to specify the addresses you
     want created with your device.

     The default value configures public IPv4, public IPv6, and private IPv4.

     Private IPv4 address is required. When specifying ``ip_addresses``\ , one of the array items
     must enable private IPv4.

     Some operating systems require public IPv4 address. In those cases you will receive an error
     message if public IPv4 is not enabled.

     For example, to only configure your server with a private IPv4 address, you can send ``{
     "ip_addresses": [{ "address_family": 4, "public": false }] }``.

     It is possible to request a subnet size larger than a ``/30`` by assigning addresses using the
     UUID(s) of ip_reservations in your project.

     For example, ``{ "ip_addresses": [..., {"address_family": 4, "public": true,
     "ip_reservations": ["uuid1", "uuid2"]}] }``

     To access a server without public IPs, you can use our Out-of-Band console access (SOS) or
     proxy through another server in the project with public IPs enabled.
    :vartype ip_addresses: list[~equinixmetalpy.models.DeviceCreateInputIpAddressesInner]
    :ivar ipxe_script_url: When set, the device will chainload an iPXE Script at boot fetched from
     the supplied URL.

     See `Custom iPXE <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/>`_
     for more details.
    :vartype ipxe_script_url: str
    :ivar locked: Whether the device should be locked, preventing accidental deletion.
    :vartype locked: bool
    :ivar no_ssh_keys: Overrides default behaviour of attaching all of the organization members ssh
     keys and project ssh keys to device if no specific keys specified.
    :vartype no_ssh_keys: bool
    :ivar operating_system: The slug of the operating system to provision. Check the Equinix Metal
     operating system documentation for rules that may be imposed per operating system, including
     restrictions on IP address options and device plans. Required.
    :vartype operating_system: str
    :ivar plan: The slug of the device plan to provision. Required.
    :vartype plan: str
    :ivar private_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
     allocated to this device.
    :vartype private_ipv4_subnet_size: int
    :ivar project_ssh_keys: A list of UUIDs identifying the device parent project
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.

     If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
     are all empty lists or omitted),
     all parent project keys, parent project members keys and organization members keys will be
     included. This behaviour can
     be changed with 'no_ssh_keys' option to omit any SSH key being added.
    :vartype project_ssh_keys: list[str]
    :ivar public_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
     allocated to this device. Your project must have addresses available for a non-default request.
    :vartype public_ipv4_subnet_size: int
    :ivar spot_instance: Create a spot instance. Spot instances are created with a maximum bid
     price. If the bid price is not met, the spot instance will be terminated as indicated by the
     ``termination_time`` field.
    :vartype spot_instance: bool
    :ivar spot_price_max: The maximum amount to bid for a spot instance.
    :vartype spot_price_max: float
    :ivar ssh_keys: A list of new or existing project ssh_keys
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys). These keys will also
     appear in the device metadata.

     These keys are added in addition to any keys defined by
       ``project_ssh_keys`` and ``user_ssh_keys``.
    :vartype ssh_keys: list[~equinixmetalpy.models.SSHKeyInput]
    :ivar tags:
    :vartype tags: list[str]
    :ivar termination_time:
    :vartype termination_time: ~datetime.datetime
    :ivar user_ssh_keys: A list of UUIDs identifying the users
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys).  These keys will also
     appear in the device metadata.

     The users must be members of the project or organization.

     If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
     are all empty lists or omitted),
     all parent project keys, parent project members keys and organization members keys will be
     included. This behaviour can
     be changed with 'no_ssh_keys' option to omit any SSH key being added.
    :vartype user_ssh_keys: list[str]
    :ivar userdata: The userdata presented in the metadata service for this device.  Userdata is
     fetched and interpreted by the operating system installed on the device. Acceptable formats are
     determined by the operating system, with the exception of a special iPXE enabling syntax which
     is handled before the operating system starts.

     See `Server User Data <https://metal.equinix.com/developers/docs/servers/user-data/>`_ and
     `Provisioning with Custom iPXE
     <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe>`_
     for more details.
    :vartype userdata: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "operating_system": {"required": True},
        "plan": {"required": True},
    }

    _attribute_map = {
        "always_pxe": {"key": "always_pxe", "type": "bool"},
        "billing_cycle": {"key": "billing_cycle", "type": "str"},
        "customdata": {"key": "customdata", "type": "{object}"},
        "description": {"key": "description", "type": "str"},
        "features": {"key": "features", "type": "[str]"},
        "hardware_reservation_id": {"key": "hardware_reservation_id", "type": "str"},
        "hostname": {"key": "hostname", "type": "str"},
        "ip_addresses": {
            "key": "ip_addresses",
            "type": "[DeviceCreateInputIpAddressesInner]",
        },
        "ipxe_script_url": {"key": "ipxe_script_url", "type": "str"},
        "locked": {"key": "locked", "type": "bool"},
        "no_ssh_keys": {"key": "no_ssh_keys", "type": "bool"},
        "operating_system": {"key": "operating_system", "type": "str"},
        "plan": {"key": "plan", "type": "str"},
        "private_ipv4_subnet_size": {"key": "private_ipv4_subnet_size", "type": "int"},
        "project_ssh_keys": {"key": "project_ssh_keys", "type": "[str]"},
        "public_ipv4_subnet_size": {"key": "public_ipv4_subnet_size", "type": "int"},
        "spot_instance": {"key": "spot_instance", "type": "bool"},
        "spot_price_max": {"key": "spot_price_max", "type": "float"},
        "ssh_keys": {"key": "ssh_keys", "type": "[SSHKeyInput]"},
        "tags": {"key": "tags", "type": "[str]"},
        "termination_time": {"key": "termination_time", "type": "iso-8601"},
        "user_ssh_keys": {"key": "user_ssh_keys", "type": "[str]"},
        "userdata": {"key": "userdata", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        operating_system: str,
        plan: str,
        always_pxe: Optional[bool] = None,
        billing_cycle: Optional[
            Union[str, "_models.DeviceCreateInputBillingCycle"]
        ] = None,
        customdata: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        features: Optional[List[str]] = None,
        hardware_reservation_id: Optional[str] = None,
        hostname: Optional[str] = None,
        ip_addresses: List["_models.DeviceCreateInputIpAddressesInner"] = [
            {"address_family": 4, "public": True},
            {"address_family": 4, "public": False},
            {"address_family": 6, "public": True},
        ],
        ipxe_script_url: Optional[str] = None,
        locked: bool = False,
        no_ssh_keys: bool = False,
        private_ipv4_subnet_size: int = 28,
        project_ssh_keys: Optional[List[str]] = None,
        public_ipv4_subnet_size: int = 31,
        spot_instance: Optional[bool] = None,
        spot_price_max: Optional[float] = None,
        ssh_keys: Optional[List["_models.SSHKeyInput"]] = None,
        tags: Optional[List[str]] = None,
        termination_time: Optional[datetime.datetime] = None,
        user_ssh_keys: Optional[List[str]] = None,
        userdata: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword always_pxe: When true, devices with a ``custom_ipxe`` OS will always boot to iPXE. The
         default setting of false ensures that iPXE will be used on only the
         first boot.
        :paramtype always_pxe: bool
        :keyword billing_cycle: The billing cycle of the device. Known values are: "hourly", "daily",
         "monthly", and "yearly".
        :paramtype billing_cycle: str or ~equinixmetalpy.models.DeviceCreateInputBillingCycle
        :keyword customdata: Customdata is an arbitrary JSON value that can be accessed via the
         metadata service.
        :paramtype customdata: dict[str, any]
        :keyword description: Any description of the device or how it will be used. This may be used
         to inform other API consumers with project access.
        :paramtype description: str
        :keyword features: The features attribute allows you to optionally specify what features your
         server should have.

         In the API shorthand syntax, all features listed are ``required``\ :

         .. code-block::

            { "features": ["tpm"] }

         Alternatively, if you do not require a certain feature, but would prefer to be assigned a
         server with that feature if there are any available, you may specify that feature with a
         ``preferred`` value. The request will not fail if we have no servers with that feature in our
         inventory. The API offers an alternative syntax for mixing preferred and required features:

         .. code-block::

            { "features": { "tpm": "required", "raid": "preferred" } }

         The request will only fail if there are no available servers matching the required ``tpm``
         criteria.
        :paramtype features: list[str]
        :keyword hardware_reservation_id: The Hardware Reservation UUID to provision. Alternatively,
         ``next-available`` can be specified to select from any of the available hardware reservations.
         An error will be returned if the requested reservation option is not available.

         See `Reserved Hardware <https://metal.equinix.com/developers/docs/deploy/reserved/>`_ for more
         details.
        :paramtype hardware_reservation_id: str
        :keyword hostname: The hostname to use within the operating system. The same hostname may be
         used on multiple devices within a project.
        :paramtype hostname: str
        :keyword ip_addresses: The `ip_addresses attribute will allow you to specify the addresses you
         want created with your device.

         The default value configures public IPv4, public IPv6, and private IPv4.

         Private IPv4 address is required. When specifying ``ip_addresses``\ , one of the array items
         must enable private IPv4.

         Some operating systems require public IPv4 address. In those cases you will receive an error
         message if public IPv4 is not enabled.

         For example, to only configure your server with a private IPv4 address, you can send ``{
         "ip_addresses": [{ "address_family": 4, "public": false }] }``.

         It is possible to request a subnet size larger than a ``/30`` by assigning addresses using the
         UUID(s) of ip_reservations in your project.

         For example, ``{ "ip_addresses": [..., {"address_family": 4, "public": true,
         "ip_reservations": ["uuid1", "uuid2"]}] }``

         To access a server without public IPs, you can use our Out-of-Band console access (SOS) or
         proxy through another server in the project with public IPs enabled.
        :paramtype ip_addresses: list[~equinixmetalpy.models.DeviceCreateInputIpAddressesInner]
        :keyword ipxe_script_url: When set, the device will chainload an iPXE Script at boot fetched
         from the supplied URL.

         See `Custom iPXE <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/>`_
         for more details.
        :paramtype ipxe_script_url: str
        :keyword locked: Whether the device should be locked, preventing accidental deletion.
        :paramtype locked: bool
        :keyword no_ssh_keys: Overrides default behaviour of attaching all of the organization members
         ssh keys and project ssh keys to device if no specific keys specified.
        :paramtype no_ssh_keys: bool
        :keyword operating_system: The slug of the operating system to provision. Check the Equinix
         Metal operating system documentation for rules that may be imposed per operating system,
         including restrictions on IP address options and device plans. Required.
        :paramtype operating_system: str
        :keyword plan: The slug of the device plan to provision. Required.
        :paramtype plan: str
        :keyword private_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
         allocated to this device.
        :paramtype private_ipv4_subnet_size: int
        :keyword project_ssh_keys: A list of UUIDs identifying the device parent project
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.

         If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
         are all empty lists or omitted),
         all parent project keys, parent project members keys and organization members keys will be
         included. This behaviour can
         be changed with 'no_ssh_keys' option to omit any SSH key being added.
        :paramtype project_ssh_keys: list[str]
        :keyword public_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
         allocated to this device. Your project must have addresses available for a non-default request.
        :paramtype public_ipv4_subnet_size: int
        :keyword spot_instance: Create a spot instance. Spot instances are created with a maximum bid
         price. If the bid price is not met, the spot instance will be terminated as indicated by the
         ``termination_time`` field.
        :paramtype spot_instance: bool
        :keyword spot_price_max: The maximum amount to bid for a spot instance.
        :paramtype spot_price_max: float
        :keyword ssh_keys: A list of new or existing project ssh_keys
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys). These keys will also
         appear in the device metadata.

         These keys are added in addition to any keys defined by
           ``project_ssh_keys`` and ``user_ssh_keys``.
        :paramtype ssh_keys: list[~equinixmetalpy.models.SSHKeyInput]
        :keyword tags:
        :paramtype tags: list[str]
        :keyword termination_time:
        :paramtype termination_time: ~datetime.datetime
        :keyword user_ssh_keys: A list of UUIDs identifying the users
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys).  These keys will also
         appear in the device metadata.

         The users must be members of the project or organization.

         If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
         are all empty lists or omitted),
         all parent project keys, parent project members keys and organization members keys will be
         included. This behaviour can
         be changed with 'no_ssh_keys' option to omit any SSH key being added.
        :paramtype user_ssh_keys: list[str]
        :keyword userdata: The userdata presented in the metadata service for this device.  Userdata is
         fetched and interpreted by the operating system installed on the device. Acceptable formats are
         determined by the operating system, with the exception of a special iPXE enabling syntax which
         is handled before the operating system starts.

         See `Server User Data <https://metal.equinix.com/developers/docs/servers/user-data/>`_ and
         `Provisioning with Custom iPXE
         <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe>`_
         for more details.
        :paramtype userdata: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.always_pxe = always_pxe
        self.billing_cycle = billing_cycle
        self.customdata = customdata
        self.description = description
        self.features = features
        self.hardware_reservation_id = hardware_reservation_id
        self.hostname = hostname
        self.ip_addresses = ip_addresses
        self.ipxe_script_url = ipxe_script_url
        self.locked = locked
        self.no_ssh_keys = no_ssh_keys
        self.operating_system = operating_system
        self.plan = plan
        self.private_ipv4_subnet_size = private_ipv4_subnet_size
        self.project_ssh_keys = project_ssh_keys
        self.public_ipv4_subnet_size = public_ipv4_subnet_size
        self.spot_instance = spot_instance
        self.spot_price_max = spot_price_max
        self.ssh_keys = ssh_keys
        self.tags = tags
        self.termination_time = termination_time
        self.user_ssh_keys = user_ssh_keys
        self.userdata = userdata
        self.href = href


class FacilityInput(_serialization.Model):
    """FacilityInput.

    All required parameters must be populated in order to send to Azure.

    :ivar facility: The datacenter where the device should be created.

     Either metro or facility must be provided.

     The API will accept either a single facility ``{ "facility": "f1" }``\ , or it can be
     instructed to create the device in the best available datacenter ``{ "facility": "any" }``.

     Additionally it is possible to set a prioritized location selection. For example ``{
     "facility": ["f3", "f2", "any"] }`` can be used to prioritize ``f3`` and then ``f2`` before
     accepting ``any`` facility. If none of the facilities provided have availability for the
     requested device the request will fail. Required.
    :vartype facility: ~equinixmetalpy.models.FacilityInputFacility
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "facility": {"required": True},
    }

    _attribute_map = {
        "facility": {"key": "facility", "type": "FacilityInputFacility"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        facility: "_models.FacilityInputFacility",
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword facility: The datacenter where the device should be created.

         Either metro or facility must be provided.

         The API will accept either a single facility ``{ "facility": "f1" }``\ , or it can be
         instructed to create the device in the best available datacenter ``{ "facility": "any" }``.

         Additionally it is possible to set a prioritized location selection. For example ``{
         "facility": ["f3", "f2", "any"] }`` can be used to prioritize ``f3`` and then ``f2`` before
         accepting ``any`` facility. If none of the facilities provided have availability for the
         requested device the request will fail. Required.
        :paramtype facility: ~equinixmetalpy.models.FacilityInputFacility
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.facility = facility
        self.href = href


class DeviceCreateInFacilityInput(
    FacilityInput, DeviceCreateInput
):  # pylint: disable=too-many-instance-attributes
    """DeviceCreateInFacilityInput.

    All required parameters must be populated in order to send to Azure.

    :ivar always_pxe: When true, devices with a ``custom_ipxe`` OS will always boot to iPXE. The
     default setting of false ensures that iPXE will be used on only the
     first boot.
    :vartype always_pxe: bool
    :ivar billing_cycle: The billing cycle of the device. Known values are: "hourly", "daily",
     "monthly", and "yearly".
    :vartype billing_cycle: str or ~equinixmetalpy.models.DeviceCreateInputBillingCycle
    :ivar customdata: Customdata is an arbitrary JSON value that can be accessed via the
     metadata service.
    :vartype customdata: dict[str, any]
    :ivar description: Any description of the device or how it will be used. This may be used
     to inform other API consumers with project access.
    :vartype description: str
    :ivar features: The features attribute allows you to optionally specify what features your
     server should have.

     In the API shorthand syntax, all features listed are ``required``\ :

     .. code-block::

        { "features": ["tpm"] }

     Alternatively, if you do not require a certain feature, but would prefer to be assigned a
     server with that feature if there are any available, you may specify that feature with a
     ``preferred`` value. The request will not fail if we have no servers with that feature in our
     inventory. The API offers an alternative syntax for mixing preferred and required features:

     .. code-block::

        { "features": { "tpm": "required", "raid": "preferred" } }

     The request will only fail if there are no available servers matching the required ``tpm``
     criteria.
    :vartype features: list[str]
    :ivar hardware_reservation_id: The Hardware Reservation UUID to provision. Alternatively,
     ``next-available`` can be specified to select from any of the available hardware reservations.
     An error will be returned if the requested reservation option is not available.

     See `Reserved Hardware <https://metal.equinix.com/developers/docs/deploy/reserved/>`_ for more
     details.
    :vartype hardware_reservation_id: str
    :ivar hostname: The hostname to use within the operating system. The same hostname may be used
     on multiple devices within a project.
    :vartype hostname: str
    :ivar ip_addresses: The `ip_addresses attribute will allow you to specify the addresses you
     want created with your device.

     The default value configures public IPv4, public IPv6, and private IPv4.

     Private IPv4 address is required. When specifying ``ip_addresses``\ , one of the array items
     must enable private IPv4.

     Some operating systems require public IPv4 address. In those cases you will receive an error
     message if public IPv4 is not enabled.

     For example, to only configure your server with a private IPv4 address, you can send ``{
     "ip_addresses": [{ "address_family": 4, "public": false }] }``.

     It is possible to request a subnet size larger than a ``/30`` by assigning addresses using the
     UUID(s) of ip_reservations in your project.

     For example, ``{ "ip_addresses": [..., {"address_family": 4, "public": true,
     "ip_reservations": ["uuid1", "uuid2"]}] }``

     To access a server without public IPs, you can use our Out-of-Band console access (SOS) or
     proxy through another server in the project with public IPs enabled.
    :vartype ip_addresses: list[~equinixmetalpy.models.DeviceCreateInputIpAddressesInner]
    :ivar ipxe_script_url: When set, the device will chainload an iPXE Script at boot fetched from
     the supplied URL.

     See `Custom iPXE <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/>`_
     for more details.
    :vartype ipxe_script_url: str
    :ivar locked: Whether the device should be locked, preventing accidental deletion.
    :vartype locked: bool
    :ivar no_ssh_keys: Overrides default behaviour of attaching all of the organization members ssh
     keys and project ssh keys to device if no specific keys specified.
    :vartype no_ssh_keys: bool
    :ivar operating_system: The slug of the operating system to provision. Check the Equinix Metal
     operating system documentation for rules that may be imposed per operating system, including
     restrictions on IP address options and device plans. Required.
    :vartype operating_system: str
    :ivar plan: The slug of the device plan to provision. Required.
    :vartype plan: str
    :ivar private_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
     allocated to this device.
    :vartype private_ipv4_subnet_size: int
    :ivar project_ssh_keys: A list of UUIDs identifying the device parent project
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.

     If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
     are all empty lists or omitted),
     all parent project keys, parent project members keys and organization members keys will be
     included. This behaviour can
     be changed with 'no_ssh_keys' option to omit any SSH key being added.
    :vartype project_ssh_keys: list[str]
    :ivar public_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
     allocated to this device. Your project must have addresses available for a non-default request.
    :vartype public_ipv4_subnet_size: int
    :ivar spot_instance: Create a spot instance. Spot instances are created with a maximum bid
     price. If the bid price is not met, the spot instance will be terminated as indicated by the
     ``termination_time`` field.
    :vartype spot_instance: bool
    :ivar spot_price_max: The maximum amount to bid for a spot instance.
    :vartype spot_price_max: float
    :ivar ssh_keys: A list of new or existing project ssh_keys
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys). These keys will also
     appear in the device metadata.

     These keys are added in addition to any keys defined by
       ``project_ssh_keys`` and ``user_ssh_keys``.
    :vartype ssh_keys: list[~equinixmetalpy.models.SSHKeyInput]
    :ivar tags:
    :vartype tags: list[str]
    :ivar termination_time:
    :vartype termination_time: ~datetime.datetime
    :ivar user_ssh_keys: A list of UUIDs identifying the users
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys).  These keys will also
     appear in the device metadata.

     The users must be members of the project or organization.

     If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
     are all empty lists or omitted),
     all parent project keys, parent project members keys and organization members keys will be
     included. This behaviour can
     be changed with 'no_ssh_keys' option to omit any SSH key being added.
    :vartype user_ssh_keys: list[str]
    :ivar userdata: The userdata presented in the metadata service for this device.  Userdata is
     fetched and interpreted by the operating system installed on the device. Acceptable formats are
     determined by the operating system, with the exception of a special iPXE enabling syntax which
     is handled before the operating system starts.

     See `Server User Data <https://metal.equinix.com/developers/docs/servers/user-data/>`_ and
     `Provisioning with Custom iPXE
     <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe>`_
     for more details.
    :vartype userdata: str
    :ivar facility: The datacenter where the device should be created.

     Either metro or facility must be provided.

     The API will accept either a single facility ``{ "facility": "f1" }``\ , or it can be
     instructed to create the device in the best available datacenter ``{ "facility": "any" }``.

     Additionally it is possible to set a prioritized location selection. For example ``{
     "facility": ["f3", "f2", "any"] }`` can be used to prioritize ``f3`` and then ``f2`` before
     accepting ``any`` facility. If none of the facilities provided have availability for the
     requested device the request will fail. Required.
    :vartype facility: ~equinixmetalpy.models.FacilityInputFacility
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "operating_system": {"required": True},
        "plan": {"required": True},
        "facility": {"required": True},
    }

    _attribute_map = {
        "always_pxe": {"key": "always_pxe", "type": "bool"},
        "billing_cycle": {"key": "billing_cycle", "type": "str"},
        "customdata": {"key": "customdata", "type": "{object}"},
        "description": {"key": "description", "type": "str"},
        "features": {"key": "features", "type": "[str]"},
        "hardware_reservation_id": {"key": "hardware_reservation_id", "type": "str"},
        "hostname": {"key": "hostname", "type": "str"},
        "ip_addresses": {
            "key": "ip_addresses",
            "type": "[DeviceCreateInputIpAddressesInner]",
        },
        "ipxe_script_url": {"key": "ipxe_script_url", "type": "str"},
        "locked": {"key": "locked", "type": "bool"},
        "no_ssh_keys": {"key": "no_ssh_keys", "type": "bool"},
        "operating_system": {"key": "operating_system", "type": "str"},
        "plan": {"key": "plan", "type": "str"},
        "private_ipv4_subnet_size": {"key": "private_ipv4_subnet_size", "type": "int"},
        "project_ssh_keys": {"key": "project_ssh_keys", "type": "[str]"},
        "public_ipv4_subnet_size": {"key": "public_ipv4_subnet_size", "type": "int"},
        "spot_instance": {"key": "spot_instance", "type": "bool"},
        "spot_price_max": {"key": "spot_price_max", "type": "float"},
        "ssh_keys": {"key": "ssh_keys", "type": "[SSHKeyInput]"},
        "tags": {"key": "tags", "type": "[str]"},
        "termination_time": {"key": "termination_time", "type": "iso-8601"},
        "user_ssh_keys": {"key": "user_ssh_keys", "type": "[str]"},
        "userdata": {"key": "userdata", "type": "str"},
        "facility": {"key": "facility", "type": "FacilityInputFacility"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        operating_system: str,
        plan: str,
        facility: "_models.FacilityInputFacility",
        always_pxe: Optional[bool] = None,
        billing_cycle: Optional[
            Union[str, "_models.DeviceCreateInputBillingCycle"]
        ] = None,
        customdata: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        features: Optional[List[str]] = None,
        hardware_reservation_id: Optional[str] = None,
        hostname: Optional[str] = None,
        ip_addresses: List["_models.DeviceCreateInputIpAddressesInner"] = [
            {"address_family": 4, "public": True},
            {"address_family": 4, "public": False},
            {"address_family": 6, "public": True},
        ],
        ipxe_script_url: Optional[str] = None,
        locked: bool = False,
        no_ssh_keys: bool = False,
        private_ipv4_subnet_size: int = 28,
        project_ssh_keys: Optional[List[str]] = None,
        public_ipv4_subnet_size: int = 31,
        spot_instance: Optional[bool] = None,
        spot_price_max: Optional[float] = None,
        ssh_keys: Optional[List["_models.SSHKeyInput"]] = None,
        tags: Optional[List[str]] = None,
        termination_time: Optional[datetime.datetime] = None,
        user_ssh_keys: Optional[List[str]] = None,
        userdata: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword always_pxe: When true, devices with a ``custom_ipxe`` OS will always boot to iPXE. The
         default setting of false ensures that iPXE will be used on only the
         first boot.
        :paramtype always_pxe: bool
        :keyword billing_cycle: The billing cycle of the device. Known values are: "hourly", "daily",
         "monthly", and "yearly".
        :paramtype billing_cycle: str or ~equinixmetalpy.models.DeviceCreateInputBillingCycle
        :keyword customdata: Customdata is an arbitrary JSON value that can be accessed via the
         metadata service.
        :paramtype customdata: dict[str, any]
        :keyword description: Any description of the device or how it will be used. This may be used
         to inform other API consumers with project access.
        :paramtype description: str
        :keyword features: The features attribute allows you to optionally specify what features your
         server should have.

         In the API shorthand syntax, all features listed are ``required``\ :

         .. code-block::

            { "features": ["tpm"] }

         Alternatively, if you do not require a certain feature, but would prefer to be assigned a
         server with that feature if there are any available, you may specify that feature with a
         ``preferred`` value. The request will not fail if we have no servers with that feature in our
         inventory. The API offers an alternative syntax for mixing preferred and required features:

         .. code-block::

            { "features": { "tpm": "required", "raid": "preferred" } }

         The request will only fail if there are no available servers matching the required ``tpm``
         criteria.
        :paramtype features: list[str]
        :keyword hardware_reservation_id: The Hardware Reservation UUID to provision. Alternatively,
         ``next-available`` can be specified to select from any of the available hardware reservations.
         An error will be returned if the requested reservation option is not available.

         See `Reserved Hardware <https://metal.equinix.com/developers/docs/deploy/reserved/>`_ for more
         details.
        :paramtype hardware_reservation_id: str
        :keyword hostname: The hostname to use within the operating system. The same hostname may be
         used on multiple devices within a project.
        :paramtype hostname: str
        :keyword ip_addresses: The `ip_addresses attribute will allow you to specify the addresses you
         want created with your device.

         The default value configures public IPv4, public IPv6, and private IPv4.

         Private IPv4 address is required. When specifying ``ip_addresses``\ , one of the array items
         must enable private IPv4.

         Some operating systems require public IPv4 address. In those cases you will receive an error
         message if public IPv4 is not enabled.

         For example, to only configure your server with a private IPv4 address, you can send ``{
         "ip_addresses": [{ "address_family": 4, "public": false }] }``.

         It is possible to request a subnet size larger than a ``/30`` by assigning addresses using the
         UUID(s) of ip_reservations in your project.

         For example, ``{ "ip_addresses": [..., {"address_family": 4, "public": true,
         "ip_reservations": ["uuid1", "uuid2"]}] }``

         To access a server without public IPs, you can use our Out-of-Band console access (SOS) or
         proxy through another server in the project with public IPs enabled.
        :paramtype ip_addresses: list[~equinixmetalpy.models.DeviceCreateInputIpAddressesInner]
        :keyword ipxe_script_url: When set, the device will chainload an iPXE Script at boot fetched
         from the supplied URL.

         See `Custom iPXE <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/>`_
         for more details.
        :paramtype ipxe_script_url: str
        :keyword locked: Whether the device should be locked, preventing accidental deletion.
        :paramtype locked: bool
        :keyword no_ssh_keys: Overrides default behaviour of attaching all of the organization members
         ssh keys and project ssh keys to device if no specific keys specified.
        :paramtype no_ssh_keys: bool
        :keyword operating_system: The slug of the operating system to provision. Check the Equinix
         Metal operating system documentation for rules that may be imposed per operating system,
         including restrictions on IP address options and device plans. Required.
        :paramtype operating_system: str
        :keyword plan: The slug of the device plan to provision. Required.
        :paramtype plan: str
        :keyword private_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
         allocated to this device.
        :paramtype private_ipv4_subnet_size: int
        :keyword project_ssh_keys: A list of UUIDs identifying the device parent project
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.

         If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
         are all empty lists or omitted),
         all parent project keys, parent project members keys and organization members keys will be
         included. This behaviour can
         be changed with 'no_ssh_keys' option to omit any SSH key being added.
        :paramtype project_ssh_keys: list[str]
        :keyword public_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
         allocated to this device. Your project must have addresses available for a non-default request.
        :paramtype public_ipv4_subnet_size: int
        :keyword spot_instance: Create a spot instance. Spot instances are created with a maximum bid
         price. If the bid price is not met, the spot instance will be terminated as indicated by the
         ``termination_time`` field.
        :paramtype spot_instance: bool
        :keyword spot_price_max: The maximum amount to bid for a spot instance.
        :paramtype spot_price_max: float
        :keyword ssh_keys: A list of new or existing project ssh_keys
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys). These keys will also
         appear in the device metadata.

         These keys are added in addition to any keys defined by
           ``project_ssh_keys`` and ``user_ssh_keys``.
        :paramtype ssh_keys: list[~equinixmetalpy.models.SSHKeyInput]
        :keyword tags:
        :paramtype tags: list[str]
        :keyword termination_time:
        :paramtype termination_time: ~datetime.datetime
        :keyword user_ssh_keys: A list of UUIDs identifying the users
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys).  These keys will also
         appear in the device metadata.

         The users must be members of the project or organization.

         If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
         are all empty lists or omitted),
         all parent project keys, parent project members keys and organization members keys will be
         included. This behaviour can
         be changed with 'no_ssh_keys' option to omit any SSH key being added.
        :paramtype user_ssh_keys: list[str]
        :keyword userdata: The userdata presented in the metadata service for this device.  Userdata is
         fetched and interpreted by the operating system installed on the device. Acceptable formats are
         determined by the operating system, with the exception of a special iPXE enabling syntax which
         is handled before the operating system starts.

         See `Server User Data <https://metal.equinix.com/developers/docs/servers/user-data/>`_ and
         `Provisioning with Custom iPXE
         <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe>`_
         for more details.
        :paramtype userdata: str
        :keyword facility: The datacenter where the device should be created.

         Either metro or facility must be provided.

         The API will accept either a single facility ``{ "facility": "f1" }``\ , or it can be
         instructed to create the device in the best available datacenter ``{ "facility": "any" }``.

         Additionally it is possible to set a prioritized location selection. For example ``{
         "facility": ["f3", "f2", "any"] }`` can be used to prioritize ``f3`` and then ``f2`` before
         accepting ``any`` facility. If none of the facilities provided have availability for the
         requested device the request will fail. Required.
        :paramtype facility: ~equinixmetalpy.models.FacilityInputFacility
        :keyword href:
        :paramtype href: str
        """
        super().__init__(
            facility=facility,
            href=href,
            always_pxe=always_pxe,
            billing_cycle=billing_cycle,
            customdata=customdata,
            description=description,
            features=features,
            hardware_reservation_id=hardware_reservation_id,
            hostname=hostname,
            ip_addresses=ip_addresses,
            ipxe_script_url=ipxe_script_url,
            locked=locked,
            no_ssh_keys=no_ssh_keys,
            operating_system=operating_system,
            plan=plan,
            private_ipv4_subnet_size=private_ipv4_subnet_size,
            project_ssh_keys=project_ssh_keys,
            public_ipv4_subnet_size=public_ipv4_subnet_size,
            spot_instance=spot_instance,
            spot_price_max=spot_price_max,
            ssh_keys=ssh_keys,
            tags=tags,
            termination_time=termination_time,
            user_ssh_keys=user_ssh_keys,
            userdata=userdata,
            **kwargs
        )
        self.always_pxe = always_pxe
        self.billing_cycle = billing_cycle
        self.customdata = customdata
        self.description = description
        self.features = features
        self.hardware_reservation_id = hardware_reservation_id
        self.hostname = hostname
        self.ip_addresses = ip_addresses
        self.ipxe_script_url = ipxe_script_url
        self.locked = locked
        self.no_ssh_keys = no_ssh_keys
        self.operating_system = operating_system
        self.plan = plan
        self.private_ipv4_subnet_size = private_ipv4_subnet_size
        self.project_ssh_keys = project_ssh_keys
        self.public_ipv4_subnet_size = public_ipv4_subnet_size
        self.spot_instance = spot_instance
        self.spot_price_max = spot_price_max
        self.ssh_keys = ssh_keys
        self.tags = tags
        self.termination_time = termination_time
        self.user_ssh_keys = user_ssh_keys
        self.userdata = userdata
        self.facility = facility
        self.href = href


class MetroInput(_serialization.Model):
    """MetroInput.

    All required parameters must be populated in order to send to Azure.

    :ivar metro: Metro code or ID of where the instance should be provisioned in.
     Either metro or facility must be provided. Required.
    :vartype metro: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "metro": {"required": True},
    }

    _attribute_map = {
        "metro": {"key": "metro", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(self, *, metro: str, href: Optional[str] = None, **kwargs):
        """
        :keyword metro: Metro code or ID of where the instance should be provisioned in.
         Either metro or facility must be provided. Required.
        :paramtype metro: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.metro = metro
        self.href = href


class DeviceCreateInMetroInput(
    MetroInput, DeviceCreateInput
):  # pylint: disable=too-many-instance-attributes
    """DeviceCreateInMetroInput.

    All required parameters must be populated in order to send to Azure.

    :ivar always_pxe: When true, devices with a ``custom_ipxe`` OS will always boot to iPXE. The
     default setting of false ensures that iPXE will be used on only the
     first boot.
    :vartype always_pxe: bool
    :ivar billing_cycle: The billing cycle of the device. Known values are: "hourly", "daily",
     "monthly", and "yearly".
    :vartype billing_cycle: str or ~equinixmetalpy.models.DeviceCreateInputBillingCycle
    :ivar customdata: Customdata is an arbitrary JSON value that can be accessed via the
     metadata service.
    :vartype customdata: dict[str, any]
    :ivar description: Any description of the device or how it will be used. This may be used
     to inform other API consumers with project access.
    :vartype description: str
    :ivar features: The features attribute allows you to optionally specify what features your
     server should have.

     In the API shorthand syntax, all features listed are ``required``\ :

     .. code-block::

        { "features": ["tpm"] }

     Alternatively, if you do not require a certain feature, but would prefer to be assigned a
     server with that feature if there are any available, you may specify that feature with a
     ``preferred`` value. The request will not fail if we have no servers with that feature in our
     inventory. The API offers an alternative syntax for mixing preferred and required features:

     .. code-block::

        { "features": { "tpm": "required", "raid": "preferred" } }

     The request will only fail if there are no available servers matching the required ``tpm``
     criteria.
    :vartype features: list[str]
    :ivar hardware_reservation_id: The Hardware Reservation UUID to provision. Alternatively,
     ``next-available`` can be specified to select from any of the available hardware reservations.
     An error will be returned if the requested reservation option is not available.

     See `Reserved Hardware <https://metal.equinix.com/developers/docs/deploy/reserved/>`_ for more
     details.
    :vartype hardware_reservation_id: str
    :ivar hostname: The hostname to use within the operating system. The same hostname may be used
     on multiple devices within a project.
    :vartype hostname: str
    :ivar ip_addresses: The `ip_addresses attribute will allow you to specify the addresses you
     want created with your device.

     The default value configures public IPv4, public IPv6, and private IPv4.

     Private IPv4 address is required. When specifying ``ip_addresses``\ , one of the array items
     must enable private IPv4.

     Some operating systems require public IPv4 address. In those cases you will receive an error
     message if public IPv4 is not enabled.

     For example, to only configure your server with a private IPv4 address, you can send ``{
     "ip_addresses": [{ "address_family": 4, "public": false }] }``.

     It is possible to request a subnet size larger than a ``/30`` by assigning addresses using the
     UUID(s) of ip_reservations in your project.

     For example, ``{ "ip_addresses": [..., {"address_family": 4, "public": true,
     "ip_reservations": ["uuid1", "uuid2"]}] }``

     To access a server without public IPs, you can use our Out-of-Band console access (SOS) or
     proxy through another server in the project with public IPs enabled.
    :vartype ip_addresses: list[~equinixmetalpy.models.DeviceCreateInputIpAddressesInner]
    :ivar ipxe_script_url: When set, the device will chainload an iPXE Script at boot fetched from
     the supplied URL.

     See `Custom iPXE <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/>`_
     for more details.
    :vartype ipxe_script_url: str
    :ivar locked: Whether the device should be locked, preventing accidental deletion.
    :vartype locked: bool
    :ivar no_ssh_keys: Overrides default behaviour of attaching all of the organization members ssh
     keys and project ssh keys to device if no specific keys specified.
    :vartype no_ssh_keys: bool
    :ivar operating_system: The slug of the operating system to provision. Check the Equinix Metal
     operating system documentation for rules that may be imposed per operating system, including
     restrictions on IP address options and device plans. Required.
    :vartype operating_system: str
    :ivar plan: The slug of the device plan to provision. Required.
    :vartype plan: str
    :ivar private_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
     allocated to this device.
    :vartype private_ipv4_subnet_size: int
    :ivar project_ssh_keys: A list of UUIDs identifying the device parent project
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.

     If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
     are all empty lists or omitted),
     all parent project keys, parent project members keys and organization members keys will be
     included. This behaviour can
     be changed with 'no_ssh_keys' option to omit any SSH key being added.
    :vartype project_ssh_keys: list[str]
    :ivar public_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
     allocated to this device. Your project must have addresses available for a non-default request.
    :vartype public_ipv4_subnet_size: int
    :ivar spot_instance: Create a spot instance. Spot instances are created with a maximum bid
     price. If the bid price is not met, the spot instance will be terminated as indicated by the
     ``termination_time`` field.
    :vartype spot_instance: bool
    :ivar spot_price_max: The maximum amount to bid for a spot instance.
    :vartype spot_price_max: float
    :ivar ssh_keys: A list of new or existing project ssh_keys
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys). These keys will also
     appear in the device metadata.

     These keys are added in addition to any keys defined by
       ``project_ssh_keys`` and ``user_ssh_keys``.
    :vartype ssh_keys: list[~equinixmetalpy.models.SSHKeyInput]
    :ivar tags:
    :vartype tags: list[str]
    :ivar termination_time:
    :vartype termination_time: ~datetime.datetime
    :ivar user_ssh_keys: A list of UUIDs identifying the users
     that should be authorized to access this device (typically
     via /root/.ssh/authorized_keys).  These keys will also
     appear in the device metadata.

     The users must be members of the project or organization.

     If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
     are all empty lists or omitted),
     all parent project keys, parent project members keys and organization members keys will be
     included. This behaviour can
     be changed with 'no_ssh_keys' option to omit any SSH key being added.
    :vartype user_ssh_keys: list[str]
    :ivar userdata: The userdata presented in the metadata service for this device.  Userdata is
     fetched and interpreted by the operating system installed on the device. Acceptable formats are
     determined by the operating system, with the exception of a special iPXE enabling syntax which
     is handled before the operating system starts.

     See `Server User Data <https://metal.equinix.com/developers/docs/servers/user-data/>`_ and
     `Provisioning with Custom iPXE
     <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe>`_
     for more details.
    :vartype userdata: str
    :ivar metro: Metro code or ID of where the instance should be provisioned in.
     Either metro or facility must be provided. Required.
    :vartype metro: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "operating_system": {"required": True},
        "plan": {"required": True},
        "metro": {"required": True},
    }

    _attribute_map = {
        "always_pxe": {"key": "always_pxe", "type": "bool"},
        "billing_cycle": {"key": "billing_cycle", "type": "str"},
        "customdata": {"key": "customdata", "type": "{object}"},
        "description": {"key": "description", "type": "str"},
        "features": {"key": "features", "type": "[str]"},
        "hardware_reservation_id": {"key": "hardware_reservation_id", "type": "str"},
        "hostname": {"key": "hostname", "type": "str"},
        "ip_addresses": {
            "key": "ip_addresses",
            "type": "[DeviceCreateInputIpAddressesInner]",
        },
        "ipxe_script_url": {"key": "ipxe_script_url", "type": "str"},
        "locked": {"key": "locked", "type": "bool"},
        "no_ssh_keys": {"key": "no_ssh_keys", "type": "bool"},
        "operating_system": {"key": "operating_system", "type": "str"},
        "plan": {"key": "plan", "type": "str"},
        "private_ipv4_subnet_size": {"key": "private_ipv4_subnet_size", "type": "int"},
        "project_ssh_keys": {"key": "project_ssh_keys", "type": "[str]"},
        "public_ipv4_subnet_size": {"key": "public_ipv4_subnet_size", "type": "int"},
        "spot_instance": {"key": "spot_instance", "type": "bool"},
        "spot_price_max": {"key": "spot_price_max", "type": "float"},
        "ssh_keys": {"key": "ssh_keys", "type": "[SSHKeyInput]"},
        "tags": {"key": "tags", "type": "[str]"},
        "termination_time": {"key": "termination_time", "type": "iso-8601"},
        "user_ssh_keys": {"key": "user_ssh_keys", "type": "[str]"},
        "userdata": {"key": "userdata", "type": "str"},
        "metro": {"key": "metro", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        operating_system: str,
        plan: str,
        metro: str,
        always_pxe: Optional[bool] = None,
        billing_cycle: Optional[
            Union[str, "_models.DeviceCreateInputBillingCycle"]
        ] = None,
        customdata: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        features: Optional[List[str]] = None,
        hardware_reservation_id: Optional[str] = None,
        hostname: Optional[str] = None,
        ip_addresses: List["_models.DeviceCreateInputIpAddressesInner"] = [
            {"address_family": 4, "public": True},
            {"address_family": 4, "public": False},
            {"address_family": 6, "public": True},
        ],
        ipxe_script_url: Optional[str] = None,
        locked: bool = False,
        no_ssh_keys: bool = False,
        private_ipv4_subnet_size: int = 28,
        project_ssh_keys: Optional[List[str]] = None,
        public_ipv4_subnet_size: int = 31,
        spot_instance: Optional[bool] = None,
        spot_price_max: Optional[float] = None,
        ssh_keys: Optional[List["_models.SSHKeyInput"]] = None,
        tags: Optional[List[str]] = None,
        termination_time: Optional[datetime.datetime] = None,
        user_ssh_keys: Optional[List[str]] = None,
        userdata: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword always_pxe: When true, devices with a ``custom_ipxe`` OS will always boot to iPXE. The
         default setting of false ensures that iPXE will be used on only the
         first boot.
        :paramtype always_pxe: bool
        :keyword billing_cycle: The billing cycle of the device. Known values are: "hourly", "daily",
         "monthly", and "yearly".
        :paramtype billing_cycle: str or ~equinixmetalpy.models.DeviceCreateInputBillingCycle
        :keyword customdata: Customdata is an arbitrary JSON value that can be accessed via the
         metadata service.
        :paramtype customdata: dict[str, any]
        :keyword description: Any description of the device or how it will be used. This may be used
         to inform other API consumers with project access.
        :paramtype description: str
        :keyword features: The features attribute allows you to optionally specify what features your
         server should have.

         In the API shorthand syntax, all features listed are ``required``\ :

         .. code-block::

            { "features": ["tpm"] }

         Alternatively, if you do not require a certain feature, but would prefer to be assigned a
         server with that feature if there are any available, you may specify that feature with a
         ``preferred`` value. The request will not fail if we have no servers with that feature in our
         inventory. The API offers an alternative syntax for mixing preferred and required features:

         .. code-block::

            { "features": { "tpm": "required", "raid": "preferred" } }

         The request will only fail if there are no available servers matching the required ``tpm``
         criteria.
        :paramtype features: list[str]
        :keyword hardware_reservation_id: The Hardware Reservation UUID to provision. Alternatively,
         ``next-available`` can be specified to select from any of the available hardware reservations.
         An error will be returned if the requested reservation option is not available.

         See `Reserved Hardware <https://metal.equinix.com/developers/docs/deploy/reserved/>`_ for more
         details.
        :paramtype hardware_reservation_id: str
        :keyword hostname: The hostname to use within the operating system. The same hostname may be
         used on multiple devices within a project.
        :paramtype hostname: str
        :keyword ip_addresses: The `ip_addresses attribute will allow you to specify the addresses you
         want created with your device.

         The default value configures public IPv4, public IPv6, and private IPv4.

         Private IPv4 address is required. When specifying ``ip_addresses``\ , one of the array items
         must enable private IPv4.

         Some operating systems require public IPv4 address. In those cases you will receive an error
         message if public IPv4 is not enabled.

         For example, to only configure your server with a private IPv4 address, you can send ``{
         "ip_addresses": [{ "address_family": 4, "public": false }] }``.

         It is possible to request a subnet size larger than a ``/30`` by assigning addresses using the
         UUID(s) of ip_reservations in your project.

         For example, ``{ "ip_addresses": [..., {"address_family": 4, "public": true,
         "ip_reservations": ["uuid1", "uuid2"]}] }``

         To access a server without public IPs, you can use our Out-of-Band console access (SOS) or
         proxy through another server in the project with public IPs enabled.
        :paramtype ip_addresses: list[~equinixmetalpy.models.DeviceCreateInputIpAddressesInner]
        :keyword ipxe_script_url: When set, the device will chainload an iPXE Script at boot fetched
         from the supplied URL.

         See `Custom iPXE <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/>`_
         for more details.
        :paramtype ipxe_script_url: str
        :keyword locked: Whether the device should be locked, preventing accidental deletion.
        :paramtype locked: bool
        :keyword no_ssh_keys: Overrides default behaviour of attaching all of the organization members
         ssh keys and project ssh keys to device if no specific keys specified.
        :paramtype no_ssh_keys: bool
        :keyword operating_system: The slug of the operating system to provision. Check the Equinix
         Metal operating system documentation for rules that may be imposed per operating system,
         including restrictions on IP address options and device plans. Required.
        :paramtype operating_system: str
        :keyword plan: The slug of the device plan to provision. Required.
        :paramtype plan: str
        :keyword private_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
         allocated to this device.
        :paramtype private_ipv4_subnet_size: int
        :keyword project_ssh_keys: A list of UUIDs identifying the device parent project
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys). These keys will also appear in the device metadata.

         If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
         are all empty lists or omitted),
         all parent project keys, parent project members keys and organization members keys will be
         included. This behaviour can
         be changed with 'no_ssh_keys' option to omit any SSH key being added.
        :paramtype project_ssh_keys: list[str]
        :keyword public_ipv4_subnet_size: Deprecated. Use ip_addresses. Subnet range for addresses
         allocated to this device. Your project must have addresses available for a non-default request.
        :paramtype public_ipv4_subnet_size: int
        :keyword spot_instance: Create a spot instance. Spot instances are created with a maximum bid
         price. If the bid price is not met, the spot instance will be terminated as indicated by the
         ``termination_time`` field.
        :paramtype spot_instance: bool
        :keyword spot_price_max: The maximum amount to bid for a spot instance.
        :paramtype spot_price_max: float
        :keyword ssh_keys: A list of new or existing project ssh_keys
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys). These keys will also
         appear in the device metadata.

         These keys are added in addition to any keys defined by
           ``project_ssh_keys`` and ``user_ssh_keys``.
        :paramtype ssh_keys: list[~equinixmetalpy.models.SSHKeyInput]
        :keyword tags:
        :paramtype tags: list[str]
        :keyword termination_time:
        :paramtype termination_time: ~datetime.datetime
        :keyword user_ssh_keys: A list of UUIDs identifying the users
         that should be authorized to access this device (typically
         via /root/.ssh/authorized_keys).  These keys will also
         appear in the device metadata.

         The users must be members of the project or organization.

         If no SSH keys are specified (\ ``user_ssh_keys``\ , ``project_ssh_keys``\ , and ``ssh_keys``
         are all empty lists or omitted),
         all parent project keys, parent project members keys and organization members keys will be
         included. This behaviour can
         be changed with 'no_ssh_keys' option to omit any SSH key being added.
        :paramtype user_ssh_keys: list[str]
        :keyword userdata: The userdata presented in the metadata service for this device.  Userdata is
         fetched and interpreted by the operating system installed on the device. Acceptable formats are
         determined by the operating system, with the exception of a special iPXE enabling syntax which
         is handled before the operating system starts.

         See `Server User Data <https://metal.equinix.com/developers/docs/servers/user-data/>`_ and
         `Provisioning with Custom iPXE
         <https://metal.equinix.com/developers/docs/operating-systems/custom-ipxe/#provisioning-with-custom-ipxe>`_
         for more details.
        :paramtype userdata: str
        :keyword metro: Metro code or ID of where the instance should be provisioned in.
         Either metro or facility must be provided. Required.
        :paramtype metro: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(
            metro=metro,
            href=href,
            always_pxe=always_pxe,
            billing_cycle=billing_cycle,
            customdata=customdata,
            description=description,
            features=features,
            hardware_reservation_id=hardware_reservation_id,
            hostname=hostname,
            ip_addresses=ip_addresses,
            ipxe_script_url=ipxe_script_url,
            locked=locked,
            no_ssh_keys=no_ssh_keys,
            operating_system=operating_system,
            plan=plan,
            private_ipv4_subnet_size=private_ipv4_subnet_size,
            project_ssh_keys=project_ssh_keys,
            public_ipv4_subnet_size=public_ipv4_subnet_size,
            spot_instance=spot_instance,
            spot_price_max=spot_price_max,
            ssh_keys=ssh_keys,
            tags=tags,
            termination_time=termination_time,
            user_ssh_keys=user_ssh_keys,
            userdata=userdata,
            **kwargs
        )
        self.always_pxe = always_pxe
        self.billing_cycle = billing_cycle
        self.customdata = customdata
        self.description = description
        self.features = features
        self.hardware_reservation_id = hardware_reservation_id
        self.hostname = hostname
        self.ip_addresses = ip_addresses
        self.ipxe_script_url = ipxe_script_url
        self.locked = locked
        self.no_ssh_keys = no_ssh_keys
        self.operating_system = operating_system
        self.plan = plan
        self.private_ipv4_subnet_size = private_ipv4_subnet_size
        self.project_ssh_keys = project_ssh_keys
        self.public_ipv4_subnet_size = public_ipv4_subnet_size
        self.spot_instance = spot_instance
        self.spot_price_max = spot_price_max
        self.ssh_keys = ssh_keys
        self.tags = tags
        self.termination_time = termination_time
        self.user_ssh_keys = user_ssh_keys
        self.userdata = userdata
        self.metro = metro
        self.href = href


class DeviceCreateInputIpAddressesInner(_serialization.Model):
    """DeviceCreateInputIpAddressesInner.

    :ivar address_family: Address Family for IP Address. Known values are: 4 and 6.
    :vartype address_family: int or
     ~equinixmetalpy.models.DeviceCreateInputIpAddressesInnerAddressFamily
    :ivar cidr: Cidr Size for the IP Block created. Valid values depends on the operating system
     being provisioned. (28..32 for IPv4 addresses, 124..127 for IPv6 addresses).
    :vartype cidr: int
    :ivar ip_reservations: UUIDs of any IP reservations to use when assigning IPs.
    :vartype ip_reservations: list[str]
    :ivar public: Address Type for IP Address.
    :vartype public: bool
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "address_family": {"key": "address_family", "type": "int"},
        "cidr": {"key": "cidr", "type": "int"},
        "ip_reservations": {"key": "ip_reservations", "type": "[str]"},
        "public": {"key": "public", "type": "bool"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address_family: Optional[
            Union[int, "_models.DeviceCreateInputIpAddressesInnerAddressFamily"]
        ] = None,
        cidr: Optional[int] = None,
        ip_reservations: Optional[List[str]] = None,
        public: bool = True,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address_family: Address Family for IP Address. Known values are: 4 and 6.
        :paramtype address_family: int or
         ~equinixmetalpy.models.DeviceCreateInputIpAddressesInnerAddressFamily
        :keyword cidr: Cidr Size for the IP Block created. Valid values depends on the operating system
         being provisioned. (28..32 for IPv4 addresses, 124..127 for IPv6 addresses).
        :paramtype cidr: int
        :keyword ip_reservations: UUIDs of any IP reservations to use when assigning IPs.
        :paramtype ip_reservations: list[str]
        :keyword public: Address Type for IP Address.
        :paramtype public: bool
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.address_family = address_family
        self.cidr = cidr
        self.ip_reservations = ip_reservations
        self.public = public
        self.href = href


class DeviceList(_serialization.Model):
    """DeviceList.

    :ivar devices:
    :vartype devices: list[~equinixmetalpy.models.Device]
    :ivar meta:
    :vartype meta: ~equinixmetalpy.models.Meta
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "devices": {"key": "devices", "type": "[Device]"},
        "meta": {"key": "meta", "type": "Meta"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        devices: Optional[List["_models.Device"]] = None,
        meta: Optional["_models.Meta"] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword devices:
        :paramtype devices: list[~equinixmetalpy.models.Device]
        :keyword meta:
        :paramtype meta: ~equinixmetalpy.models.Meta
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.devices = devices
        self.meta = meta
        self.href = href


class Metro(_serialization.Model):
    """Metro.

    :ivar code:
    :vartype code: str
    :ivar country:
    :vartype country: str
    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        country: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword code:
        :paramtype code: str
        :keyword country:
        :paramtype country: str
        :keyword id:
        :paramtype id: str
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.code = code
        self.country = country
        self.id = id
        self.name = name
        self.href = href


class DeviceMetro(Metro):
    """The metro the facility is in.

    :ivar code:
    :vartype code: str
    :ivar country:
    :vartype country: str
    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        country: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword code:
        :paramtype code: str
        :keyword country:
        :paramtype country: str
        :keyword id:
        :paramtype id: str
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(
            code=code, country=country, id=id, name=name, href=href, **kwargs
        )


class Href(_serialization.Model):
    """Href.

    All required parameters must be populated in order to send to Azure.

    :ivar href: Required.
    :vartype href: str
    """

    _validation = {
        "href": {"required": True},
    }

    _attribute_map = {
        "href": {"key": "href", "type": "str"},
    }

    def __init__(self, *, href: str, **kwargs):
        """
        :keyword href: Required.
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.href = href


class DeviceProject(Href):
    """Full version of project object when included.

    All required parameters must be populated in order to send to Azure.

    :ivar href: Required.
    :vartype href: str
    """

    _validation = {
        "href": {"required": True},
    }

    _attribute_map = {
        "href": {"key": "href", "type": "str"},
    }

    def __init__(self, *, href: str, **kwargs):
        """
        :keyword href: Required.
        :paramtype href: str
        """
        super().__init__(href=href, **kwargs)


class DeviceProjectLite(Href):
    """Lite version of project object when included.

    All required parameters must be populated in order to send to Azure.

    :ivar href: Required.
    :vartype href: str
    """

    _validation = {
        "href": {"required": True},
    }

    _attribute_map = {
        "href": {"key": "href", "type": "str"},
    }

    def __init__(self, *, href: str, **kwargs):
        """
        :keyword href: Required.
        :paramtype href: str
        """
        super().__init__(href=href, **kwargs)


class DeviceUpdateInput(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """DeviceUpdateInput.

    :ivar always_pxe:
    :vartype always_pxe: bool
    :ivar billing_cycle:
    :vartype billing_cycle: str
    :ivar customdata: Dictionary of :code:`<any>`.
    :vartype customdata: dict[str, any]
    :ivar description:
    :vartype description: str
    :ivar hostname:
    :vartype hostname: str
    :ivar ipxe_script_url:
    :vartype ipxe_script_url: str
    :ivar locked:
    :vartype locked: bool
    :ivar network_frozen: If true, this instance can not be converted to a different network type.
    :vartype network_frozen: bool
    :ivar spot_instance: Can be set to false to convert a spot-market instance to on-demand.
    :vartype spot_instance: bool
    :ivar tags:
    :vartype tags: list[str]
    :ivar userdata:
    :vartype userdata: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "always_pxe": {"key": "always_pxe", "type": "bool"},
        "billing_cycle": {"key": "billing_cycle", "type": "str"},
        "customdata": {"key": "customdata", "type": "{object}"},
        "description": {"key": "description", "type": "str"},
        "hostname": {"key": "hostname", "type": "str"},
        "ipxe_script_url": {"key": "ipxe_script_url", "type": "str"},
        "locked": {"key": "locked", "type": "bool"},
        "network_frozen": {"key": "network_frozen", "type": "bool"},
        "spot_instance": {"key": "spot_instance", "type": "bool"},
        "tags": {"key": "tags", "type": "[str]"},
        "userdata": {"key": "userdata", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        always_pxe: Optional[bool] = None,
        billing_cycle: Optional[str] = None,
        customdata: Optional[Dict[str, Any]] = None,
        description: Optional[str] = None,
        hostname: Optional[str] = None,
        ipxe_script_url: Optional[str] = None,
        locked: Optional[bool] = None,
        network_frozen: Optional[bool] = None,
        spot_instance: Optional[bool] = None,
        tags: Optional[List[str]] = None,
        userdata: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword always_pxe:
        :paramtype always_pxe: bool
        :keyword billing_cycle:
        :paramtype billing_cycle: str
        :keyword customdata: Dictionary of :code:`<any>`.
        :paramtype customdata: dict[str, any]
        :keyword description:
        :paramtype description: str
        :keyword hostname:
        :paramtype hostname: str
        :keyword ipxe_script_url:
        :paramtype ipxe_script_url: str
        :keyword locked:
        :paramtype locked: bool
        :keyword network_frozen: If true, this instance can not be converted to a different network
         type.
        :paramtype network_frozen: bool
        :keyword spot_instance: Can be set to false to convert a spot-market instance to on-demand.
        :paramtype spot_instance: bool
        :keyword tags:
        :paramtype tags: list[str]
        :keyword userdata:
        :paramtype userdata: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.always_pxe = always_pxe
        self.billing_cycle = billing_cycle
        self.customdata = customdata
        self.description = description
        self.hostname = hostname
        self.ipxe_script_url = ipxe_script_url
        self.locked = locked
        self.network_frozen = network_frozen
        self.spot_instance = spot_instance
        self.tags = tags
        self.userdata = userdata
        self.href = href


class Error(_serialization.Model):
    """Error responses are included with 4xx and 5xx HTTP responses from the API service. Either "error" or "errors" will be set.

    :ivar error: A description of the error that caused the request to fail.
    :vartype error: str
    :ivar errors: A list of errors that contributed to the request failing.
    :vartype errors: list[str]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "error": {"key": "error", "type": "str"},
        "errors": {"key": "errors", "type": "[str]"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        error: Optional[str] = None,
        errors: Optional[List[str]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword error: A description of the error that caused the request to fail.
        :paramtype error: str
        :keyword errors: A list of errors that contributed to the request failing.
        :paramtype errors: list[str]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.error = error
        self.errors = errors
        self.href = href


class Event(_serialization.Model):
    """Event.

    :ivar body:
    :vartype body: str
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar interpolated:
    :vartype interpolated: str
    :ivar relationships:
    :vartype relationships: list[~equinixmetalpy.models.Href]
    :ivar state:
    :vartype state: str
    :ivar type:
    :vartype type: str
    :ivar modified_by: Any object.
    :vartype modified_by: JSON
    :ivar ip:
    :vartype ip: str
    """

    _attribute_map = {
        "body": {"key": "body", "type": "str"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "interpolated": {"key": "interpolated", "type": "str"},
        "relationships": {"key": "relationships", "type": "[Href]"},
        "state": {"key": "state", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "modified_by": {"key": "modified_by", "type": "object"},
        "ip": {"key": "ip", "type": "str"},
    }

    def __init__(
        self,
        *,
        body: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        interpolated: Optional[str] = None,
        relationships: Optional[List["_models.Href"]] = None,
        state: Optional[str] = None,
        type: Optional[str] = None,
        modified_by: Optional[JSON] = None,
        ip: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword body:
        :paramtype body: str
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword interpolated:
        :paramtype interpolated: str
        :keyword relationships:
        :paramtype relationships: list[~equinixmetalpy.models.Href]
        :keyword state:
        :paramtype state: str
        :keyword type:
        :paramtype type: str
        :keyword modified_by: Any object.
        :paramtype modified_by: JSON
        :keyword ip:
        :paramtype ip: str
        """
        super().__init__(**kwargs)
        self.body = body
        self.created_at = created_at
        self.href = href
        self.id = id
        self.interpolated = interpolated
        self.relationships = relationships
        self.state = state
        self.type = type
        self.modified_by = modified_by
        self.ip = ip


class Facility(_serialization.Model):
    """Facility.

    :ivar address:
    :vartype address: ~equinixmetalpy.models.Address
    :ivar code:
    :vartype code: str
    :ivar features:
    :vartype features: list[str or ~equinixmetalpy.models.FacilityFeaturesItem]
    :ivar id:
    :vartype id: str
    :ivar ip_ranges: IP ranges registered in facility. Can be used for GeoIP location.
    :vartype ip_ranges: list[str]
    :ivar metro: The metro the facility is in.
    :vartype metro: ~equinixmetalpy.models.DeviceMetro
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "address": {"key": "address", "type": "Address"},
        "code": {"key": "code", "type": "str"},
        "features": {"key": "features", "type": "[str]"},
        "id": {"key": "id", "type": "str"},
        "ip_ranges": {"key": "ip_ranges", "type": "[str]"},
        "metro": {"key": "metro", "type": "DeviceMetro"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address: Optional["_models.Address"] = None,
        code: Optional[str] = None,
        features: Optional[List[Union[str, "_models.FacilityFeaturesItem"]]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ip_ranges: Optional[List[str]] = None,
        metro: Optional["_models.DeviceMetro"] = None,
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address:
        :paramtype address: ~equinixmetalpy.models.Address
        :keyword code:
        :paramtype code: str
        :keyword features:
        :paramtype features: list[str or ~equinixmetalpy.models.FacilityFeaturesItem]
        :keyword id:
        :paramtype id: str
        :keyword ip_ranges: IP ranges registered in facility. Can be used for GeoIP location.
        :paramtype ip_ranges: list[str]
        :keyword metro: The metro the facility is in.
        :paramtype metro: ~equinixmetalpy.models.DeviceMetro
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.address = address
        self.code = code
        self.features = features
        self.id = id
        self.ip_ranges = ip_ranges
        self.metro = metro
        self.name = name
        self.href = href


class FacilityInputFacility(_serialization.Model):
    """The datacenter where the device should be created.

    Either metro or facility must be provided.

    The API will accept either a single facility ``{ "facility": "f1" }``\ , or it can be instructed to create the device in the best available datacenter ``{ "facility": "any" }``.

    Additionally it is possible to set a prioritized location selection. For example ``{ "facility": ["f3", "f2", "any"] }`` can be used to prioritize ``f3`` and then ``f2`` before accepting ``any`` facility. If none of the facilities provided have availability for the requested device the request will fail.

    """

    _attribute_map = {}

    def __init__(self, **kwargs):
        """ """
        super().__init__(**kwargs)


class FindIPAddressById200Response(_serialization.Model):
    """FindIPAddressById200Response."""

    _attribute_map = {}

    def __init__(self, **kwargs):
        """ """
        super().__init__(**kwargs)


class IPAssignment(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """IPAssignment.

    :ivar address:
    :vartype address: str
    :ivar address_family:
    :vartype address_family: int
    :ivar assigned_to:
    :vartype assigned_to: ~equinixmetalpy.models.Href
    :ivar cidr:
    :vartype cidr: int
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar enabled:
    :vartype enabled: bool
    :ivar gateway:
    :vartype gateway: str
    :ivar global_ip:
    :vartype global_ip: bool
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar manageable:
    :vartype manageable: bool
    :ivar management:
    :vartype management: bool
    :ivar metro: The metro the IP address is in.
    :vartype metro: ~equinixmetalpy.models.IPAssignmentMetro
    :ivar netmask:
    :vartype netmask: str
    :ivar network:
    :vartype network: str
    :ivar parent_block:
    :vartype parent_block: ~equinixmetalpy.models.ParentBlock
    :ivar public:
    :vartype public: bool
    """

    _attribute_map = {
        "address": {"key": "address", "type": "str"},
        "address_family": {"key": "address_family", "type": "int"},
        "assigned_to": {"key": "assigned_to", "type": "Href"},
        "cidr": {"key": "cidr", "type": "int"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "enabled": {"key": "enabled", "type": "bool"},
        "gateway": {"key": "gateway", "type": "str"},
        "global_ip": {"key": "global_ip", "type": "bool"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "manageable": {"key": "manageable", "type": "bool"},
        "management": {"key": "management", "type": "bool"},
        "metro": {"key": "metro", "type": "IPAssignmentMetro"},
        "netmask": {"key": "netmask", "type": "str"},
        "network": {"key": "network", "type": "str"},
        "parent_block": {"key": "parent_block", "type": "ParentBlock"},
        "public": {"key": "public", "type": "bool"},
    }

    def __init__(
        self,
        *,
        address: Optional[str] = None,
        address_family: Optional[int] = None,
        assigned_to: Optional["_models.Href"] = None,
        cidr: Optional[int] = None,
        created_at: Optional[datetime.datetime] = None,
        enabled: Optional[bool] = None,
        gateway: Optional[str] = None,
        global_ip: Optional[bool] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        manageable: Optional[bool] = None,
        management: Optional[bool] = None,
        metro: Optional["_models.IPAssignmentMetro"] = None,
        netmask: Optional[str] = None,
        network: Optional[str] = None,
        parent_block: Optional["_models.ParentBlock"] = None,
        public: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword address:
        :paramtype address: str
        :keyword address_family:
        :paramtype address_family: int
        :keyword assigned_to:
        :paramtype assigned_to: ~equinixmetalpy.models.Href
        :keyword cidr:
        :paramtype cidr: int
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword enabled:
        :paramtype enabled: bool
        :keyword gateway:
        :paramtype gateway: str
        :keyword global_ip:
        :paramtype global_ip: bool
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword manageable:
        :paramtype manageable: bool
        :keyword management:
        :paramtype management: bool
        :keyword metro: The metro the IP address is in.
        :paramtype metro: ~equinixmetalpy.models.IPAssignmentMetro
        :keyword netmask:
        :paramtype netmask: str
        :keyword network:
        :paramtype network: str
        :keyword parent_block:
        :paramtype parent_block: ~equinixmetalpy.models.ParentBlock
        :keyword public:
        :paramtype public: bool
        """
        super().__init__(**kwargs)
        self.address = address
        self.address_family = address_family
        self.assigned_to = assigned_to
        self.cidr = cidr
        self.created_at = created_at
        self.enabled = enabled
        self.gateway = gateway
        self.global_ip = global_ip
        self.href = href
        self.id = id
        self.manageable = manageable
        self.management = management
        self.metro = metro
        self.netmask = netmask
        self.network = network
        self.parent_block = parent_block
        self.public = public


class IPAssignmentInput(_serialization.Model):
    """IPAssignmentInput.

    All required parameters must be populated in order to send to Azure.

    :ivar address: Required.
    :vartype address: str
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar manageable:
    :vartype manageable: bool
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "address": {"required": True},
    }

    _attribute_map = {
        "address": {"key": "address", "type": "str"},
        "customdata": {"key": "customdata", "type": "object"},
        "manageable": {"key": "manageable", "type": "bool"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address: str,
        customdata: Optional[JSON] = None,
        manageable: Optional[bool] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address: Required.
        :paramtype address: str
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword manageable:
        :paramtype manageable: bool
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.address = address
        self.customdata = customdata
        self.manageable = manageable
        self.href = href


class IPAssignmentList(_serialization.Model):
    """IPAssignmentList.

    :ivar ip_addresses:
    :vartype ip_addresses: list[~equinixmetalpy.models.IPAssignment]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "ip_addresses": {"key": "ip_addresses", "type": "[IPAssignment]"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        ip_addresses: Optional[List["_models.IPAssignment"]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword ip_addresses:
        :paramtype ip_addresses: list[~equinixmetalpy.models.IPAssignment]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.ip_addresses = ip_addresses
        self.href = href


class IPAssignmentMetro(Metro):
    """The metro the IP address is in.

    :ivar code:
    :vartype code: str
    :ivar country:
    :vartype country: str
    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        country: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword code:
        :paramtype code: str
        :keyword country:
        :paramtype country: str
        :keyword id:
        :paramtype id: str
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(
            code=code, country=country, id=id, name=name, href=href, **kwargs
        )


class IPAssignmentUpdateInput(_serialization.Model):
    """IPAssignmentUpdateInput.

    :ivar details:
    :vartype details: str
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar tags:
    :vartype tags: list[str]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "details": {"key": "details", "type": "str"},
        "customdata": {"key": "customdata", "type": "object"},
        "tags": {"key": "tags", "type": "[str]"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        details: Optional[str] = None,
        customdata: Optional[JSON] = None,
        tags: Optional[List[str]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword details:
        :paramtype details: str
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword tags:
        :paramtype tags: list[str]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.details = details
        self.customdata = customdata
        self.tags = tags
        self.href = href


class IPAvailabilitiesList(_serialization.Model):
    """IPAvailabilitiesList.

    :ivar available:
    :vartype available: list[str]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "available": {"key": "available", "type": "[str]"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        available: Optional[List[str]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword available:
        :paramtype available: list[str]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.available = available
        self.href = href


class IPReservation(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """IPReservation.

    All required parameters must be populated in order to send to Azure.

    :ivar addon:
    :vartype addon: bool
    :ivar address:
    :vartype address: str
    :ivar address_family:
    :vartype address_family: int
    :ivar assignments:
    :vartype assignments: list[~equinixmetalpy.models.IPAssignment]
    :ivar available:
    :vartype available: str
    :ivar bill:
    :vartype bill: bool
    :ivar cidr:
    :vartype cidr: int
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar enabled:
    :vartype enabled: bool
    :ivar details:
    :vartype details: str
    :ivar facility: The facility the IP reservation is in. If the facility the IP reservation was
     requested in is in a metro, a metro value will also be set, and the subsequent IP reservation
     can be used on a metro level. Can be null if requesting an IP reservation in a metro.
    :vartype facility: ~equinixmetalpy.models.IPReservationFacility
    :ivar gateway:
    :vartype gateway: str
    :ivar global_ip:
    :vartype global_ip: bool
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar manageable:
    :vartype manageable: bool
    :ivar management:
    :vartype management: bool
    :ivar metal_gateway:
    :vartype metal_gateway: ~equinixmetalpy.models.MetalGatewayLite
    :ivar metro: The metro the IP reservation is in. As long as the IP reservation has a metro, it
     can be used on a metro level. Can be null if requesting an IP reservation in a facility that is
     not in a metro.
    :vartype metro: ~equinixmetalpy.models.IPReservationMetro
    :ivar netmask:
    :vartype netmask: str
    :ivar network:
    :vartype network: str
    :ivar project:
    :vartype project: ~equinixmetalpy.models.Project
    :ivar project_lite:
    :vartype project_lite: ~equinixmetalpy.models.Href
    :ivar requested_by:
    :vartype requested_by: ~equinixmetalpy.models.Href
    :ivar public:
    :vartype public: bool
    :ivar state:
    :vartype state: str
    :ivar tags:
    :vartype tags: list[str]
    :ivar type: Required. Known values are: "global_ipv4", "public_ipv4", "private_ipv4", and
     "public_ipv6".
    :vartype type: str or ~equinixmetalpy.models.IPReservationType
    """

    _validation = {
        "type": {"required": True},
    }

    _attribute_map = {
        "addon": {"key": "addon", "type": "bool"},
        "address": {"key": "address", "type": "str"},
        "address_family": {"key": "address_family", "type": "int"},
        "assignments": {"key": "assignments", "type": "[IPAssignment]"},
        "available": {"key": "available", "type": "str"},
        "bill": {"key": "bill", "type": "bool"},
        "cidr": {"key": "cidr", "type": "int"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "customdata": {"key": "customdata", "type": "object"},
        "enabled": {"key": "enabled", "type": "bool"},
        "details": {"key": "details", "type": "str"},
        "facility": {"key": "facility", "type": "IPReservationFacility"},
        "gateway": {"key": "gateway", "type": "str"},
        "global_ip": {"key": "global_ip", "type": "bool"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "manageable": {"key": "manageable", "type": "bool"},
        "management": {"key": "management", "type": "bool"},
        "metal_gateway": {"key": "metal_gateway", "type": "MetalGatewayLite"},
        "metro": {"key": "metro", "type": "IPReservationMetro"},
        "netmask": {"key": "netmask", "type": "str"},
        "network": {"key": "network", "type": "str"},
        "project": {"key": "project", "type": "Project"},
        "project_lite": {"key": "project_lite", "type": "Href"},
        "requested_by": {"key": "requested_by", "type": "Href"},
        "public": {"key": "public", "type": "bool"},
        "state": {"key": "state", "type": "str"},
        "tags": {"key": "tags", "type": "[str]"},
        "type": {"key": "type", "type": "str"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        type: Union[str, "_models.IPReservationType"],
        addon: Optional[bool] = None,
        address: Optional[str] = None,
        address_family: Optional[int] = None,
        assignments: Optional[List["_models.IPAssignment"]] = None,
        available: Optional[str] = None,
        bill: Optional[bool] = None,
        cidr: Optional[int] = None,
        created_at: Optional[datetime.datetime] = None,
        customdata: Optional[JSON] = None,
        enabled: Optional[bool] = None,
        details: Optional[str] = None,
        facility: Optional["_models.IPReservationFacility"] = None,
        gateway: Optional[str] = None,
        global_ip: Optional[bool] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        manageable: Optional[bool] = None,
        management: Optional[bool] = None,
        metal_gateway: Optional["_models.MetalGatewayLite"] = None,
        metro: Optional["_models.IPReservationMetro"] = None,
        netmask: Optional[str] = None,
        network: Optional[str] = None,
        project: Optional["_models.Project"] = None,
        project_lite: Optional["_models.Href"] = None,
        requested_by: Optional["_models.Href"] = None,
        public: Optional[bool] = None,
        state: Optional[str] = None,
        tags: Optional[List[str]] = None,
        **kwargs
    ):
        """
        :keyword addon:
        :paramtype addon: bool
        :keyword address:
        :paramtype address: str
        :keyword address_family:
        :paramtype address_family: int
        :keyword assignments:
        :paramtype assignments: list[~equinixmetalpy.models.IPAssignment]
        :keyword available:
        :paramtype available: str
        :keyword bill:
        :paramtype bill: bool
        :keyword cidr:
        :paramtype cidr: int
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword enabled:
        :paramtype enabled: bool
        :keyword details:
        :paramtype details: str
        :keyword facility: The facility the IP reservation is in. If the facility the IP reservation
         was requested in is in a metro, a metro value will also be set, and the subsequent IP
         reservation can be used on a metro level. Can be null if requesting an IP reservation in a
         metro.
        :paramtype facility: ~equinixmetalpy.models.IPReservationFacility
        :keyword gateway:
        :paramtype gateway: str
        :keyword global_ip:
        :paramtype global_ip: bool
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword manageable:
        :paramtype manageable: bool
        :keyword management:
        :paramtype management: bool
        :keyword metal_gateway:
        :paramtype metal_gateway: ~equinixmetalpy.models.MetalGatewayLite
        :keyword metro: The metro the IP reservation is in. As long as the IP reservation has a metro,
         it can be used on a metro level. Can be null if requesting an IP reservation in a facility that
         is not in a metro.
        :paramtype metro: ~equinixmetalpy.models.IPReservationMetro
        :keyword netmask:
        :paramtype netmask: str
        :keyword network:
        :paramtype network: str
        :keyword project:
        :paramtype project: ~equinixmetalpy.models.Project
        :keyword project_lite:
        :paramtype project_lite: ~equinixmetalpy.models.Href
        :keyword requested_by:
        :paramtype requested_by: ~equinixmetalpy.models.Href
        :keyword public:
        :paramtype public: bool
        :keyword state:
        :paramtype state: str
        :keyword tags:
        :paramtype tags: list[str]
        :keyword type: Required. Known values are: "global_ipv4", "public_ipv4", "private_ipv4", and
         "public_ipv6".
        :paramtype type: str or ~equinixmetalpy.models.IPReservationType
        """
        super().__init__(**kwargs)
        self.addon = addon
        self.address = address
        self.address_family = address_family
        self.assignments = assignments
        self.available = available
        self.bill = bill
        self.cidr = cidr
        self.created_at = created_at
        self.customdata = customdata
        self.enabled = enabled
        self.details = details
        self.facility = facility
        self.gateway = gateway
        self.global_ip = global_ip
        self.href = href
        self.id = id
        self.manageable = manageable
        self.management = management
        self.metal_gateway = metal_gateway
        self.metro = metro
        self.netmask = netmask
        self.network = network
        self.project = project
        self.project_lite = project_lite
        self.requested_by = requested_by
        self.public = public
        self.state = state
        self.tags = tags
        self.type = type


class IPReservationFacility(Facility):
    """The facility the IP reservation is in. If the facility the IP reservation was requested in is in a metro, a metro value will also be set, and the subsequent IP reservation can be used on a metro level. Can be null if requesting an IP reservation in a metro.

    :ivar address:
    :vartype address: ~equinixmetalpy.models.Address
    :ivar code:
    :vartype code: str
    :ivar features:
    :vartype features: list[str or ~equinixmetalpy.models.FacilityFeaturesItem]
    :ivar id:
    :vartype id: str
    :ivar ip_ranges: IP ranges registered in facility. Can be used for GeoIP location.
    :vartype ip_ranges: list[str]
    :ivar metro: The metro the facility is in.
    :vartype metro: ~equinixmetalpy.models.DeviceMetro
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "address": {"key": "address", "type": "Address"},
        "code": {"key": "code", "type": "str"},
        "features": {"key": "features", "type": "[str]"},
        "id": {"key": "id", "type": "str"},
        "ip_ranges": {"key": "ip_ranges", "type": "[str]"},
        "metro": {"key": "metro", "type": "DeviceMetro"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address: Optional["_models.Address"] = None,
        code: Optional[str] = None,
        features: Optional[List[Union[str, "_models.FacilityFeaturesItem"]]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ip_ranges: Optional[List[str]] = None,
        metro: Optional["_models.DeviceMetro"] = None,
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address:
        :paramtype address: ~equinixmetalpy.models.Address
        :keyword code:
        :paramtype code: str
        :keyword features:
        :paramtype features: list[str or ~equinixmetalpy.models.FacilityFeaturesItem]
        :keyword id:
        :paramtype id: str
        :keyword ip_ranges: IP ranges registered in facility. Can be used for GeoIP location.
        :paramtype ip_ranges: list[str]
        :keyword metro: The metro the facility is in.
        :paramtype metro: ~equinixmetalpy.models.DeviceMetro
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(
            address=address,
            code=code,
            features=features,
            id=id,
            ip_ranges=ip_ranges,
            metro=metro,
            name=name,
            href=href,
            **kwargs
        )


class IPReservationList(_serialization.Model):
    """IPReservationList.

    :ivar ip_addresses:
    :vartype ip_addresses: list[~equinixmetalpy.models.IPReservationListIpAddressesInner]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "ip_addresses": {
            "key": "ip_addresses",
            "type": "[IPReservationListIpAddressesInner]",
        },
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        ip_addresses: Optional[
            List["_models.IPReservationListIpAddressesInner"]
        ] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword ip_addresses:
        :paramtype ip_addresses: list[~equinixmetalpy.models.IPReservationListIpAddressesInner]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.ip_addresses = ip_addresses
        self.href = href


class IPReservationListIpAddressesInner(_serialization.Model):
    """IPReservationListIpAddressesInner."""

    _attribute_map = {}

    def __init__(self, **kwargs):
        """ """
        super().__init__(**kwargs)


class IPReservationMetro(Metro):
    """The metro the IP reservation is in. As long as the IP reservation has a metro, it can be used on a metro level. Can be null if requesting an IP reservation in a facility that is not in a metro.

    :ivar code:
    :vartype code: str
    :ivar country:
    :vartype country: str
    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "code": {"key": "code", "type": "str"},
        "country": {"key": "country", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        code: Optional[str] = None,
        country: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword code:
        :paramtype code: str
        :keyword country:
        :paramtype country: str
        :keyword id:
        :paramtype id: str
        :keyword name:
        :paramtype name: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(
            code=code, country=country, id=id, name=name, href=href, **kwargs
        )


class IPReservationRequestInput(_serialization.Model):
    """IPReservationRequestInput.

    All required parameters must be populated in order to send to Azure.

    :ivar comments:
    :vartype comments: str
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar details:
    :vartype details: str
    :ivar facility:
    :vartype facility: str
    :ivar fail_on_approval_required:
    :vartype fail_on_approval_required: bool
    :ivar metro: The code of the metro you are requesting the IP reservation in.
    :vartype metro: str
    :ivar quantity: Required.
    :vartype quantity: int
    :ivar tags:
    :vartype tags: list[str]
    :ivar type: Required.
    :vartype type: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "quantity": {"required": True},
        "type": {"required": True},
    }

    _attribute_map = {
        "comments": {"key": "comments", "type": "str"},
        "customdata": {"key": "customdata", "type": "object"},
        "details": {"key": "details", "type": "str"},
        "facility": {"key": "facility", "type": "str"},
        "fail_on_approval_required": {
            "key": "fail_on_approval_required",
            "type": "bool",
        },
        "metro": {"key": "metro", "type": "str"},
        "quantity": {"key": "quantity", "type": "int"},
        "tags": {"key": "tags", "type": "[str]"},
        "type": {"key": "type", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        quantity: int,
        type: str,
        comments: Optional[str] = None,
        customdata: Optional[JSON] = None,
        details: Optional[str] = None,
        facility: Optional[str] = None,
        fail_on_approval_required: Optional[bool] = None,
        metro: Optional[str] = None,
        tags: Optional[List[str]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword comments:
        :paramtype comments: str
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword details:
        :paramtype details: str
        :keyword facility:
        :paramtype facility: str
        :keyword fail_on_approval_required:
        :paramtype fail_on_approval_required: bool
        :keyword metro: The code of the metro you are requesting the IP reservation in.
        :paramtype metro: str
        :keyword quantity: Required.
        :paramtype quantity: int
        :keyword tags:
        :paramtype tags: list[str]
        :keyword type: Required.
        :paramtype type: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.comments = comments
        self.customdata = customdata
        self.details = details
        self.facility = facility
        self.fail_on_approval_required = fail_on_approval_required
        self.metro = metro
        self.quantity = quantity
        self.tags = tags
        self.type = type
        self.href = href


class Meta(_serialization.Model):
    """Meta.

    :ivar first:
    :vartype first: ~equinixmetalpy.models.Href
    :ivar last:
    :vartype last: ~equinixmetalpy.models.Href
    :ivar next:
    :vartype next: ~equinixmetalpy.models.Href
    :ivar previous:
    :vartype previous: ~equinixmetalpy.models.Href
    :ivar self_property:
    :vartype self_property: ~equinixmetalpy.models.Href
    :ivar total:
    :vartype total: int
    :ivar current_page:
    :vartype current_page: int
    :ivar last_page:
    :vartype last_page: int
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "first": {"key": "first", "type": "Href"},
        "last": {"key": "last", "type": "Href"},
        "next": {"key": "next", "type": "Href"},
        "previous": {"key": "previous", "type": "Href"},
        "self_property": {"key": "self", "type": "Href"},
        "total": {"key": "total", "type": "int"},
        "current_page": {"key": "current_page", "type": "int"},
        "last_page": {"key": "last_page", "type": "int"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        first: Optional["_models.Href"] = None,
        last: Optional["_models.Href"] = None,
        next: Optional["_models.Href"] = None,
        previous: Optional["_models.Href"] = None,
        self_property: Optional["_models.Href"] = None,
        total: Optional[int] = None,
        current_page: Optional[int] = None,
        last_page: Optional[int] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword first:
        :paramtype first: ~equinixmetalpy.models.Href
        :keyword last:
        :paramtype last: ~equinixmetalpy.models.Href
        :keyword next:
        :paramtype next: ~equinixmetalpy.models.Href
        :keyword previous:
        :paramtype previous: ~equinixmetalpy.models.Href
        :keyword self_property:
        :paramtype self_property: ~equinixmetalpy.models.Href
        :keyword total:
        :paramtype total: int
        :keyword current_page:
        :paramtype current_page: int
        :keyword last_page:
        :paramtype last_page: int
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.first = first
        self.last = last
        self.next = next
        self.previous = previous
        self.self_property = self_property
        self.total = total
        self.current_page = current_page
        self.last_page = last_page
        self.href = href


class MetalGatewayLite(_serialization.Model):
    """MetalGatewayLite.

    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar gateway_address: The gateway address with subnet CIDR value for this Metal Gateway. For
     example, a Metal Gateway using an IP reservation with block 10.1.2.0/27 would have a gateway
     address of 10.1.2.1/27.
    :vartype gateway_address: str
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar state: The current state of the Metal Gateway. 'Ready' indicates the gateway record has
     been configured, but is currently not active on the network. 'Active' indicates the gateway has
     been configured on the network. 'Deleting' is a temporary state used to indicate that the
     gateway is in the process of being un-configured from the network, after which the gateway
     record will be deleted. Known values are: "ready", "active", and "deleting".
    :vartype state: str or ~equinixmetalpy.models.MetalGatewayLiteState
    :ivar updated_at:
    :vartype updated_at: ~datetime.datetime
    :ivar vlan: The VLAN id of the Virtual Network record associated to this Metal Gateway.
    :vartype vlan: int
    """

    _attribute_map = {
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "gateway_address": {"key": "gateway_address", "type": "str"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "state": {"key": "state", "type": "str"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
        "vlan": {"key": "vlan", "type": "int"},
    }

    def __init__(
        self,
        *,
        created_at: Optional[datetime.datetime] = None,
        gateway_address: Optional[str] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        state: Optional[Union[str, "_models.MetalGatewayLiteState"]] = None,
        updated_at: Optional[datetime.datetime] = None,
        vlan: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword gateway_address: The gateway address with subnet CIDR value for this Metal Gateway.
         For example, a Metal Gateway using an IP reservation with block 10.1.2.0/27 would have a
         gateway address of 10.1.2.1/27.
        :paramtype gateway_address: str
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword state: The current state of the Metal Gateway. 'Ready' indicates the gateway record
         has been configured, but is currently not active on the network. 'Active' indicates the gateway
         has been configured on the network. 'Deleting' is a temporary state used to indicate that the
         gateway is in the process of being un-configured from the network, after which the gateway
         record will be deleted. Known values are: "ready", "active", and "deleting".
        :paramtype state: str or ~equinixmetalpy.models.MetalGatewayLiteState
        :keyword updated_at:
        :paramtype updated_at: ~datetime.datetime
        :keyword vlan: The VLAN id of the Virtual Network record associated to this Metal Gateway.
        :paramtype vlan: int
        """
        super().__init__(**kwargs)
        self.created_at = created_at
        self.gateway_address = gateway_address
        self.href = href
        self.id = id
        self.state = state
        self.updated_at = updated_at
        self.vlan = vlan


class OperatingSystem(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """OperatingSystem.

    :ivar distro:
    :vartype distro: str
    :ivar distro_label:
    :vartype distro_label: str
    :ivar id:
    :vartype id: str
    :ivar licensed: Licenced OS is priced according to pricing property.
    :vartype licensed: bool
    :ivar name:
    :vartype name: str
    :ivar preinstallable: Servers can be already preinstalled with OS in order to shorten provision
     time.
    :vartype preinstallable: bool
    :ivar pricing: This object contains price per time unit and optional multiplier value if
     licence price depends on hardware plan or components (e.g. number of cores).
    :vartype pricing: JSON
    :ivar provisionable_on:
    :vartype provisionable_on: list[str]
    :ivar slug:
    :vartype slug: str
    :ivar version:
    :vartype version: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "distro": {"key": "distro", "type": "str"},
        "distro_label": {"key": "distro_label", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "licensed": {"key": "licensed", "type": "bool"},
        "name": {"key": "name", "type": "str"},
        "preinstallable": {"key": "preinstallable", "type": "bool"},
        "pricing": {"key": "pricing", "type": "object"},
        "provisionable_on": {"key": "provisionable_on", "type": "[str]"},
        "slug": {"key": "slug", "type": "str"},
        "version": {"key": "version", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        distro: Optional[str] = None,
        distro_label: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        licensed: Optional[bool] = None,
        name: Optional[str] = None,
        preinstallable: Optional[bool] = None,
        pricing: Optional[JSON] = None,
        provisionable_on: Optional[List[str]] = None,
        slug: Optional[str] = None,
        version: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword distro:
        :paramtype distro: str
        :keyword distro_label:
        :paramtype distro_label: str
        :keyword id:
        :paramtype id: str
        :keyword licensed: Licenced OS is priced according to pricing property.
        :paramtype licensed: bool
        :keyword name:
        :paramtype name: str
        :keyword preinstallable: Servers can be already preinstalled with OS in order to shorten
         provision time.
        :paramtype preinstallable: bool
        :keyword pricing: This object contains price per time unit and optional multiplier value if
         licence price depends on hardware plan or components (e.g. number of cores).
        :paramtype pricing: JSON
        :keyword provisionable_on:
        :paramtype provisionable_on: list[str]
        :keyword slug:
        :paramtype slug: str
        :keyword version:
        :paramtype version: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.distro = distro
        self.distro_label = distro_label
        self.id = id
        self.licensed = licensed
        self.name = name
        self.preinstallable = preinstallable
        self.pricing = pricing
        self.provisionable_on = provisionable_on
        self.slug = slug
        self.version = version
        self.href = href


class Organization(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """Organization.

    :ivar address:
    :vartype address: ~equinixmetalpy.models.Address
    :ivar billing_address:
    :vartype billing_address: ~equinixmetalpy.models.Address
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar credit_amount:
    :vartype credit_amount: float
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar description:
    :vartype description: str
    :ivar enforce2_fa_at: Force to all members to have enabled the two factor authentication after
     that date, unless the value is null.
    :vartype enforce2_fa_at: ~datetime.datetime
    :ivar id:
    :vartype id: str
    :ivar logo:
    :vartype logo: IO
    :ivar members:
    :vartype members: list[~equinixmetalpy.models.Href]
    :ivar memberships:
    :vartype memberships: list[~equinixmetalpy.models.Href]
    :ivar name:
    :vartype name: str
    :ivar projects:
    :vartype projects: list[~equinixmetalpy.models.Href]
    :ivar terms:
    :vartype terms: int
    :ivar twitter:
    :vartype twitter: str
    :ivar updated_at:
    :vartype updated_at: ~datetime.datetime
    :ivar website:
    :vartype website: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "address": {"key": "address", "type": "Address"},
        "billing_address": {"key": "billing_address", "type": "Address"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "credit_amount": {"key": "credit_amount", "type": "float"},
        "customdata": {"key": "customdata", "type": "object"},
        "description": {"key": "description", "type": "str"},
        "enforce2_fa_at": {"key": "enforce_2fa_at", "type": "iso-8601"},
        "id": {"key": "id", "type": "str"},
        "logo": {"key": "logo", "type": "IO"},
        "members": {"key": "members", "type": "[Href]"},
        "memberships": {"key": "memberships", "type": "[Href]"},
        "name": {"key": "name", "type": "str"},
        "projects": {"key": "projects", "type": "[Href]"},
        "terms": {"key": "terms", "type": "int"},
        "twitter": {"key": "twitter", "type": "str"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
        "website": {"key": "website", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address: Optional["_models.Address"] = None,
        billing_address: Optional["_models.Address"] = None,
        created_at: Optional[datetime.datetime] = None,
        credit_amount: Optional[float] = None,
        customdata: Optional[JSON] = None,
        description: Optional[str] = None,
        enforce2_fa_at: Optional[datetime.datetime] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        logo: Optional[IO] = None,
        members: Optional[List["_models.Href"]] = None,
        memberships: Optional[List["_models.Href"]] = None,
        name: Optional[str] = None,
        projects: Optional[List["_models.Href"]] = None,
        terms: Optional[int] = None,
        twitter: Optional[str] = None,
        updated_at: Optional[datetime.datetime] = None,
        website: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address:
        :paramtype address: ~equinixmetalpy.models.Address
        :keyword billing_address:
        :paramtype billing_address: ~equinixmetalpy.models.Address
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword credit_amount:
        :paramtype credit_amount: float
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword description:
        :paramtype description: str
        :keyword enforce2_fa_at: Force to all members to have enabled the two factor authentication
         after that date, unless the value is null.
        :paramtype enforce2_fa_at: ~datetime.datetime
        :keyword id:
        :paramtype id: str
        :keyword logo:
        :paramtype logo: IO
        :keyword members:
        :paramtype members: list[~equinixmetalpy.models.Href]
        :keyword memberships:
        :paramtype memberships: list[~equinixmetalpy.models.Href]
        :keyword name:
        :paramtype name: str
        :keyword projects:
        :paramtype projects: list[~equinixmetalpy.models.Href]
        :keyword terms:
        :paramtype terms: int
        :keyword twitter:
        :paramtype twitter: str
        :keyword updated_at:
        :paramtype updated_at: ~datetime.datetime
        :keyword website:
        :paramtype website: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.address = address
        self.billing_address = billing_address
        self.created_at = created_at
        self.credit_amount = credit_amount
        self.customdata = customdata
        self.description = description
        self.enforce2_fa_at = enforce2_fa_at
        self.id = id
        self.logo = logo
        self.members = members
        self.memberships = memberships
        self.name = name
        self.projects = projects
        self.terms = terms
        self.twitter = twitter
        self.updated_at = updated_at
        self.website = website
        self.href = href


class OrganizationInput(_serialization.Model):
    """OrganizationInput.

    :ivar address:
    :vartype address: ~equinixmetalpy.models.Address
    :ivar billing_address:
    :vartype billing_address: ~equinixmetalpy.models.Address
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar description:
    :vartype description: str
    :ivar enforce2_fa_at: Force to all members to have enabled the two factor authentication after
     that date, unless the value is null.
    :vartype enforce2_fa_at: ~datetime.datetime
    :ivar logo:
    :vartype logo: IO
    :ivar name:
    :vartype name: str
    :ivar twitter:
    :vartype twitter: str
    :ivar website:
    :vartype website: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "address": {"key": "address", "type": "Address"},
        "billing_address": {"key": "billing_address", "type": "Address"},
        "customdata": {"key": "customdata", "type": "object"},
        "description": {"key": "description", "type": "str"},
        "enforce2_fa_at": {"key": "enforce_2fa_at", "type": "iso-8601"},
        "logo": {"key": "logo", "type": "IO"},
        "name": {"key": "name", "type": "str"},
        "twitter": {"key": "twitter", "type": "str"},
        "website": {"key": "website", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        address: Optional["_models.Address"] = None,
        billing_address: Optional["_models.Address"] = None,
        customdata: Optional[JSON] = None,
        description: Optional[str] = None,
        enforce2_fa_at: Optional[datetime.datetime] = None,
        logo: Optional[IO] = None,
        name: Optional[str] = None,
        twitter: Optional[str] = None,
        website: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword address:
        :paramtype address: ~equinixmetalpy.models.Address
        :keyword billing_address:
        :paramtype billing_address: ~equinixmetalpy.models.Address
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword description:
        :paramtype description: str
        :keyword enforce2_fa_at: Force to all members to have enabled the two factor authentication
         after that date, unless the value is null.
        :paramtype enforce2_fa_at: ~datetime.datetime
        :keyword logo:
        :paramtype logo: IO
        :keyword name:
        :paramtype name: str
        :keyword twitter:
        :paramtype twitter: str
        :keyword website:
        :paramtype website: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.address = address
        self.billing_address = billing_address
        self.customdata = customdata
        self.description = description
        self.enforce2_fa_at = enforce2_fa_at
        self.logo = logo
        self.name = name
        self.twitter = twitter
        self.website = website
        self.href = href


class OrganizationList(_serialization.Model):
    """OrganizationList.

    :ivar meta:
    :vartype meta: ~equinixmetalpy.models.Meta
    :ivar organizations:
    :vartype organizations: list[~equinixmetalpy.models.Organization]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "meta": {"key": "meta", "type": "Meta"},
        "organizations": {"key": "organizations", "type": "[Organization]"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        meta: Optional["_models.Meta"] = None,
        organizations: Optional[List["_models.Organization"]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword meta:
        :paramtype meta: ~equinixmetalpy.models.Meta
        :keyword organizations:
        :paramtype organizations: list[~equinixmetalpy.models.Organization]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.meta = meta
        self.organizations = organizations
        self.href = href


class ParentBlock(_serialization.Model):
    """ParentBlock.

    :ivar cidr:
    :vartype cidr: int
    :ivar href:
    :vartype href: str
    :ivar netmask:
    :vartype netmask: str
    :ivar network:
    :vartype network: str
    """

    _attribute_map = {
        "cidr": {"key": "cidr", "type": "int"},
        "href": {"key": "href", "type": "str"},
        "netmask": {"key": "netmask", "type": "str"},
        "network": {"key": "network", "type": "str"},
    }

    def __init__(
        self,
        *,
        cidr: Optional[int] = None,
        href: Optional[str] = None,
        netmask: Optional[str] = None,
        network: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword cidr:
        :paramtype cidr: int
        :keyword href:
        :paramtype href: str
        :keyword netmask:
        :paramtype netmask: str
        :keyword network:
        :paramtype network: str
        """
        super().__init__(**kwargs)
        self.cidr = cidr
        self.href = href
        self.netmask = netmask
        self.network = network


class Plan(_serialization.Model):  # pylint: disable=too-many-instance-attributes
    """Plan.

    :ivar available_in: Shows which facilities the plan is available in, and the facility-based
     price if it is different from the default price.
    :vartype available_in: list[~equinixmetalpy.models.PlanAvailableInInner]
    :ivar available_in_metros: Shows which metros the plan is available in, and the metro-based
     price if it is different from the default price.
    :vartype available_in_metros: list[~equinixmetalpy.models.PlanAvailableInMetrosInner]
    :ivar class_property:
    :vartype class_property: str
    :ivar description:
    :vartype description: str
    :ivar deployment_types:
    :vartype deployment_types: list[str or ~equinixmetalpy.models.PlanDeploymentTypesItem]
    :ivar id:
    :vartype id: str
    :ivar legacy:
    :vartype legacy: bool
    :ivar line: "baremetal"
    :vartype line: str or ~equinixmetalpy.models.PlanLine
    :ivar name:
    :vartype name: str
    :ivar pricing: Any object.
    :vartype pricing: JSON
    :ivar slug:
    :vartype slug: str
    :ivar specs:
    :vartype specs: ~equinixmetalpy.models.PlanSpecs
    :ivar type: The plan type. Known values are: "standard", "workload_optimized", and "custom".
    :vartype type: str or ~equinixmetalpy.models.PlanType
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "deployment_types": {"unique": True},
    }

    _attribute_map = {
        "available_in": {"key": "available_in", "type": "[PlanAvailableInInner]"},
        "available_in_metros": {
            "key": "available_in_metros",
            "type": "[PlanAvailableInMetrosInner]",
        },
        "class_property": {"key": "class", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "deployment_types": {"key": "deployment_types", "type": "[str]"},
        "id": {"key": "id", "type": "str"},
        "legacy": {"key": "legacy", "type": "bool"},
        "line": {"key": "line", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "pricing": {"key": "pricing", "type": "object"},
        "slug": {"key": "slug", "type": "str"},
        "specs": {"key": "specs", "type": "PlanSpecs"},
        "type": {"key": "type", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        available_in: Optional[List["_models.PlanAvailableInInner"]] = None,
        available_in_metros: Optional[
            List["_models.PlanAvailableInMetrosInner"]
        ] = None,
        class_property: Optional[str] = None,
        description: Optional[str] = None,
        deployment_types: Optional[
            List[Union[str, "_models.PlanDeploymentTypesItem"]]
        ] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        legacy: Optional[bool] = None,
        line: Optional[Union[str, "_models.PlanLine"]] = None,
        name: Optional[str] = None,
        pricing: Optional[JSON] = None,
        slug: Optional[str] = None,
        specs: Optional["_models.PlanSpecs"] = None,
        type: Optional[Union[str, "_models.PlanType"]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword available_in: Shows which facilities the plan is available in, and the facility-based
         price if it is different from the default price.
        :paramtype available_in: list[~equinixmetalpy.models.PlanAvailableInInner]
        :keyword available_in_metros: Shows which metros the plan is available in, and the metro-based
         price if it is different from the default price.
        :paramtype available_in_metros: list[~equinixmetalpy.models.PlanAvailableInMetrosInner]
        :keyword class_property:
        :paramtype class_property: str
        :keyword description:
        :paramtype description: str
        :keyword deployment_types:
        :paramtype deployment_types: list[str or ~equinixmetalpy.models.PlanDeploymentTypesItem]
        :keyword id:
        :paramtype id: str
        :keyword legacy:
        :paramtype legacy: bool
        :keyword line: "baremetal"
        :paramtype line: str or ~equinixmetalpy.models.PlanLine
        :keyword name:
        :paramtype name: str
        :keyword pricing: Any object.
        :paramtype pricing: JSON
        :keyword slug:
        :paramtype slug: str
        :keyword specs:
        :paramtype specs: ~equinixmetalpy.models.PlanSpecs
        :keyword type: The plan type. Known values are: "standard", "workload_optimized", and "custom".
        :paramtype type: str or ~equinixmetalpy.models.PlanType
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.available_in = available_in
        self.available_in_metros = available_in_metros
        self.class_property = class_property
        self.description = description
        self.deployment_types = deployment_types
        self.id = id
        self.legacy = legacy
        self.line = line
        self.name = name
        self.pricing = pricing
        self.slug = slug
        self.specs = specs
        self.type = type
        self.href = href


class PlanAvailableInInner(_serialization.Model):
    """PlanAvailableInInner.

    :ivar href: href to the Facility.
    :vartype href: str
    :ivar price:
    :vartype price: ~equinixmetalpy.models.PlanAvailableInInnerPrice
    """

    _attribute_map = {
        "href": {"key": "href", "type": "str"},
        "price": {"key": "price", "type": "PlanAvailableInInnerPrice"},
    }

    def __init__(
        self,
        *,
        href: Optional[str] = None,
        price: Optional["_models.PlanAvailableInInnerPrice"] = None,
        **kwargs
    ):
        """
        :keyword href: href to the Facility.
        :paramtype href: str
        :keyword price:
        :paramtype price: ~equinixmetalpy.models.PlanAvailableInInnerPrice
        """
        super().__init__(**kwargs)
        self.href = href
        self.price = price


class PlanAvailableInInnerPrice(_serialization.Model):
    """PlanAvailableInInnerPrice.

    :ivar hour:
    :vartype hour: float
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "hour": {"key": "hour", "type": "float"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self, *, hour: Optional[float] = None, href: Optional[str] = None, **kwargs
    ):
        """
        :keyword hour:
        :paramtype hour: float
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.hour = hour
        self.href = href


class PlanAvailableInMetrosInner(_serialization.Model):
    """PlanAvailableInMetrosInner.

    :ivar href: href to the Metro.
    :vartype href: str
    :ivar price:
    :vartype price: ~equinixmetalpy.models.PlanAvailableInInnerPrice
    """

    _attribute_map = {
        "href": {"key": "href", "type": "str"},
        "price": {"key": "price", "type": "PlanAvailableInInnerPrice"},
    }

    def __init__(
        self,
        *,
        href: Optional[str] = None,
        price: Optional["_models.PlanAvailableInInnerPrice"] = None,
        **kwargs
    ):
        """
        :keyword href: href to the Metro.
        :paramtype href: str
        :keyword price:
        :paramtype price: ~equinixmetalpy.models.PlanAvailableInInnerPrice
        """
        super().__init__(**kwargs)
        self.href = href
        self.price = price


class PlanSpecs(_serialization.Model):
    """PlanSpecs.

    :ivar cpus:
    :vartype cpus: list[~equinixmetalpy.models.PlanSpecsCpusInner]
    :ivar drives:
    :vartype drives: list[~equinixmetalpy.models.PlanSpecsDrivesInner]
    :ivar nics:
    :vartype nics: list[~equinixmetalpy.models.PlanSpecsNicsInner]
    :ivar features:
    :vartype features: ~equinixmetalpy.models.PlanSpecsFeatures
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "cpus": {"key": "cpus", "type": "[PlanSpecsCpusInner]"},
        "drives": {"key": "drives", "type": "[PlanSpecsDrivesInner]"},
        "nics": {"key": "nics", "type": "[PlanSpecsNicsInner]"},
        "features": {"key": "features", "type": "PlanSpecsFeatures"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        cpus: Optional[List["_models.PlanSpecsCpusInner"]] = None,
        drives: Optional[List["_models.PlanSpecsDrivesInner"]] = None,
        nics: Optional[List["_models.PlanSpecsNicsInner"]] = None,
        features: Optional["_models.PlanSpecsFeatures"] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword cpus:
        :paramtype cpus: list[~equinixmetalpy.models.PlanSpecsCpusInner]
        :keyword drives:
        :paramtype drives: list[~equinixmetalpy.models.PlanSpecsDrivesInner]
        :keyword nics:
        :paramtype nics: list[~equinixmetalpy.models.PlanSpecsNicsInner]
        :keyword features:
        :paramtype features: ~equinixmetalpy.models.PlanSpecsFeatures
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.cpus = cpus
        self.drives = drives
        self.nics = nics
        self.features = features
        self.href = href


class PlanSpecsCpusInner(_serialization.Model):
    """PlanSpecsCpusInner.

    :ivar count:
    :vartype count: int
    :ivar type:
    :vartype type: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        type: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword count:
        :paramtype count: int
        :keyword type:
        :paramtype type: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.count = count
        self.type = type
        self.href = href


class PlanSpecsDrivesInner(_serialization.Model):
    """PlanSpecsDrivesInner.

    :ivar count:
    :vartype count: int
    :ivar type: Known values are: "HDD", "SSD", and "NVME".
    :vartype type: str or ~equinixmetalpy.models.PlanSpecsDrivesInnerType
    :ivar size:
    :vartype size: str
    :ivar category: Known values are: "boot", "cache", and "storage".
    :vartype category: str or ~equinixmetalpy.models.PlanSpecsDrivesInnerCategory
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "size": {"key": "size", "type": "str"},
        "category": {"key": "category", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        type: Optional[Union[str, "_models.PlanSpecsDrivesInnerType"]] = None,
        size: Optional[str] = None,
        category: Optional[Union[str, "_models.PlanSpecsDrivesInnerCategory"]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword count:
        :paramtype count: int
        :keyword type: Known values are: "HDD", "SSD", and "NVME".
        :paramtype type: str or ~equinixmetalpy.models.PlanSpecsDrivesInnerType
        :keyword size:
        :paramtype size: str
        :keyword category: Known values are: "boot", "cache", and "storage".
        :paramtype category: str or ~equinixmetalpy.models.PlanSpecsDrivesInnerCategory
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.count = count
        self.type = type
        self.size = size
        self.category = category
        self.href = href


class PlanSpecsFeatures(_serialization.Model):
    """PlanSpecsFeatures.

    :ivar raid:
    :vartype raid: bool
    :ivar txt:
    :vartype txt: bool
    :ivar uefi:
    :vartype uefi: bool
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "raid": {"key": "raid", "type": "bool"},
        "txt": {"key": "txt", "type": "bool"},
        "uefi": {"key": "uefi", "type": "bool"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        raid: Optional[bool] = None,
        txt: Optional[bool] = None,
        uefi: Optional[bool] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword raid:
        :paramtype raid: bool
        :keyword txt:
        :paramtype txt: bool
        :keyword uefi:
        :paramtype uefi: bool
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.raid = raid
        self.txt = txt
        self.uefi = uefi
        self.href = href


class PlanSpecsNicsInner(_serialization.Model):
    """PlanSpecsNicsInner.

    :ivar count:
    :vartype count: int
    :ivar type: Known values are: "1Gbps", "10Gbps", and "25Gbps".
    :vartype type: str or ~equinixmetalpy.models.PlanSpecsNicsInnerType
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "count": {"key": "count", "type": "int"},
        "type": {"key": "type", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        count: Optional[int] = None,
        type: Optional[Union[str, "_models.PlanSpecsNicsInnerType"]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword count:
        :paramtype count: int
        :keyword type: Known values are: "1Gbps", "10Gbps", and "25Gbps".
        :paramtype type: str or ~equinixmetalpy.models.PlanSpecsNicsInnerType
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.count = count
        self.type = type
        self.href = href


class Port(_serialization.Model):
    """Port is a hardware port associated with a reserved or instantiated hardware device.

    :ivar bond:
    :vartype bond: ~equinixmetalpy.models.BondPortData
    :ivar data:
    :vartype data: ~equinixmetalpy.models.PortData
    :ivar disbond_operation_supported: Indicates whether or not the bond can be broken on the port
     (when applicable).
    :vartype disbond_operation_supported: bool
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar type: Type is either "NetworkBondPort" for bond ports or "NetworkPort" for bondable
     ethernet ports. Known values are: "NetworkPort" and "NetworkBondPort".
    :vartype type: str or ~equinixmetalpy.models.PortType
    :ivar network_type: Composite network type of the bond. Known values are: "layer2-bonded",
     "layer2-individual", "layer3", "hybrid", and "hybrid-bonded".
    :vartype network_type: str or ~equinixmetalpy.models.PortNetworkType
    :ivar native_virtual_network:
    :vartype native_virtual_network: ~equinixmetalpy.models.VirtualNetwork
    :ivar virtual_networks:
    :vartype virtual_networks: list[~equinixmetalpy.models.Href]
    """

    _attribute_map = {
        "bond": {"key": "bond", "type": "BondPortData"},
        "data": {"key": "data", "type": "PortData"},
        "disbond_operation_supported": {
            "key": "disbond_operation_supported",
            "type": "bool",
        },
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "type": {"key": "type", "type": "str"},
        "network_type": {"key": "network_type", "type": "str"},
        "native_virtual_network": {
            "key": "native_virtual_network",
            "type": "VirtualNetwork",
        },
        "virtual_networks": {"key": "virtual_networks", "type": "[Href]"},
    }

    def __init__(
        self,
        *,
        bond: Optional["_models.BondPortData"] = None,
        data: Optional["_models.PortData"] = None,
        disbond_operation_supported: Optional[bool] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        type: Optional[Union[str, "_models.PortType"]] = None,
        network_type: Optional[Union[str, "_models.PortNetworkType"]] = None,
        native_virtual_network: Optional["_models.VirtualNetwork"] = None,
        virtual_networks: Optional[List["_models.Href"]] = None,
        **kwargs
    ):
        """
        :keyword bond:
        :paramtype bond: ~equinixmetalpy.models.BondPortData
        :keyword data:
        :paramtype data: ~equinixmetalpy.models.PortData
        :keyword disbond_operation_supported: Indicates whether or not the bond can be broken on the
         port (when applicable).
        :paramtype disbond_operation_supported: bool
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword name:
        :paramtype name: str
        :keyword type: Type is either "NetworkBondPort" for bond ports or "NetworkPort" for bondable
         ethernet ports. Known values are: "NetworkPort" and "NetworkBondPort".
        :paramtype type: str or ~equinixmetalpy.models.PortType
        :keyword network_type: Composite network type of the bond. Known values are: "layer2-bonded",
         "layer2-individual", "layer3", "hybrid", and "hybrid-bonded".
        :paramtype network_type: str or ~equinixmetalpy.models.PortNetworkType
        :keyword native_virtual_network:
        :paramtype native_virtual_network: ~equinixmetalpy.models.VirtualNetwork
        :keyword virtual_networks:
        :paramtype virtual_networks: list[~equinixmetalpy.models.Href]
        """
        super().__init__(**kwargs)
        self.bond = bond
        self.data = data
        self.disbond_operation_supported = disbond_operation_supported
        self.href = href
        self.id = id
        self.name = name
        self.type = type
        self.network_type = network_type
        self.native_virtual_network = native_virtual_network
        self.virtual_networks = virtual_networks


class PortData(_serialization.Model):
    """PortData.

    :ivar mac: MAC address is set for NetworkPort ports.
    :vartype mac: str
    :ivar bonded: Bonded is true for NetworkPort ports in a bond and NetworkBondPort ports that are
     active.
    :vartype bonded: bool
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "mac": {"key": "mac", "type": "str"},
        "bonded": {"key": "bonded", "type": "bool"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        mac: Optional[str] = None,
        bonded: Optional[bool] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword mac: MAC address is set for NetworkPort ports.
        :paramtype mac: str
        :keyword bonded: Bonded is true for NetworkPort ports in a bond and NetworkBondPort ports that
         are active.
        :paramtype bonded: bool
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.mac = mac
        self.bonded = bonded
        self.href = href


class Project(_serialization.Model):  # pylint: disable=too-many-instance-attributes
    """Project.

    :ivar bgp_config:
    :vartype bgp_config: ~equinixmetalpy.models.Href
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar devices:
    :vartype devices: list[~equinixmetalpy.models.Href]
    :ivar id:
    :vartype id: str
    :ivar invitations:
    :vartype invitations: list[~equinixmetalpy.models.Href]
    :ivar max_devices: Any object.
    :vartype max_devices: JSON
    :ivar members:
    :vartype members: list[~equinixmetalpy.models.Href]
    :ivar memberships:
    :vartype memberships: list[~equinixmetalpy.models.Href]
    :ivar name:
    :vartype name: str
    :ivar network_status: Any object.
    :vartype network_status: JSON
    :ivar payment_method:
    :vartype payment_method: ~equinixmetalpy.models.Href
    :ivar ssh_keys:
    :vartype ssh_keys: list[~equinixmetalpy.models.Href]
    :ivar updated_at:
    :vartype updated_at: ~datetime.datetime
    :ivar volumes:
    :vartype volumes: list[~equinixmetalpy.models.Href]
    :ivar organization:
    :vartype organization: ~equinixmetalpy.models.Href
    :ivar href:
    :vartype href: str
    :ivar backend_transfer_enabled:
    :vartype backend_transfer_enabled: bool
    """

    _attribute_map = {
        "bgp_config": {"key": "bgp_config", "type": "Href"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "customdata": {"key": "customdata", "type": "object"},
        "devices": {"key": "devices", "type": "[Href]"},
        "id": {"key": "id", "type": "str"},
        "invitations": {"key": "invitations", "type": "[Href]"},
        "max_devices": {"key": "max_devices", "type": "object"},
        "members": {"key": "members", "type": "[Href]"},
        "memberships": {"key": "memberships", "type": "[Href]"},
        "name": {"key": "name", "type": "str"},
        "network_status": {"key": "network_status", "type": "object"},
        "payment_method": {"key": "payment_method", "type": "Href"},
        "ssh_keys": {"key": "ssh_keys", "type": "[Href]"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
        "volumes": {"key": "volumes", "type": "[Href]"},
        "organization": {"key": "organization", "type": "Href"},
        "href": {"key": "href", "type": "str"},
        "backend_transfer_enabled": {"key": "backend_transfer_enabled", "type": "bool"},
    }

    def __init__(
        self,
        *,
        bgp_config: Optional["_models.Href"] = None,
        created_at: Optional[datetime.datetime] = None,
        customdata: Optional[JSON] = None,
        devices: Optional[List["_models.Href"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        invitations: Optional[List["_models.Href"]] = None,
        max_devices: Optional[JSON] = None,
        members: Optional[List["_models.Href"]] = None,
        memberships: Optional[List["_models.Href"]] = None,
        name: Optional[str] = None,
        network_status: Optional[JSON] = None,
        payment_method: Optional["_models.Href"] = None,
        ssh_keys: Optional[List["_models.Href"]] = None,
        updated_at: Optional[datetime.datetime] = None,
        volumes: Optional[List["_models.Href"]] = None,
        organization: Optional["_models.Href"] = None,
        href: Optional[str] = None,
        backend_transfer_enabled: Optional[bool] = None,
        **kwargs
    ):
        """
        :keyword bgp_config:
        :paramtype bgp_config: ~equinixmetalpy.models.Href
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword devices:
        :paramtype devices: list[~equinixmetalpy.models.Href]
        :keyword id:
        :paramtype id: str
        :keyword invitations:
        :paramtype invitations: list[~equinixmetalpy.models.Href]
        :keyword max_devices: Any object.
        :paramtype max_devices: JSON
        :keyword members:
        :paramtype members: list[~equinixmetalpy.models.Href]
        :keyword memberships:
        :paramtype memberships: list[~equinixmetalpy.models.Href]
        :keyword name:
        :paramtype name: str
        :keyword network_status: Any object.
        :paramtype network_status: JSON
        :keyword payment_method:
        :paramtype payment_method: ~equinixmetalpy.models.Href
        :keyword ssh_keys:
        :paramtype ssh_keys: list[~equinixmetalpy.models.Href]
        :keyword updated_at:
        :paramtype updated_at: ~datetime.datetime
        :keyword volumes:
        :paramtype volumes: list[~equinixmetalpy.models.Href]
        :keyword organization:
        :paramtype organization: ~equinixmetalpy.models.Href
        :keyword href:
        :paramtype href: str
        :keyword backend_transfer_enabled:
        :paramtype backend_transfer_enabled: bool
        """
        super().__init__(**kwargs)
        self.bgp_config = bgp_config
        self.created_at = created_at
        self.customdata = customdata
        self.devices = devices
        self.id = id
        self.invitations = invitations
        self.max_devices = max_devices
        self.members = members
        self.memberships = memberships
        self.name = name
        self.network_status = network_status
        self.payment_method = payment_method
        self.ssh_keys = ssh_keys
        self.updated_at = updated_at
        self.volumes = volumes
        self.organization = organization
        self.href = href
        self.backend_transfer_enabled = backend_transfer_enabled


class ProjectCreateFromRootInput(_serialization.Model):
    """ProjectCreateFromRootInput.

    All required parameters must be populated in order to send to Azure.

    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar name: Required.
    :vartype name: str
    :ivar organization_id:
    :vartype organization_id: str
    :ivar payment_method_id:
    :vartype payment_method_id: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "customdata": {"key": "customdata", "type": "object"},
        "name": {"key": "name", "type": "str"},
        "organization_id": {"key": "organization_id", "type": "str"},
        "payment_method_id": {"key": "payment_method_id", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        customdata: Optional[JSON] = None,
        organization_id: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword name: Required.
        :paramtype name: str
        :keyword organization_id:
        :paramtype organization_id: str
        :keyword payment_method_id:
        :paramtype payment_method_id: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.customdata = customdata
        self.name = name
        self.organization_id = organization_id
        self.payment_method_id = payment_method_id
        self.href = href


class ProjectCreateInput(_serialization.Model):
    """ProjectCreateInput.

    All required parameters must be populated in order to send to Azure.

    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar name: Required.
    :vartype name: str
    :ivar payment_method_id:
    :vartype payment_method_id: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "name": {"required": True},
    }

    _attribute_map = {
        "customdata": {"key": "customdata", "type": "object"},
        "name": {"key": "name", "type": "str"},
        "payment_method_id": {"key": "payment_method_id", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        name: str,
        customdata: Optional[JSON] = None,
        payment_method_id: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword name: Required.
        :paramtype name: str
        :keyword payment_method_id:
        :paramtype payment_method_id: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.customdata = customdata
        self.name = name
        self.payment_method_id = payment_method_id
        self.href = href


class ProjectList(_serialization.Model):
    """ProjectList.

    :ivar meta:
    :vartype meta: ~equinixmetalpy.models.Meta
    :ivar projects:
    :vartype projects: list[~equinixmetalpy.models.Project]
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "meta": {"key": "meta", "type": "Meta"},
        "projects": {"key": "projects", "type": "[Project]"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        meta: Optional["_models.Meta"] = None,
        projects: Optional[List["_models.Project"]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword meta:
        :paramtype meta: ~equinixmetalpy.models.Meta
        :keyword projects:
        :paramtype projects: list[~equinixmetalpy.models.Project]
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.meta = meta
        self.projects = projects
        self.href = href


class ProjectUpdateInput(_serialization.Model):
    """ProjectUpdateInput.

    :ivar backend_transfer_enabled:
    :vartype backend_transfer_enabled: bool
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar name:
    :vartype name: str
    :ivar payment_method_id:
    :vartype payment_method_id: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "backend_transfer_enabled": {"key": "backend_transfer_enabled", "type": "bool"},
        "customdata": {"key": "customdata", "type": "object"},
        "name": {"key": "name", "type": "str"},
        "payment_method_id": {"key": "payment_method_id", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        backend_transfer_enabled: Optional[bool] = None,
        customdata: Optional[JSON] = None,
        name: Optional[str] = None,
        payment_method_id: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword backend_transfer_enabled:
        :paramtype backend_transfer_enabled: bool
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword name:
        :paramtype name: str
        :keyword payment_method_id:
        :paramtype payment_method_id: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.backend_transfer_enabled = backend_transfer_enabled
        self.customdata = customdata
        self.name = name
        self.payment_method_id = payment_method_id
        self.href = href


class RequestIPReservation201Response(_serialization.Model):
    """RequestIPReservation201Response."""

    _attribute_map = {}

    def __init__(self, **kwargs):
        """ """
        super().__init__(**kwargs)


class RequestIPReservationRequest(_serialization.Model):
    """RequestIPReservationRequest."""

    _attribute_map = {}

    def __init__(self, **kwargs):
        """ """
        super().__init__(**kwargs)


class SSHKeyInput(_serialization.Model):
    """SSHKeyInput.

    :ivar key:
    :vartype key: str
    :ivar label:
    :vartype label: str
    :ivar href:
    :vartype href: str
    """

    _attribute_map = {
        "key": {"key": "key", "type": "str"},
        "label": {"key": "label", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        key: Optional[str] = None,
        label: Optional[str] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword key:
        :paramtype key: str
        :keyword label:
        :paramtype label: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.key = key
        self.label = label
        self.href = href


class User(_serialization.Model):  # pylint: disable=too-many-instance-attributes
    """User.

    :ivar avatar_thumb_url:
    :vartype avatar_thumb_url: str
    :ivar avatar_url:
    :vartype avatar_url: str
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar email:
    :vartype email: str
    :ivar emails:
    :vartype emails: list[~equinixmetalpy.models.Href]
    :ivar first_name:
    :vartype first_name: str
    :ivar fraud_score:
    :vartype fraud_score: str
    :ivar full_name:
    :vartype full_name: str
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar last_login_at:
    :vartype last_login_at: ~datetime.datetime
    :ivar last_name:
    :vartype last_name: str
    :ivar max_organizations:
    :vartype max_organizations: int
    :ivar max_projects:
    :vartype max_projects: int
    :ivar phone_number:
    :vartype phone_number: str
    :ivar short_id:
    :vartype short_id: str
    :ivar timezone:
    :vartype timezone: str
    :ivar two_factor_auth:
    :vartype two_factor_auth: str
    :ivar updated_at:
    :vartype updated_at: ~datetime.datetime
    """

    _attribute_map = {
        "avatar_thumb_url": {"key": "avatar_thumb_url", "type": "str"},
        "avatar_url": {"key": "avatar_url", "type": "str"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "customdata": {"key": "customdata", "type": "object"},
        "email": {"key": "email", "type": "str"},
        "emails": {"key": "emails", "type": "[Href]"},
        "first_name": {"key": "first_name", "type": "str"},
        "fraud_score": {"key": "fraud_score", "type": "str"},
        "full_name": {"key": "full_name", "type": "str"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "last_login_at": {"key": "last_login_at", "type": "iso-8601"},
        "last_name": {"key": "last_name", "type": "str"},
        "max_organizations": {"key": "max_organizations", "type": "int"},
        "max_projects": {"key": "max_projects", "type": "int"},
        "phone_number": {"key": "phone_number", "type": "str"},
        "short_id": {"key": "short_id", "type": "str"},
        "timezone": {"key": "timezone", "type": "str"},
        "two_factor_auth": {"key": "two_factor_auth", "type": "str"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        avatar_thumb_url: Optional[str] = None,
        avatar_url: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        customdata: Optional[JSON] = None,
        email: Optional[str] = None,
        emails: Optional[List["_models.Href"]] = None,
        first_name: Optional[str] = None,
        fraud_score: Optional[str] = None,
        full_name: Optional[str] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        last_login_at: Optional[datetime.datetime] = None,
        last_name: Optional[str] = None,
        max_organizations: Optional[int] = None,
        max_projects: Optional[int] = None,
        phone_number: Optional[str] = None,
        short_id: Optional[str] = None,
        timezone: Optional[str] = None,
        two_factor_auth: Optional[str] = None,
        updated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword avatar_thumb_url:
        :paramtype avatar_thumb_url: str
        :keyword avatar_url:
        :paramtype avatar_url: str
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword email:
        :paramtype email: str
        :keyword emails:
        :paramtype emails: list[~equinixmetalpy.models.Href]
        :keyword first_name:
        :paramtype first_name: str
        :keyword fraud_score:
        :paramtype fraud_score: str
        :keyword full_name:
        :paramtype full_name: str
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword last_login_at:
        :paramtype last_login_at: ~datetime.datetime
        :keyword last_name:
        :paramtype last_name: str
        :keyword max_organizations:
        :paramtype max_organizations: int
        :keyword max_projects:
        :paramtype max_projects: int
        :keyword phone_number:
        :paramtype phone_number: str
        :keyword short_id:
        :paramtype short_id: str
        :keyword timezone:
        :paramtype timezone: str
        :keyword two_factor_auth:
        :paramtype two_factor_auth: str
        :keyword updated_at:
        :paramtype updated_at: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.avatar_thumb_url = avatar_thumb_url
        self.avatar_url = avatar_url
        self.created_at = created_at
        self.customdata = customdata
        self.email = email
        self.emails = emails
        self.first_name = first_name
        self.fraud_score = fraud_score
        self.full_name = full_name
        self.href = href
        self.id = id
        self.last_login_at = last_login_at
        self.last_name = last_name
        self.max_organizations = max_organizations
        self.max_projects = max_projects
        self.phone_number = phone_number
        self.short_id = short_id
        self.timezone = timezone
        self.two_factor_auth = two_factor_auth
        self.updated_at = updated_at


class VirtualNetwork(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """VirtualNetwork.

    :ivar assigned_to:
    :vartype assigned_to: ~equinixmetalpy.models.Href
    :ivar assigned_to_virtual_circuit: True if the virtual network is attached to a virtual
     circuit. False if not.
    :vartype assigned_to_virtual_circuit: bool
    :ivar description:
    :vartype description: str
    :ivar facility:
    :vartype facility: ~equinixmetalpy.models.Href
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar instances: A list of instances with ports currently associated to this Virtual Network.
    :vartype instances: list[~equinixmetalpy.models.Href]
    :ivar metal_gateways: A list of metal gateways currently associated to this Virtual Network.
    :vartype metal_gateways: list[~equinixmetalpy.models.MetalGatewayLite]
    :ivar metro:
    :vartype metro: ~equinixmetalpy.models.Href
    :ivar metro_code: The Metro code of the metro in which this Virtual Network is defined.
    :vartype metro_code: str
    :ivar vxlan:
    :vartype vxlan: int
    """

    _attribute_map = {
        "assigned_to": {"key": "assigned_to", "type": "Href"},
        "assigned_to_virtual_circuit": {
            "key": "assigned_to_virtual_circuit",
            "type": "bool",
        },
        "description": {"key": "description", "type": "str"},
        "facility": {"key": "facility", "type": "Href"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "instances": {"key": "instances", "type": "[Href]"},
        "metal_gateways": {"key": "metal_gateways", "type": "[MetalGatewayLite]"},
        "metro": {"key": "metro", "type": "Href"},
        "metro_code": {"key": "metro_code", "type": "str"},
        "vxlan": {"key": "vxlan", "type": "int"},
    }

    def __init__(
        self,
        *,
        assigned_to: Optional["_models.Href"] = None,
        assigned_to_virtual_circuit: Optional[bool] = None,
        description: Optional[str] = None,
        facility: Optional["_models.Href"] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        instances: Optional[List["_models.Href"]] = None,
        metal_gateways: Optional[List["_models.MetalGatewayLite"]] = None,
        metro: Optional["_models.Href"] = None,
        metro_code: Optional[str] = None,
        vxlan: Optional[int] = None,
        **kwargs
    ):
        """
        :keyword assigned_to:
        :paramtype assigned_to: ~equinixmetalpy.models.Href
        :keyword assigned_to_virtual_circuit: True if the virtual network is attached to a virtual
         circuit. False if not.
        :paramtype assigned_to_virtual_circuit: bool
        :keyword description:
        :paramtype description: str
        :keyword facility:
        :paramtype facility: ~equinixmetalpy.models.Href
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword instances: A list of instances with ports currently associated to this Virtual
         Network.
        :paramtype instances: list[~equinixmetalpy.models.Href]
        :keyword metal_gateways: A list of metal gateways currently associated to this Virtual Network.
        :paramtype metal_gateways: list[~equinixmetalpy.models.MetalGatewayLite]
        :keyword metro:
        :paramtype metro: ~equinixmetalpy.models.Href
        :keyword metro_code: The Metro code of the metro in which this Virtual Network is defined.
        :paramtype metro_code: str
        :keyword vxlan:
        :paramtype vxlan: int
        """
        super().__init__(**kwargs)
        self.assigned_to = assigned_to
        self.assigned_to_virtual_circuit = assigned_to_virtual_circuit
        self.description = description
        self.facility = facility
        self.href = href
        self.id = id
        self.instances = instances
        self.metal_gateways = metal_gateways
        self.metro = metro
        self.metro_code = metro_code
        self.vxlan = vxlan


class Vrf(_serialization.Model):  # pylint: disable=too-many-instance-attributes
    """Vrf.

    :ivar id:
    :vartype id: str
    :ivar name:
    :vartype name: str
    :ivar description: Optional field that can be set to describe the VRF.
    :vartype description: str
    :ivar local_asn: A 4-byte ASN associated with the VRF.
    :vartype local_asn: int
    :ivar ip_ranges: A list of CIDR network addresses. Like ["10.0.0.0/16", "2001:d78::/56"].
    :vartype ip_ranges: list[str]
    :ivar project:
    :vartype project: ~equinixmetalpy.models.Project
    :ivar metro:
    :vartype metro: ~equinixmetalpy.models.Metro
    :ivar created_by:
    :vartype created_by: ~equinixmetalpy.models.User
    :ivar href:
    :vartype href: str
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar updated_at:
    :vartype updated_at: ~datetime.datetime
    """

    _attribute_map = {
        "id": {"key": "id", "type": "str"},
        "name": {"key": "name", "type": "str"},
        "description": {"key": "description", "type": "str"},
        "local_asn": {"key": "local_asn", "type": "int"},
        "ip_ranges": {"key": "ip_ranges", "type": "[str]"},
        "project": {"key": "project", "type": "Project"},
        "metro": {"key": "metro", "type": "Metro"},
        "created_by": {"key": "created_by", "type": "User"},
        "href": {"key": "href", "type": "str"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "updated_at": {"key": "updated_at", "type": "iso-8601"},
    }

    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        description: Optional[str] = None,
        local_asn: Optional[int] = None,
        ip_ranges: Optional[List[str]] = None,
        project: Optional["_models.Project"] = None,
        metro: Optional["_models.Metro"] = None,
        created_by: Optional["_models.User"] = None,
        href: Optional[str] = None,
        created_at: Optional[datetime.datetime] = None,
        updated_at: Optional[datetime.datetime] = None,
        **kwargs
    ):
        """
        :keyword id:
        :paramtype id: str
        :keyword name:
        :paramtype name: str
        :keyword description: Optional field that can be set to describe the VRF.
        :paramtype description: str
        :keyword local_asn: A 4-byte ASN associated with the VRF.
        :paramtype local_asn: int
        :keyword ip_ranges: A list of CIDR network addresses. Like ["10.0.0.0/16", "2001:d78::/56"].
        :paramtype ip_ranges: list[str]
        :keyword project:
        :paramtype project: ~equinixmetalpy.models.Project
        :keyword metro:
        :paramtype metro: ~equinixmetalpy.models.Metro
        :keyword created_by:
        :paramtype created_by: ~equinixmetalpy.models.User
        :keyword href:
        :paramtype href: str
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword updated_at:
        :paramtype updated_at: ~datetime.datetime
        """
        super().__init__(**kwargs)
        self.id = id
        self.name = name
        self.description = description
        self.local_asn = local_asn
        self.ip_ranges = ip_ranges
        self.project = project
        self.metro = metro
        self.created_by = created_by
        self.href = href
        self.created_at = created_at
        self.updated_at = updated_at


class VrfIpReservation(
    _serialization.Model
):  # pylint: disable=too-many-instance-attributes
    """VrfIpReservation.

    All required parameters must be populated in order to send to Azure.

    :ivar address_family:
    :vartype address_family: int
    :ivar cidr:
    :vartype cidr: int
    :ivar created_at:
    :vartype created_at: ~datetime.datetime
    :ivar created_by:
    :vartype created_by: ~equinixmetalpy.models.Href
    :ivar details:
    :vartype details: str
    :ivar href:
    :vartype href: str
    :ivar id:
    :vartype id: str
    :ivar metal_gateway:
    :vartype metal_gateway: ~equinixmetalpy.models.MetalGatewayLite
    :ivar netmask:
    :vartype netmask: str
    :ivar network:
    :vartype network: str
    :ivar project:
    :vartype project: ~equinixmetalpy.models.Project
    :ivar state:
    :vartype state: str
    :ivar tags:
    :vartype tags: list[str]
    :ivar type: Required. "vrf"
    :vartype type: str or ~equinixmetalpy.models.VrfIpReservationType
    :ivar vrf: Required.
    :vartype vrf: ~equinixmetalpy.models.Vrf
    :ivar public:
    :vartype public: bool
    :ivar management:
    :vartype management: bool
    :ivar manageable:
    :vartype manageable: bool
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar bill:
    :vartype bill: bool
    :ivar project_lite:
    :vartype project_lite: ~equinixmetalpy.models.Project
    :ivar address:
    :vartype address: str
    :ivar gateway:
    :vartype gateway: str
    :ivar metro:
    :vartype metro: ~equinixmetalpy.models.Metro
    """

    _validation = {
        "type": {"required": True},
        "vrf": {"required": True},
    }

    _attribute_map = {
        "address_family": {"key": "address_family", "type": "int"},
        "cidr": {"key": "cidr", "type": "int"},
        "created_at": {"key": "created_at", "type": "iso-8601"},
        "created_by": {"key": "created_by", "type": "Href"},
        "details": {"key": "details", "type": "str"},
        "href": {"key": "href", "type": "str"},
        "id": {"key": "id", "type": "str"},
        "metal_gateway": {"key": "metal_gateway", "type": "MetalGatewayLite"},
        "netmask": {"key": "netmask", "type": "str"},
        "network": {"key": "network", "type": "str"},
        "project": {"key": "project", "type": "Project"},
        "state": {"key": "state", "type": "str"},
        "tags": {"key": "tags", "type": "[str]"},
        "type": {"key": "type", "type": "str"},
        "vrf": {"key": "vrf", "type": "Vrf"},
        "public": {"key": "public", "type": "bool"},
        "management": {"key": "management", "type": "bool"},
        "manageable": {"key": "manageable", "type": "bool"},
        "customdata": {"key": "customdata", "type": "object"},
        "bill": {"key": "bill", "type": "bool"},
        "project_lite": {"key": "project_lite", "type": "Project"},
        "address": {"key": "address", "type": "str"},
        "gateway": {"key": "gateway", "type": "str"},
        "metro": {"key": "metro", "type": "Metro"},
    }

    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        type: Union[str, "_models.VrfIpReservationType"],
        vrf: "_models.Vrf",
        address_family: Optional[int] = None,
        cidr: Optional[int] = None,
        created_at: Optional[datetime.datetime] = None,
        created_by: Optional["_models.Href"] = None,
        details: Optional[str] = None,
        href: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        metal_gateway: Optional["_models.MetalGatewayLite"] = None,
        netmask: Optional[str] = None,
        network: Optional[str] = None,
        project: Optional["_models.Project"] = None,
        state: Optional[str] = None,
        tags: Optional[List[str]] = None,
        public: Optional[bool] = None,
        management: Optional[bool] = None,
        manageable: Optional[bool] = None,
        customdata: Optional[JSON] = None,
        bill: Optional[bool] = None,
        project_lite: Optional["_models.Project"] = None,
        address: Optional[str] = None,
        gateway: Optional[str] = None,
        metro: Optional["_models.Metro"] = None,
        **kwargs
    ):
        """
        :keyword address_family:
        :paramtype address_family: int
        :keyword cidr:
        :paramtype cidr: int
        :keyword created_at:
        :paramtype created_at: ~datetime.datetime
        :keyword created_by:
        :paramtype created_by: ~equinixmetalpy.models.Href
        :keyword details:
        :paramtype details: str
        :keyword href:
        :paramtype href: str
        :keyword id:
        :paramtype id: str
        :keyword metal_gateway:
        :paramtype metal_gateway: ~equinixmetalpy.models.MetalGatewayLite
        :keyword netmask:
        :paramtype netmask: str
        :keyword network:
        :paramtype network: str
        :keyword project:
        :paramtype project: ~equinixmetalpy.models.Project
        :keyword state:
        :paramtype state: str
        :keyword tags:
        :paramtype tags: list[str]
        :keyword type: Required. "vrf"
        :paramtype type: str or ~equinixmetalpy.models.VrfIpReservationType
        :keyword vrf: Required.
        :paramtype vrf: ~equinixmetalpy.models.Vrf
        :keyword public:
        :paramtype public: bool
        :keyword management:
        :paramtype management: bool
        :keyword manageable:
        :paramtype manageable: bool
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword bill:
        :paramtype bill: bool
        :keyword project_lite:
        :paramtype project_lite: ~equinixmetalpy.models.Project
        :keyword address:
        :paramtype address: str
        :keyword gateway:
        :paramtype gateway: str
        :keyword metro:
        :paramtype metro: ~equinixmetalpy.models.Metro
        """
        super().__init__(**kwargs)
        self.address_family = address_family
        self.cidr = cidr
        self.created_at = created_at
        self.created_by = created_by
        self.details = details
        self.href = href
        self.id = id
        self.metal_gateway = metal_gateway
        self.netmask = netmask
        self.network = network
        self.project = project
        self.state = state
        self.tags = tags
        self.type = type
        self.vrf = vrf
        self.public = public
        self.management = management
        self.manageable = manageable
        self.customdata = customdata
        self.bill = bill
        self.project_lite = project_lite
        self.address = address
        self.gateway = gateway
        self.metro = metro


class VrfIpReservationCreateInput(_serialization.Model):
    """VrfIpReservationCreateInput.

    All required parameters must be populated in order to send to Azure.

    :ivar cidr: The size of the VRF IP Reservation's subnet. Required.
    :vartype cidr: int
    :ivar customdata: Any object.
    :vartype customdata: JSON
    :ivar details:
    :vartype details: str
    :ivar network: The starting address for this VRF IP Reservation's subnet. Required.
    :vartype network: str
    :ivar tags:
    :vartype tags: list[str]
    :ivar type: Must be set to 'vrf'. Required.
    :vartype type: str
    :ivar vrf_id: The ID of the VRF in which this VRF IP Reservation is created. The VRF must have
     an existing IP Range that contains the requested subnet. This field may be aliased as just
     'vrf'. Required.
    :vartype vrf_id: str
    :ivar href:
    :vartype href: str
    """

    _validation = {
        "cidr": {"required": True},
        "network": {"required": True},
        "type": {"required": True},
        "vrf_id": {"required": True},
    }

    _attribute_map = {
        "cidr": {"key": "cidr", "type": "int"},
        "customdata": {"key": "customdata", "type": "object"},
        "details": {"key": "details", "type": "str"},
        "network": {"key": "network", "type": "str"},
        "tags": {"key": "tags", "type": "[str]"},
        "type": {"key": "type", "type": "str"},
        "vrf_id": {"key": "vrf_id", "type": "str"},
        "href": {"key": "href", "type": "str"},
    }

    def __init__(
        self,
        *,
        cidr: int,
        network: str,
        type: str,
        vrf_id: str,
        customdata: Optional[JSON] = None,
        details: Optional[str] = None,
        tags: Optional[List[str]] = None,
        href: Optional[str] = None,
        **kwargs
    ):
        """
        :keyword cidr: The size of the VRF IP Reservation's subnet. Required.
        :paramtype cidr: int
        :keyword customdata: Any object.
        :paramtype customdata: JSON
        :keyword details:
        :paramtype details: str
        :keyword network: The starting address for this VRF IP Reservation's subnet. Required.
        :paramtype network: str
        :keyword tags:
        :paramtype tags: list[str]
        :keyword type: Must be set to 'vrf'. Required.
        :paramtype type: str
        :keyword vrf_id: The ID of the VRF in which this VRF IP Reservation is created. The VRF must
         have an existing IP Range that contains the requested subnet. This field may be aliased as just
         'vrf'. Required.
        :paramtype vrf_id: str
        :keyword href:
        :paramtype href: str
        """
        super().__init__(**kwargs)
        self.cidr = cidr
        self.customdata = customdata
        self.details = details
        self.network = network
        self.tags = tags
        self.type = type
        self.vrf_id = vrf_id
        self.href = href

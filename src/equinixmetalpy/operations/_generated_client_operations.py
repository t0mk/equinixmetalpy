# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.3, generator: @autorest/python@6.0.1)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._serialization import Serializer
from .._vendor import MixinABC, _convert_request, _format_url_section

T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]
]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_delete_device_request(
    id: str, *, force_delete: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/devices/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if force_delete is not None:
        _params["force_delete"] = _SERIALIZER.query(
            "force_delete", force_delete, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="DELETE", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_find_device_by_id_request(
    id: str,
    *,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/devices/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_update_device_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/devices/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_find_organizations_request(
    *,
    personal: Optional[Union[str, "_models.Enum11"]] = None,
    without_projects: Optional[Union[str, "_models.Enum12"]] = None,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    page: int = 1,
    per_page: int = 10,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations")

    # Construct parameters
    if personal is not None:
        _params["personal"] = _SERIALIZER.query("personal", personal, "str")
    if without_projects is not None:
        _params["without_projects"] = _SERIALIZER.query(
            "without_projects", without_projects, "str"
        )
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")
    if page is not None:
        _params["page"] = _SERIALIZER.query(
            "page", page, "int", maximum=100000, minimum=1
        )
    if per_page is not None:
        _params["per_page"] = _SERIALIZER.query(
            "per_page", per_page, "int", maximum=1000, minimum=1
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_create_organization_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_delete_organization_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_find_organization_by_id_request(
    id: str,
    *,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_update_organization_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_find_organization_devices_request(
    id: str,
    *,
    facility: Optional[str] = None,
    hostname: Optional[str] = None,
    reserved: Optional[bool] = None,
    tag: Optional[str] = None,
    type: Optional[str] = None,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    page: int = 1,
    per_page: int = 10,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations/{id}/devices")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if facility is not None:
        _params["facility"] = _SERIALIZER.query("facility", facility, "str")
    if hostname is not None:
        _params["hostname"] = _SERIALIZER.query("hostname", hostname, "str")
    if reserved is not None:
        _params["reserved"] = _SERIALIZER.query("reserved", reserved, "bool")
    if tag is not None:
        _params["tag"] = _SERIALIZER.query("tag", tag, "str")
    if type is not None:
        _params["type"] = _SERIALIZER.query("type", type, "str")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")
    if page is not None:
        _params["page"] = _SERIALIZER.query(
            "page", page, "int", maximum=100000, minimum=1
        )
    if per_page is not None:
        _params["per_page"] = _SERIALIZER.query(
            "per_page", per_page, "int", maximum=1000, minimum=1
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_find_organization_projects_request(
    id: str,
    *,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    page: int = 1,
    per_page: int = 10,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations/{id}/projects")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")
    if page is not None:
        _params["page"] = _SERIALIZER.query(
            "page", page, "int", maximum=100000, minimum=1
        )
    if per_page is not None:
        _params["per_page"] = _SERIALIZER.query(
            "per_page", per_page, "int", maximum=1000, minimum=1
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_create_organization_project_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/organizations/{id}/projects")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_find_projects_request(
    *,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    page: int = 1,
    per_page: int = 10,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects")

    # Construct parameters
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")
    if page is not None:
        _params["page"] = _SERIALIZER.query(
            "page", page, "int", maximum=100000, minimum=1
        )
    if per_page is not None:
        _params["per_page"] = _SERIALIZER.query(
            "per_page", per_page, "int", maximum=1000, minimum=1
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_create_project_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_delete_project_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_find_project_by_id_request(
    id: str,
    *,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_update_project_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_find_project_devices_request(
    id: str,
    *,
    facility: Optional[str] = None,
    hostname: Optional[str] = None,
    reserved: Optional[bool] = None,
    tag: Optional[str] = None,
    type: Optional[str] = None,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    page: int = 1,
    per_page: int = 10,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}/devices")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if facility is not None:
        _params["facility"] = _SERIALIZER.query("facility", facility, "str")
    if hostname is not None:
        _params["hostname"] = _SERIALIZER.query("hostname", hostname, "str")
    if reserved is not None:
        _params["reserved"] = _SERIALIZER.query("reserved", reserved, "bool")
    if tag is not None:
        _params["tag"] = _SERIALIZER.query("tag", tag, "str")
    if type is not None:
        _params["type"] = _SERIALIZER.query("type", type, "str")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")
    if page is not None:
        _params["page"] = _SERIALIZER.query(
            "page", page, "int", maximum=100000, minimum=1
        )
    if per_page is not None:
        _params["per_page"] = _SERIALIZER.query(
            "per_page", per_page, "int", maximum=1000, minimum=1
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_create_device_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}/devices")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_find_ip_reservations_request(
    id: str,
    *,
    types: Optional[List[Union[str, "_models.Enum15"]]] = None,
    include: Optional[List[str]] = None,
    exclude: Optional[List[str]] = None,
    per_page: int = 250,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}/ips")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if types is not None:
        _params["types"] = _SERIALIZER.query("types", types, "[str]", div=",")
    if include is not None:
        _params["include"] = _SERIALIZER.query("include", include, "[str]", div=",")
    if exclude is not None:
        _params["exclude"] = _SERIALIZER.query("exclude", exclude, "[str]", div=",")
    if per_page is not None:
        _params["per_page"] = _SERIALIZER.query(
            "per_page", per_page, "int", maximum=1000, minimum=1
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_request_ip_reservation_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )  # type: Optional[str]
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "/projects/{id}/ips")
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


class GeneratedClientOperationsMixin(MixinABC):
    @distributed_trace
    def delete_device(
        self, id: str, force_delete: Optional[bool] = None, **kwargs: Any
    ) -> Optional[_models.Error]:
        """Delete the device.

        Deletes a device and deprovisions it in our datacenter.

        :param id: Device UUID. Required.
        :type id: str
        :param force_delete: Force the deletion of the device, by detaching any storage volume still
         active. Default value is None.
        :type force_delete: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Error or None or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Error or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.Error]]

        request = build_delete_device_request(
            id=id,
            force_delete=force_delete,
            template_url=self.delete_device.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_device.metadata = {"url": "/devices/{id}"}  # type: ignore

    @distributed_trace
    def find_device_by_id(
        self,
        id: str,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Retrieve a device.

        Type-specific options (such as facility for baremetal devices) will be included as part of the
        main data structure.
                                 State value can be one of: active inactive queued or provisioning.

        :param id: Device UUID. Required.
        :type id: str
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Device, _models.Error]]

        request = build_find_device_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            template_url=self.find_device_by_id.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("Device", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_device_by_id.metadata = {"url": "/devices/{id}"}  # type: ignore

    @overload
    def update_device(
        self,
        id: str,
        body: _models.DeviceUpdateInput,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Update the device.

        Updates the device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: Facility to update. Required.
        :type body: ~equinixmetalpy.models.DeviceUpdateInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_device(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Update the device.

        Updates the device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: Facility to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_device(
        self, id: str, body: Union[_models.DeviceUpdateInput, IO], **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Update the device.

        Updates the device.

        :param id: Device UUID. Required.
        :type id: str
        :param body: Facility to update. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.DeviceUpdateInput or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Device, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "DeviceUpdateInput")

        request = build_update_device_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.update_device.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("Device", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_device.metadata = {"url": "/devices/{id}"}  # type: ignore

    @distributed_trace
    def find_organizations(
        self,
        personal: Optional[Union[str, "_models.Enum11"]] = None,
        without_projects: Optional[Union[str, "_models.Enum12"]] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> Union[_models.OrganizationList, _models.Error]:
        """Retrieve all organizations.

        Returns a list of organizations that are accessible to the current user.

        :param personal: Include, exclude or show only personal organizations. Known values are:
         "include", "exclude", and "only". Default value is None.
        :type personal: str or ~equinixmetalpy.models.Enum11
        :param without_projects: Include, exclude or show only organizations that have no projects.
         Known values are: "include", "exclude", and "only". Default value is None.
        :type without_projects: str or ~equinixmetalpy.models.Enum12
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :param page: Page to return. Default value is 1.
        :type page: int
        :param per_page: Items returned per page. Default value is 10.
        :type per_page: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationList or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.OrganizationList or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.OrganizationList, _models.Error]]

        request = build_find_organizations_request(
            personal=personal,
            without_projects=without_projects,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            template_url=self.find_organizations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("OrganizationList", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_organizations.metadata = {"url": "/organizations"}  # type: ignore

    @overload
    def create_organization(
        self,
        body: _models.OrganizationInput,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Create an organization.

        Creates an organization.

        :param body: Organization to create. Required.
        :type body: ~equinixmetalpy.models.OrganizationInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_organization(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Create an organization.

        Creates an organization.

        :param body: Organization to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_organization(
        self, body: Union[_models.OrganizationInput, IO], **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Create an organization.

        Creates an organization.

        :param body: Organization to create. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.OrganizationInput or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Organization, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "OrganizationInput")

        request = build_create_organization_request(
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.create_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize("Organization", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization.metadata = {"url": "/organizations"}  # type: ignore

    @distributed_trace
    def delete_organization(self, id: str, **kwargs: Any) -> Optional[_models.Error]:
        """Delete the organization.

        Deletes the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Error or None or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Error or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.Error]]

        request = build_delete_organization_request(
            id=id,
            template_url=self.delete_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_organization.metadata = {"url": "/organizations/{id}"}  # type: ignore

    @distributed_trace
    def find_organization_by_id(
        self,
        id: str,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Retrieve an organization's details.

        Returns a single organization's details, if the user is authorized to view it.

        :param id: Organization UUID. Required.
        :type id: str
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Organization, _models.Error]]

        request = build_find_organization_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            template_url=self.find_organization_by_id.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("Organization", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_organization_by_id.metadata = {"url": "/organizations/{id}"}  # type: ignore

    @overload
    def update_organization(
        self,
        id: str,
        body: _models.OrganizationInput,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Update the organization.

        Updates the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Organization to update. Required.
        :type body: ~equinixmetalpy.models.OrganizationInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_organization(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Update the organization.

        Updates the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Organization to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_organization(
        self, id: str, body: Union[_models.OrganizationInput, IO], **kwargs: Any
    ) -> Union[_models.Organization, _models.Error]:
        """Update the organization.

        Updates the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Organization to update. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.OrganizationInput or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Organization or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Organization or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Organization, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "OrganizationInput")

        request = build_update_organization_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.update_organization.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("Organization", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization.metadata = {"url": "/organizations/{id}"}  # type: ignore

    @distributed_trace
    def find_organization_devices(
        self,
        id: str,
        facility: Optional[str] = None,
        hostname: Optional[str] = None,
        reserved: Optional[bool] = None,
        tag: Optional[str] = None,
        type: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> Union[_models.DeviceList, _models.Error]:
        """Retrieve all devices of an organization.

        Provides a collection of devices for a given organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param facility: Filter by device facility. Default value is None.
        :type facility: str
        :param hostname: Filter by partial hostname. Default value is None.
        :type hostname: str
        :param reserved: Filter only reserved instances. Default value is None.
        :type reserved: bool
        :param tag: Filter by device tag. Default value is None.
        :type tag: str
        :param type: Filter by instance type (ondemand,spot,reserved). Default value is None.
        :type type: str
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :param page: Page to return. Default value is 1.
        :type page: int
        :param per_page: Items returned per page. Default value is 10.
        :type per_page: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeviceList or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.DeviceList or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.DeviceList, _models.Error]]

        request = build_find_organization_devices_request(
            id=id,
            facility=facility,
            hostname=hostname,
            reserved=reserved,
            tag=tag,
            type=type,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            template_url=self.find_organization_devices.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceList", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_organization_devices.metadata = {"url": "/organizations/{id}/devices"}  # type: ignore

    @distributed_trace
    def find_organization_projects(
        self,
        id: str,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> Union[_models.ProjectList, _models.Error]:
        """Retrieve all projects of an organization.

        Returns a collection of projects that belong to the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :param page: Page to return. Default value is 1.
        :type page: int
        :param per_page: Items returned per page. Default value is 10.
        :type per_page: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectList or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.ProjectList or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.ProjectList, _models.Error]]

        request = build_find_organization_projects_request(
            id=id,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            template_url=self.find_organization_projects.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("ProjectList", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_organization_projects.metadata = {"url": "/organizations/{id}/projects"}  # type: ignore

    @overload
    def create_organization_project(
        self,
        id: str,
        body: _models.ProjectCreateInput,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Create a project for the organization.

        Creates a new project for the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Project to create. Required.
        :type body: ~equinixmetalpy.models.ProjectCreateInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_organization_project(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Create a project for the organization.

        Creates a new project for the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Project to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_organization_project(
        self, id: str, body: Union[_models.ProjectCreateInput, IO], **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Create a project for the organization.

        Creates a new project for the organization.

        :param id: Organization UUID. Required.
        :type id: str
        :param body: Project to create. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.ProjectCreateInput or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Project, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ProjectCreateInput")

        request = build_create_organization_project_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.create_organization_project.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize("Project", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization_project.metadata = {"url": "/organizations/{id}/projects"}  # type: ignore

    @distributed_trace
    def find_projects(
        self,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> Union[_models.ProjectList, _models.Error]:
        """Retrieve all projects.

        Returns a collection of projects that the current user is a member of.

        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :param page: Page to return. Default value is 1.
        :type page: int
        :param per_page: Items returned per page. Default value is 10.
        :type per_page: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectList or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.ProjectList or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.ProjectList, _models.Error]]

        request = build_find_projects_request(
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            template_url=self.find_projects.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("ProjectList", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_projects.metadata = {"url": "/projects"}  # type: ignore

    @overload
    def create_project(
        self,
        body: _models.ProjectCreateFromRootInput,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Create a project.

        Creates a new project for the user default organization. If the user don't have an
        organization, a new one will be created.

        :param body: Project to create. Required.
        :type body: ~equinixmetalpy.models.ProjectCreateFromRootInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_project(
        self, body: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Create a project.

        Creates a new project for the user default organization. If the user don't have an
        organization, a new one will be created.

        :param body: Project to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_project(
        self, body: Union[_models.ProjectCreateFromRootInput, IO], **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Create a project.

        Creates a new project for the user default organization. If the user don't have an
        organization, a new one will be created.

        :param body: Project to create. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.ProjectCreateFromRootInput or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Project, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ProjectCreateFromRootInput")

        request = build_create_project_request(
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.create_project.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize("Project", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project.metadata = {"url": "/projects"}  # type: ignore

    @distributed_trace
    def delete_project(self, id: str, **kwargs: Any) -> Optional[_models.Error]:
        """Delete the project.

        Deletes the project.

        :param id: Project UUID. Required.
        :type id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Error or None or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Error or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Optional[_models.Error]]

        request = build_delete_project_request(
            id=id,
            template_url=self.delete_project.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project.metadata = {"url": "/projects/{id}"}  # type: ignore

    @distributed_trace
    def find_project_by_id(
        self,
        id: str,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Retrieve a project.

        Returns a single project if the user has access.

        :param id: Project UUID. Required.
        :type id: str
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Project, _models.Error]]

        request = build_find_project_by_id_request(
            id=id,
            include=include,
            exclude=exclude,
            template_url=self.find_project_by_id.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("Project", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_project_by_id.metadata = {"url": "/projects/{id}"}  # type: ignore

    @overload
    def update_project(
        self,
        id: str,
        body: _models.ProjectUpdateInput,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Update the project.

        Updates the project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Project to update. Required.
        :type body: ~equinixmetalpy.models.ProjectUpdateInput
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_project(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Update the project.

        Updates the project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Project to update. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_project(
        self, id: str, body: Union[_models.ProjectUpdateInput, IO], **kwargs: Any
    ) -> Union[_models.Project, _models.Error]:
        """Update the project.

        Updates the project.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Project to update. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.ProjectUpdateInput or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Project or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Project or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Project, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "ProjectUpdateInput")

        request = build_update_project_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.update_project.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("Project", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project.metadata = {"url": "/projects/{id}"}  # type: ignore

    @distributed_trace
    def find_project_devices(
        self,
        id: str,
        facility: Optional[str] = None,
        hostname: Optional[str] = None,
        reserved: Optional[bool] = None,
        tag: Optional[str] = None,
        type: Optional[str] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        page: int = 1,
        per_page: int = 10,
        **kwargs: Any
    ) -> Union[_models.DeviceList, _models.Error]:
        """Retrieve all devices of a project.

        Provides a collection of devices for a given project.

        :param id: Project UUID. Required.
        :type id: str
        :param facility: Filter by device facility. Default value is None.
        :type facility: str
        :param hostname: Filter by partial hostname. Default value is None.
        :type hostname: str
        :param reserved: Filter only reserved instances. Default value is None.
        :type reserved: bool
        :param tag: Filter by device tag. Default value is None.
        :type tag: str
        :param type: Filter by instance type (ondemand,spot,reserved). Default value is None.
        :type type: str
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :param page: Page to return. Default value is 1.
        :type page: int
        :param per_page: Items returned per page. Default value is 10.
        :type per_page: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeviceList or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.DeviceList or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.DeviceList, _models.Error]]

        request = build_find_project_devices_request(
            id=id,
            facility=facility,
            hostname=hostname,
            reserved=reserved,
            tag=tag,
            type=type,
            include=include,
            exclude=exclude,
            page=page,
            per_page=per_page,
            template_url=self.find_project_devices.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("DeviceList", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_project_devices.metadata = {"url": "/projects/{id}/devices"}  # type: ignore

    @overload
    def create_device(
        self,
        id: str,
        body: _models.CreateDeviceRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Create a device.

        Creates a new device and provisions it in the specified location.

        Device type-specific options are accepted.  For example, ``baremetal`` devices accept
        ``operating_system``\ , ``hostname``\ , and ``plan``. These parameters may not be accepted for
        other device types. The default device type is ``baremetal``.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Device to create. Required.
        :type body: ~equinixmetalpy.models.CreateDeviceRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_device(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Create a device.

        Creates a new device and provisions it in the specified location.

        Device type-specific options are accepted.  For example, ``baremetal`` devices accept
        ``operating_system``\ , ``hostname``\ , and ``plan``. These parameters may not be accepted for
        other device types. The default device type is ``baremetal``.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Device to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_device(
        self, id: str, body: Union[_models.CreateDeviceRequest, IO], **kwargs: Any
    ) -> Union[_models.Device, _models.Error]:
        """Create a device.

        Creates a new device and provisions it in the specified location.

        Device type-specific options are accepted.  For example, ``baremetal`` devices accept
        ``operating_system``\ , ``hostname``\ , and ``plan``. These parameters may not be accepted for
        other device types. The default device type is ``baremetal``.

        :param id: Project UUID. Required.
        :type id: str
        :param body: Device to create. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.CreateDeviceRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Device or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.Device or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.Device, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "CreateDeviceRequest")

        request = build_create_device_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.create_device.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize("Device", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_device.metadata = {"url": "/projects/{id}/devices"}  # type: ignore

    @distributed_trace
    def find_ip_reservations(
        self,
        id: str,
        types: Optional[List[Union[str, "_models.Enum15"]]] = None,
        include: Optional[List[str]] = None,
        exclude: Optional[List[str]] = None,
        per_page: int = 250,
        **kwargs: Any
    ) -> Union[_models.IPReservationList, _models.Error]:
        """Retrieve all ip reservations.

        Provides a paginated list of IP reservations for a single project.

        :param id: Project UUID. Required.
        :type id: str
        :param types: Filter project IP reservations by reservation type. Default value is None.
        :type types: list[str or ~equinixmetalpy.models.Enum15]
        :param include: Nested attributes to include. Included objects will return their full
         attributes. Attribute names can be dotted (up to 3 levels) to included deeply
         nested objects. Default value is None.
        :type include: list[str]
        :param exclude: Nested attributes to exclude. Excluded objects will return only the href
         attribute. Attribute names can be dotted (up to 3 levels) to exclude deeply
         nested objects. Default value is None.
        :type exclude: list[str]
        :param per_page: Items returned per page. Default value is 250.
        :type per_page: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IPReservationList or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.IPReservationList or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.IPReservationList, _models.Error]]

        request = build_find_ip_reservations_request(
            id=id,
            types=types,
            include=include,
            exclude=exclude,
            per_page=per_page,
            template_url=self.find_ip_reservations.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            deserialized = self._deserialize("IPReservationList", pipeline_response)

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    find_ip_reservations.metadata = {"url": "/projects/{id}/ips"}  # type: ignore

    @overload
    def request_ip_reservation(
        self,
        id: str,
        body: _models.RequestIPReservationRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.RequestIPReservation201Response, _models.Error]:
        """Requesting IP reservations.

        Request more IP space for a project in order to have additional IP addresses to assign to
        devices.  If the request is within the max quota, an IP reservation will be created. If the
        project will exceed its IP quota, a request will be submitted for review, and will return an IP
        Reservation with a ``state`` of ``pending``. You can automatically have the request fail with
        HTTP status 422 instead of triggering the review process by providing the
        ``fail_on_approval_required`` parameter set to ``true`` in the request.

        :param id: Project UUID. Required.
        :type id: str
        :param body: IP Reservation Request to create. Required.
        :type body: ~equinixmetalpy.models.RequestIPReservationRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: RequestIPReservation201Response or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.RequestIPReservation201Response or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def request_ip_reservation(
        self,
        id: str,
        body: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Union[_models.RequestIPReservation201Response, _models.Error]:
        """Requesting IP reservations.

        Request more IP space for a project in order to have additional IP addresses to assign to
        devices.  If the request is within the max quota, an IP reservation will be created. If the
        project will exceed its IP quota, a request will be submitted for review, and will return an IP
        Reservation with a ``state`` of ``pending``. You can automatically have the request fail with
        HTTP status 422 instead of triggering the review process by providing the
        ``fail_on_approval_required`` parameter set to ``true`` in the request.

        :param id: Project UUID. Required.
        :type id: str
        :param body: IP Reservation Request to create. Required.
        :type body: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: RequestIPReservation201Response or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.RequestIPReservation201Response or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def request_ip_reservation(
        self,
        id: str,
        body: Union[_models.RequestIPReservationRequest, IO],
        **kwargs: Any
    ) -> Union[_models.RequestIPReservation201Response, _models.Error]:
        """Requesting IP reservations.

        Request more IP space for a project in order to have additional IP addresses to assign to
        devices.  If the request is within the max quota, an IP reservation will be created. If the
        project will exceed its IP quota, a request will be submitted for review, and will return an IP
        Reservation with a ``state`` of ``pending``. You can automatically have the request fail with
        HTTP status 422 instead of triggering the review process by providing the
        ``fail_on_approval_required`` parameter set to ``true`` in the request.

        :param id: Project UUID. Required.
        :type id: str
        :param body: IP Reservation Request to create. Is either a model type or a IO type. Required.
        :type body: ~equinixmetalpy.models.RequestIPReservationRequest or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: RequestIPReservation201Response or Error or the result of cls(response)
        :rtype: ~equinixmetalpy.models.RequestIPReservation201Response or ~equinixmetalpy.models.Error
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )  # type: Optional[str]
        cls = kwargs.pop(
            "cls", None
        )  # type: ClsType[Union[_models.RequestIPReservation201Response, _models.Error]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = self._serialize.body(body, "RequestIPReservationRequest")

        request = build_request_ip_reservation_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            template_url=self.request_ip_reservation.metadata["url"],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 401, 403, 404, 422]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.status_code == 201:
            deserialized = self._deserialize(
                "RequestIPReservation201Response", pipeline_response
            )

        if response.status_code == 401:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 403:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize("Error", pipeline_response)

        if response.status_code == 422:
            deserialized = self._deserialize("Error", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    request_ip_reservation.metadata = {"url": "/projects/{id}/ips"}  # type: ignore
